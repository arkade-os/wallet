/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Bf(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function wi(e, t = "") {
  if (!Number.isSafeInteger(e) || e < 0) {
    const n = t && `"${t}" `;
    throw new Error(`${n}expected integer >0, got ${e}`);
  }
}
function yt(e, t, n = "") {
  const r = Bf(e), i = e?.length, s = t !== void 0;
  if (!r || s && i !== t) {
    const o = n && `"${n}" `, a = s ? ` of length ${t}` : "", c = r ? `length=${i}` : `type=${typeof e}`;
    throw new Error(o + "expected Uint8Array" + a + ", got " + c);
  }
  return e;
}
function xy(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  wi(e.outputLen), wi(e.blockLen);
}
function Ra(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function dE(e, t) {
  yt(e, void 0, "digestInto() output");
  const n = t.outputLen;
  if (e.length < n)
    throw new Error('"digestInto() output" expected to be of length >=' + n);
}
function Pa(...e) {
  for (let t = 0; t < e.length; t++)
    e[t].fill(0);
}
function Eu(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function on(e, t) {
  return e << 32 - t | e >>> t;
}
const Ty = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", hE = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Pc(e) {
  if (yt(e), Ty)
    return e.toHex();
  let t = "";
  for (let n = 0; n < e.length; n++)
    t += hE[e[n]];
  return t;
}
const Rn = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function uh(e) {
  if (e >= Rn._0 && e <= Rn._9)
    return e - Rn._0;
  if (e >= Rn.A && e <= Rn.F)
    return e - (Rn.A - 10);
  if (e >= Rn.a && e <= Rn.f)
    return e - (Rn.a - 10);
}
function Na(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (Ty)
    return Uint8Array.fromHex(e);
  const t = e.length, n = t / 2;
  if (t % 2)
    throw new Error("hex string expected, got unpadded hex of length " + t);
  const r = new Uint8Array(n);
  for (let i = 0, s = 0; i < n; i++, s += 2) {
    const o = uh(e.charCodeAt(s)), a = uh(e.charCodeAt(s + 1));
    if (o === void 0 || a === void 0) {
      const c = e[s] + e[s + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + s);
    }
    r[i] = o * 16 + a;
  }
  return r;
}
function En(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    yt(i), t += i.length;
  }
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const s = e[r];
    n.set(s, i), i += s.length;
  }
  return n;
}
function pE(e, t = {}) {
  const n = (i, s) => e(s).update(i).digest(), r = e(void 0);
  return n.outputLen = r.outputLen, n.blockLen = r.blockLen, n.create = (i) => e(i), Object.assign(n, t), Object.freeze(n);
}
function Nc(e = 32) {
  const t = typeof globalThis == "object" ? globalThis.crypto : null;
  if (typeof t?.getRandomValues != "function")
    throw new Error("crypto.getRandomValues must be defined");
  return t.getRandomValues(new Uint8Array(e));
}
const gE = (e) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, e])
});
function yE(e, t, n) {
  return e & t ^ ~e & n;
}
function wE(e, t, n) {
  return e & t ^ e & n ^ t & n;
}
let mE = class {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = !1;
  length = 0;
  pos = 0;
  destroyed = !1;
  constructor(t, n, r, i) {
    this.blockLen = t, this.outputLen = n, this.padOffset = r, this.isLE = i, this.buffer = new Uint8Array(t), this.view = Eu(this.buffer);
  }
  update(t) {
    Ra(this), yt(t);
    const { view: n, buffer: r, blockLen: i } = this, s = t.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = Eu(t);
        for (; i <= s - o; o += i)
          this.process(c, o);
        continue;
      }
      r.set(t.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(n, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Ra(this), dE(t, this), this.finished = !0;
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    n[o++] = 128, Pa(this.buffer.subarray(o)), this.padOffset > i - o && (this.process(r, 0), o = 0);
    for (let f = o; f < i; f++)
      n[f] = 0;
    r.setBigUint64(i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = Eu(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      a.setUint32(4 * f, l[f], s);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t ||= new this.constructor(), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a } = this;
    return t.destroyed = o, t.finished = s, t.length = i, t.pos = a, i % n && t.buffer.set(r), t;
  }
  clone() {
    return this._cloneInto();
  }
};
const tr = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), bE = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), er = /* @__PURE__ */ new Uint32Array(64);
let EE = class extends mE {
  constructor(t) {
    super(64, t, 8, !1);
  }
  get() {
    const { A: t, B: n, C: r, D: i, E: s, F: o, G: a, H: c } = this;
    return [t, n, r, i, s, o, a, c];
  }
  // prettier-ignore
  set(t, n, r, i, s, o, a, c) {
    this.A = t | 0, this.B = n | 0, this.C = r | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, n) {
    for (let f = 0; f < 16; f++, n += 4)
      er[f] = t.getUint32(n, !1);
    for (let f = 16; f < 64; f++) {
      const h = er[f - 15], g = er[f - 2], d = on(h, 7) ^ on(h, 18) ^ h >>> 3, p = on(g, 17) ^ on(g, 19) ^ g >>> 10;
      er[f] = p + er[f - 7] + d + er[f - 16] | 0;
    }
    let { A: r, B: i, C: s, D: o, E: a, F: c, G: u, H: l } = this;
    for (let f = 0; f < 64; f++) {
      const h = on(a, 6) ^ on(a, 11) ^ on(a, 25), g = l + h + yE(a, c, u) + bE[f] + er[f] | 0, p = (on(r, 2) ^ on(r, 13) ^ on(r, 22)) + wE(r, i, s) | 0;
      l = u, u = c, c = a, a = o + g | 0, o = s, s = i, i = r, r = g + p | 0;
    }
    r = r + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, i, s, o, a, c, u, l);
  }
  roundClean() {
    Pa(er);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), Pa(this.buffer);
  }
}, xE = class extends EE {
  // We cannot use array here since array allows indexing by variable
  // which means optimizer/compiler cannot use registers.
  A = tr[0] | 0;
  B = tr[1] | 0;
  C = tr[2] | 0;
  D = tr[3] | 0;
  E = tr[4] | 0;
  F = tr[5] | 0;
  G = tr[6] | 0;
  H = tr[7] | 0;
  constructor() {
    super(32);
  }
};
const yl = /* @__PURE__ */ pE(
  () => new xE(),
  /* @__PURE__ */ gE(1)
);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Cf = /* @__PURE__ */ BigInt(0), wl = /* @__PURE__ */ BigInt(1);
function La(e, t = "") {
  if (typeof e != "boolean") {
    const n = t && `"${t}" `;
    throw new Error(n + "expected boolean, got type=" + typeof e);
  }
  return e;
}
function Sy(e) {
  if (typeof e == "bigint") {
    if (!sa(e))
      throw new Error("positive bigint expected, got " + e);
  } else
    wi(e);
  return e;
}
function Oo(e) {
  const t = Sy(e).toString(16);
  return t.length & 1 ? "0" + t : t;
}
function vy(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return e === "" ? Cf : BigInt("0x" + e);
}
function Yn(e) {
  return vy(Pc(e));
}
function ky(e) {
  return vy(Pc(TE(yt(e)).reverse()));
}
function Lc(e, t) {
  wi(t), e = Sy(e);
  const n = Na(e.toString(16).padStart(t * 2, "0"));
  if (n.length !== t)
    throw new Error("number too large");
  return n;
}
function Ay(e, t) {
  return Lc(e, t).reverse();
}
function Rf(e, t) {
  if (e.length !== t.length)
    return !1;
  let n = 0;
  for (let r = 0; r < e.length; r++)
    n |= e[r] ^ t[r];
  return n === 0;
}
function TE(e) {
  return Uint8Array.from(e);
}
function SE(e) {
  return Uint8Array.from(e, (t, n) => {
    const r = t.charCodeAt(0);
    if (t.length !== 1 || r > 127)
      throw new Error(`string contains non-ASCII character "${e[n]}" with code ${r} at position ${n}`);
    return r;
  });
}
const sa = (e) => typeof e == "bigint" && Cf <= e;
function vE(e, t, n) {
  return sa(e) && sa(t) && sa(n) && t <= e && e < n;
}
function $y(e, t, n, r) {
  if (!vE(t, n, r))
    throw new Error("expected valid " + e + ": " + n + " <= n < " + r + ", got " + t);
}
function kE(e) {
  let t;
  for (t = 0; e > Cf; e >>= wl, t += 1)
    ;
  return t;
}
const Pf = (e) => (wl << BigInt(e)) - wl;
function AE(e, t, n) {
  if (wi(e, "hashLen"), wi(t, "qByteLen"), typeof n != "function")
    throw new Error("hmacFn must be a function");
  const r = (y) => new Uint8Array(y), i = Uint8Array.of(), s = Uint8Array.of(0), o = Uint8Array.of(1), a = 1e3;
  let c = r(e), u = r(e), l = 0;
  const f = () => {
    c.fill(1), u.fill(0), l = 0;
  }, h = (...y) => n(u, En(c, ...y)), g = (y = i) => {
    u = h(s, y), c = h(), y.length !== 0 && (u = h(o, y), c = h());
  }, d = () => {
    if (l++ >= a)
      throw new Error("drbg: tried max amount of iterations");
    let y = 0;
    const x = [];
    for (; y < t; ) {
      c = h();
      const S = c.slice();
      x.push(S), y += c.length;
    }
    return En(...x);
  };
  return (y, x) => {
    f(), g(y);
    let S;
    for (; !(S = x(d())); )
      g();
    return f(), S;
  };
}
function Nf(e, t = {}, n = {}) {
  if (!e || typeof e != "object")
    throw new Error("expected valid options object");
  function r(s, o, a) {
    const c = e[s];
    if (a && c === void 0)
      return;
    const u = typeof c;
    if (u !== o || c === null)
      throw new Error(`param "${s}" is invalid: expected ${o}, got ${u}`);
  }
  const i = (s, o) => Object.entries(s).forEach(([a, c]) => r(a, c, o));
  i(t, !1), i(n, !0);
}
function lh(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return (n, ...r) => {
    const i = t.get(n);
    if (i !== void 0)
      return i;
    const s = e(n, ...r);
    return t.set(n, s), s;
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const se = /* @__PURE__ */ BigInt(0), Qt = /* @__PURE__ */ BigInt(1), ei = /* @__PURE__ */ BigInt(2), Iy = /* @__PURE__ */ BigInt(3), Oy = /* @__PURE__ */ BigInt(4), By = /* @__PURE__ */ BigInt(5), $E = /* @__PURE__ */ BigInt(7), Cy = /* @__PURE__ */ BigInt(8), IE = /* @__PURE__ */ BigInt(9), Ry = /* @__PURE__ */ BigInt(16);
function Fe(e, t) {
  const n = e % t;
  return n >= se ? n : t + n;
}
function Se(e, t, n) {
  let r = e;
  for (; t-- > se; )
    r *= r, r %= n;
  return r;
}
function fh(e, t) {
  if (e === se)
    throw new Error("invert: expected non-zero number");
  if (t <= se)
    throw new Error("invert: expected positive modulus, got " + t);
  let n = Fe(e, t), r = t, i = se, s = Qt;
  for (; n !== se; ) {
    const a = r / n, c = r % n, u = i - s * a;
    r = n, n = c, i = s, s = u;
  }
  if (r !== Qt)
    throw new Error("invert: does not exist");
  return Fe(i, t);
}
function Lf(e, t, n) {
  if (!e.eql(e.sqr(t), n))
    throw new Error("Cannot find square root");
}
function Py(e, t) {
  const n = (e.ORDER + Qt) / Oy, r = e.pow(t, n);
  return Lf(e, r, t), r;
}
function OE(e, t) {
  const n = (e.ORDER - By) / Cy, r = e.mul(t, ei), i = e.pow(r, n), s = e.mul(t, i), o = e.mul(e.mul(s, ei), i), a = e.mul(s, e.sub(o, e.ONE));
  return Lf(e, a, t), a;
}
function BE(e) {
  const t = Uc(e), n = Ny(e), r = n(t, t.neg(t.ONE)), i = n(t, r), s = n(t, t.neg(r)), o = (e + $E) / Ry;
  return (a, c) => {
    let u = a.pow(c, o), l = a.mul(u, r);
    const f = a.mul(u, i), h = a.mul(u, s), g = a.eql(a.sqr(l), c), d = a.eql(a.sqr(f), c);
    u = a.cmov(u, l, g), l = a.cmov(h, f, d);
    const p = a.eql(a.sqr(l), c), y = a.cmov(u, l, p);
    return Lf(a, y, c), y;
  };
}
function Ny(e) {
  if (e < Iy)
    throw new Error("sqrt is not defined for small field");
  let t = e - Qt, n = 0;
  for (; t % ei === se; )
    t /= ei, n++;
  let r = ei;
  const i = Uc(e);
  for (; dh(i, r) === 1; )
    if (r++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (n === 1)
    return Py;
  let s = i.pow(r, t);
  const o = (t + Qt) / ei;
  return function(c, u) {
    if (c.is0(u))
      return u;
    if (dh(c, u) !== 1)
      throw new Error("Cannot find square root");
    let l = n, f = c.mul(c.ONE, s), h = c.pow(u, t), g = c.pow(u, o);
    for (; !c.eql(h, c.ONE); ) {
      if (c.is0(h))
        return c.ZERO;
      let d = 1, p = c.sqr(h);
      for (; !c.eql(p, c.ONE); )
        if (d++, p = c.sqr(p), d === l)
          throw new Error("Cannot find square root");
      const y = Qt << BigInt(l - d - 1), x = c.pow(f, y);
      l = d, f = c.sqr(x), h = c.mul(h, f), g = c.mul(g, x);
    }
    return g;
  };
}
function CE(e) {
  return e % Oy === Iy ? Py : e % Cy === By ? OE : e % Ry === IE ? BE(e) : Ny(e);
}
const RE = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function PE(e) {
  const t = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  }, n = RE.reduce((r, i) => (r[i] = "function", r), t);
  return Nf(e, n), e;
}
function NE(e, t, n) {
  if (n < se)
    throw new Error("invalid exponent, negatives unsupported");
  if (n === se)
    return e.ONE;
  if (n === Qt)
    return t;
  let r = e.ONE, i = t;
  for (; n > se; )
    n & Qt && (r = e.mul(r, i)), i = e.sqr(i), n >>= Qt;
  return r;
}
function Ly(e, t, n = !1) {
  const r = new Array(t.length).fill(n ? e.ZERO : void 0), i = t.reduce((o, a, c) => e.is0(a) ? o : (r[c] = o, e.mul(o, a)), e.ONE), s = e.inv(i);
  return t.reduceRight((o, a, c) => e.is0(a) ? o : (r[c] = e.mul(o, r[c]), e.mul(o, a)), s), r;
}
function dh(e, t) {
  const n = (e.ORDER - Qt) / ei, r = e.pow(t, n), i = e.eql(r, e.ONE), s = e.eql(r, e.ZERO), o = e.eql(r, e.neg(e.ONE));
  if (!i && !s && !o)
    throw new Error("invalid Legendre symbol result");
  return i ? 1 : s ? 0 : -1;
}
function LE(e, t) {
  t !== void 0 && wi(t);
  const n = t !== void 0 ? t : e.toString(2).length, r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
let UE = class {
  ORDER;
  BITS;
  BYTES;
  isLE;
  ZERO = se;
  ONE = Qt;
  _lengths;
  _sqrt;
  // cached sqrt
  _mod;
  constructor(t, n = {}) {
    if (t <= se)
      throw new Error("invalid field: expected ORDER > 0, got " + t);
    let r;
    this.isLE = !1, n != null && typeof n == "object" && (typeof n.BITS == "number" && (r = n.BITS), typeof n.sqrt == "function" && (this.sqrt = n.sqrt), typeof n.isLE == "boolean" && (this.isLE = n.isLE), n.allowedLengths && (this._lengths = n.allowedLengths?.slice()), typeof n.modFromBytes == "boolean" && (this._mod = n.modFromBytes));
    const { nBitLength: i, nByteLength: s } = LE(t, r);
    if (s > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = t, this.BITS = i, this.BYTES = s, this._sqrt = void 0, Object.preventExtensions(this);
  }
  create(t) {
    return Fe(t, this.ORDER);
  }
  isValid(t) {
    if (typeof t != "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof t);
    return se <= t && t < this.ORDER;
  }
  is0(t) {
    return t === se;
  }
  // is valid and invertible
  isValidNot0(t) {
    return !this.is0(t) && this.isValid(t);
  }
  isOdd(t) {
    return (t & Qt) === Qt;
  }
  neg(t) {
    return Fe(-t, this.ORDER);
  }
  eql(t, n) {
    return t === n;
  }
  sqr(t) {
    return Fe(t * t, this.ORDER);
  }
  add(t, n) {
    return Fe(t + n, this.ORDER);
  }
  sub(t, n) {
    return Fe(t - n, this.ORDER);
  }
  mul(t, n) {
    return Fe(t * n, this.ORDER);
  }
  pow(t, n) {
    return NE(this, t, n);
  }
  div(t, n) {
    return Fe(t * fh(n, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(t) {
    return t * t;
  }
  addN(t, n) {
    return t + n;
  }
  subN(t, n) {
    return t - n;
  }
  mulN(t, n) {
    return t * n;
  }
  inv(t) {
    return fh(t, this.ORDER);
  }
  sqrt(t) {
    return this._sqrt || (this._sqrt = CE(this.ORDER)), this._sqrt(this, t);
  }
  toBytes(t) {
    return this.isLE ? Ay(t, this.BYTES) : Lc(t, this.BYTES);
  }
  fromBytes(t, n = !1) {
    yt(t);
    const { _lengths: r, BYTES: i, isLE: s, ORDER: o, _mod: a } = this;
    if (r) {
      if (!r.includes(t.length) || t.length > i)
        throw new Error("Field.fromBytes: expected " + r + " bytes, got " + t.length);
      const u = new Uint8Array(i);
      u.set(t, s ? 0 : u.length - t.length), t = u;
    }
    if (t.length !== i)
      throw new Error("Field.fromBytes: expected " + i + " bytes, got " + t.length);
    let c = s ? ky(t) : Yn(t);
    if (a && (c = Fe(c, o)), !n && !this.isValid(c))
      throw new Error("invalid field element: outside of range 0..ORDER");
    return c;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(t) {
    return Ly(this, t);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(t, n, r) {
    return r ? n : t;
  }
};
function Uc(e, t = {}) {
  return new UE(e, t);
}
function Uy(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function _y(e) {
  const t = Uy(e);
  return t + Math.ceil(t / 2);
}
function Dy(e, t, n = !1) {
  yt(e);
  const r = e.length, i = Uy(t), s = _y(t);
  if (r < 16 || r < s || r > 1024)
    throw new Error("expected " + s + "-1024 bytes of input, got " + r);
  const o = n ? ky(e) : Yn(e), a = Fe(o, t - Qt) + Qt;
  return n ? Ay(a, i) : Lc(a, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Yi = /* @__PURE__ */ BigInt(0), ni = /* @__PURE__ */ BigInt(1);
function Ua(e, t) {
  const n = t.negate();
  return e ? n : t;
}
function hh(e, t) {
  const n = Ly(e.Fp, t.map((r) => r.Z));
  return t.map((r, i) => e.fromAffine(r.toAffine(n[i])));
}
function Vy(e, t) {
  if (!Number.isSafeInteger(e) || e <= 0 || e > t)
    throw new Error("invalid window size, expected [1.." + t + "], got W=" + e);
}
function xu(e, t) {
  Vy(e, t);
  const n = Math.ceil(t / e) + 1, r = 2 ** (e - 1), i = 2 ** e, s = Pf(e), o = BigInt(e);
  return { windows: n, windowSize: r, mask: s, maxNumber: i, shiftBy: o };
}
function ph(e, t, n) {
  const { windowSize: r, mask: i, maxNumber: s, shiftBy: o } = n;
  let a = Number(e & i), c = e >> o;
  a > r && (a -= s, c += ni);
  const u = t * r, l = u + Math.abs(a) - 1, f = a === 0, h = a < 0, g = t % 2 !== 0;
  return { nextN: c, offset: l, isZero: f, isNeg: h, isNegF: g, offsetF: u };
}
const Tu = /* @__PURE__ */ new WeakMap(), My = /* @__PURE__ */ new WeakMap();
function Su(e) {
  return My.get(e) || 1;
}
function gh(e) {
  if (e !== Yi)
    throw new Error("invalid wNAF");
}
let _E = class {
  BASE;
  ZERO;
  Fn;
  bits;
  // Parametrized with a given Point class (not individual point)
  constructor(t, n) {
    this.BASE = t.BASE, this.ZERO = t.ZERO, this.Fn = t.Fn, this.bits = n;
  }
  // non-const time multiplication ladder
  _unsafeLadder(t, n, r = this.ZERO) {
    let i = t;
    for (; n > Yi; )
      n & ni && (r = r.add(i)), i = i.double(), n >>= ni;
    return r;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:
   * - ùëä is the window size
   * - ùëõ is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(t, n) {
    const { windows: r, windowSize: i } = xu(n, this.bits), s = [];
    let o = t, a = o;
    for (let c = 0; c < r; c++) {
      a = o, s.push(a);
      for (let u = 1; u < i; u++)
        a = a.add(o), s.push(a);
      o = a.double();
    }
    return s;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(t, n, r) {
    if (!this.Fn.isValid(r))
      throw new Error("invalid scalar");
    let i = this.ZERO, s = this.BASE;
    const o = xu(t, this.bits);
    for (let a = 0; a < o.windows; a++) {
      const { nextN: c, offset: u, isZero: l, isNeg: f, isNegF: h, offsetF: g } = ph(r, a, o);
      r = c, l ? s = s.add(Ua(h, n[g])) : i = i.add(Ua(f, n[u]));
    }
    return gh(r), { p: i, f: s };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(t, n, r, i = this.ZERO) {
    const s = xu(t, this.bits);
    for (let o = 0; o < s.windows && r !== Yi; o++) {
      const { nextN: a, offset: c, isZero: u, isNeg: l } = ph(r, o, s);
      if (r = a, !u) {
        const f = n[c];
        i = i.add(l ? f.negate() : f);
      }
    }
    return gh(r), i;
  }
  getPrecomputes(t, n, r) {
    let i = Tu.get(n);
    return i || (i = this.precomputeWindow(n, t), t !== 1 && (typeof r == "function" && (i = r(i)), Tu.set(n, i))), i;
  }
  cached(t, n, r) {
    const i = Su(t);
    return this.wNAF(i, this.getPrecomputes(i, t, r), n);
  }
  unsafe(t, n, r, i) {
    const s = Su(t);
    return s === 1 ? this._unsafeLadder(t, n, i) : this.wNAFUnsafe(s, this.getPrecomputes(s, t, r), n, i);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(t, n) {
    Vy(n, this.bits), My.set(t, n), Tu.delete(t);
  }
  hasCache(t) {
    return Su(t) !== 1;
  }
};
function DE(e, t, n, r) {
  let i = t, s = e.ZERO, o = e.ZERO;
  for (; n > Yi || r > Yi; )
    n & ni && (s = s.add(i)), r & ni && (o = o.add(i)), i = i.double(), n >>= ni, r >>= ni;
  return { p1: s, p2: o };
}
function yh(e, t, n) {
  if (t) {
    if (t.ORDER !== e)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return PE(t), t;
  } else
    return Uc(e, { isLE: n });
}
function VE(e, t, n = {}, r) {
  if (r === void 0 && (r = e === "edwards"), !t || typeof t != "object")
    throw new Error(`expected valid ${e} CURVE object`);
  for (const c of ["p", "n", "h"]) {
    const u = t[c];
    if (!(typeof u == "bigint" && u > Yi))
      throw new Error(`CURVE.${c} must be positive bigint`);
  }
  const i = yh(t.p, n.Fp, r), s = yh(t.n, n.Fn, r), a = ["Gx", "Gy", "a", "b"];
  for (const c of a)
    if (!i.isValid(t[c]))
      throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);
  return t = Object.freeze(Object.assign({}, t)), { CURVE: t, Fp: i, Fn: s };
}
function Fy(e, t) {
  return function(r) {
    const i = e(r);
    return { secretKey: i, publicKey: t(i) };
  };
}
let Hy = class {
  oHash;
  iHash;
  blockLen;
  outputLen;
  finished = !1;
  destroyed = !1;
  constructor(t, n) {
    if (xy(t), yt(n, void 0, "key"), this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const r = this.blockLen, i = new Uint8Array(r);
    i.set(n.length > r ? t.create().update(n).digest() : n);
    for (let s = 0; s < i.length; s++)
      i[s] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let s = 0; s < i.length; s++)
      i[s] ^= 106;
    this.oHash.update(i), Pa(i);
  }
  update(t) {
    return Ra(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Ra(this), yt(t, this.outputLen, "output"), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t ||= Object.create(Object.getPrototypeOf(this), {});
    const { oHash: n, iHash: r, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;
    return t = t, t.finished = i, t.destroyed = s, t.blockLen = o, t.outputLen = a, t.oHash = n._cloneInto(t.oHash), t.iHash = r._cloneInto(t.iHash), t;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const Wy = (e, t, n) => new Hy(e, t).update(n).digest();
Wy.create = (e, t) => new Hy(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const wh = (e, t) => (e + (e >= 0 ? t : -t) / Ky) / t;
function ME(e, t, n) {
  const [[r, i], [s, o]] = t, a = wh(o * e, n), c = wh(-i * e, n);
  let u = e - a * r - c * s, l = -a * i - c * o;
  const f = u < Fn, h = l < Fn;
  f && (u = -u), h && (l = -l);
  const g = Pf(Math.ceil(kE(n) / 2)) + Di;
  if (u < Fn || u >= g || l < Fn || l >= g)
    throw new Error("splitScalar (endomorphism): failed, k=" + e);
  return { k1neg: f, k1: u, k2neg: h, k2: l };
}
function ml(e) {
  if (!["compact", "recovered", "der"].includes(e))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return e;
}
function vu(e, t) {
  const n = {};
  for (let r of Object.keys(t))
    n[r] = e[r] === void 0 ? t[r] : e[r];
  return La(n.lowS, "lowS"), La(n.prehash, "prehash"), n.format !== void 0 && ml(n.format), n;
}
let FE = class extends Error {
  constructor(t = "") {
    super(t);
  }
};
const hr = {
  // asn.1 DER encoding utils
  Err: FE,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, t) => {
      const { Err: n } = hr;
      if (e < 0 || e > 256)
        throw new n("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new n("tlv.encode: unpadded data");
      const r = t.length / 2, i = Oo(r);
      if (i.length / 2 & 128)
        throw new n("tlv.encode: long form length too big");
      const s = r > 127 ? Oo(i.length / 2 | 128) : "";
      return Oo(e) + s + i + t;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, t) {
      const { Err: n } = hr;
      let r = 0;
      if (e < 0 || e > 256)
        throw new n("tlv.encode: wrong tag");
      if (t.length < 2 || t[r++] !== e)
        throw new n("tlv.decode: wrong tlv");
      const i = t[r++], s = !!(i & 128);
      let o = 0;
      if (!s)
        o = i;
      else {
        const c = i & 127;
        if (!c)
          throw new n("tlv.decode(long): indefinite length not supported");
        if (c > 4)
          throw new n("tlv.decode(long): byte length is too big");
        const u = t.subarray(r, r + c);
        if (u.length !== c)
          throw new n("tlv.decode: length bytes not complete");
        if (u[0] === 0)
          throw new n("tlv.decode(long): zero leftmost byte");
        for (const l of u)
          o = o << 8 | l;
        if (r += c, o < 128)
          throw new n("tlv.decode(long): not minimal encoding");
      }
      const a = t.subarray(r, r + o);
      if (a.length !== o)
        throw new n("tlv.decode: wrong value length");
      return { v: a, l: t.subarray(r + o) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: t } = hr;
      if (e < Fn)
        throw new t("integer: negative integers are not allowed");
      let n = Oo(e);
      if (Number.parseInt(n[0], 16) & 8 && (n = "00" + n), n.length & 1)
        throw new t("unexpected DER parsing assertion: unpadded hex");
      return n;
    },
    decode(e) {
      const { Err: t } = hr;
      if (e[0] & 128)
        throw new t("invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new t("invalid signature integer: unnecessary leading zero");
      return Yn(e);
    }
  },
  toSig(e) {
    const { Err: t, _int: n, _tlv: r } = hr, i = yt(e, void 0, "signature"), { v: s, l: o } = r.decode(48, i);
    if (o.length)
      throw new t("invalid signature: left bytes after parsing");
    const { v: a, l: c } = r.decode(2, s), { v: u, l } = r.decode(2, c);
    if (l.length)
      throw new t("invalid signature: left bytes after parsing");
    return { r: n.decode(a), s: n.decode(u) };
  },
  hexFromSig(e) {
    const { _tlv: t, _int: n } = hr, r = t.encode(2, n.encode(e.r)), i = t.encode(2, n.encode(e.s)), s = r + i;
    return t.encode(48, s);
  }
}, Fn = BigInt(0), Di = BigInt(1), Ky = BigInt(2), Bo = BigInt(3), HE = BigInt(4);
function WE(e, t = {}) {
  const n = VE("weierstrass", e, t), { Fp: r, Fn: i } = n;
  let s = n.CURVE;
  const { h: o, n: a } = s;
  Nf(t, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo: c } = t;
  if (c && (!r.is0(s.a) || typeof c.beta != "bigint" || !Array.isArray(c.basises)))
    throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const u = zy(r, i);
  function l() {
    if (!r.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function f(v, b, E) {
    const { x: m, y: T } = b.toAffine(), k = r.toBytes(m);
    if (La(E, "isCompressed"), E) {
      l();
      const P = !r.isOdd(T);
      return En(jy(P), k);
    } else
      return En(Uint8Array.of(4), k, r.toBytes(T));
  }
  function h(v) {
    yt(v, void 0, "Point");
    const { publicKey: b, publicKeyUncompressed: E } = u, m = v.length, T = v[0], k = v.subarray(1);
    if (m === b && (T === 2 || T === 3)) {
      const P = r.fromBytes(k);
      if (!r.isValid(P))
        throw new Error("bad point: is not on curve, wrong x");
      const O = p(P);
      let I;
      try {
        I = r.sqrt(O);
      } catch (z) {
        const H = z instanceof Error ? ": " + z.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + H);
      }
      l();
      const $ = r.isOdd(I);
      return (T & 1) === 1 !== $ && (I = r.neg(I)), { x: P, y: I };
    } else if (m === E && T === 4) {
      const P = r.BYTES, O = r.fromBytes(k.subarray(0, P)), I = r.fromBytes(k.subarray(P, P * 2));
      if (!y(O, I))
        throw new Error("bad point: is not on curve");
      return { x: O, y: I };
    } else
      throw new Error(`bad point: got length ${m}, expected compressed=${b} or uncompressed=${E}`);
  }
  const g = t.toBytes || f, d = t.fromBytes || h;
  function p(v) {
    const b = r.sqr(v), E = r.mul(b, v);
    return r.add(r.add(E, r.mul(v, s.a)), s.b);
  }
  function y(v, b) {
    const E = r.sqr(b), m = p(v);
    return r.eql(E, m);
  }
  if (!y(s.Gx, s.Gy))
    throw new Error("bad curve params: generator point");
  const x = r.mul(r.pow(s.a, Bo), HE), S = r.mul(r.sqr(s.b), BigInt(27));
  if (r.is0(r.add(x, S)))
    throw new Error("bad curve params: a or b");
  function A(v, b, E = !1) {
    if (!r.isValid(b) || E && r.is0(b))
      throw new Error(`bad point coordinate ${v}`);
    return b;
  }
  function R(v) {
    if (!(v instanceof U))
      throw new Error("Weierstrass Point expected");
  }
  function N(v) {
    if (!c || !c.basises)
      throw new Error("no endo");
    return ME(v, c.basises, i.ORDER);
  }
  const F = lh((v, b) => {
    const { X: E, Y: m, Z: T } = v;
    if (r.eql(T, r.ONE))
      return { x: E, y: m };
    const k = v.is0();
    b == null && (b = k ? r.ONE : r.inv(T));
    const P = r.mul(E, b), O = r.mul(m, b), I = r.mul(T, b);
    if (k)
      return { x: r.ZERO, y: r.ZERO };
    if (!r.eql(I, r.ONE))
      throw new Error("invZ was invalid");
    return { x: P, y: O };
  }), w = lh((v) => {
    if (v.is0()) {
      if (t.allowInfinityPoint && !r.is0(v.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: b, y: E } = v.toAffine();
    if (!r.isValid(b) || !r.isValid(E))
      throw new Error("bad point: x or y not field elements");
    if (!y(b, E))
      throw new Error("bad point: equation left != right");
    if (!v.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  function K(v, b, E, m, T) {
    return E = new U(r.mul(E.X, v), E.Y, E.Z), b = Ua(m, b), E = Ua(T, E), b.add(E);
  }
  class U {
    // base / generator point
    static BASE = new U(s.Gx, s.Gy, r.ONE);
    // zero / infinity / identity point
    static ZERO = new U(r.ZERO, r.ONE, r.ZERO);
    // 0, 1, 0
    // math field
    static Fp = r;
    // scalar field
    static Fn = i;
    X;
    Y;
    Z;
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(b, E, m) {
      this.X = A("x", b), this.Y = A("y", E, !0), this.Z = A("z", m), Object.freeze(this);
    }
    static CURVE() {
      return s;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(b) {
      const { x: E, y: m } = b || {};
      if (!b || !r.isValid(E) || !r.isValid(m))
        throw new Error("invalid affine point");
      if (b instanceof U)
        throw new Error("projective point not allowed");
      return r.is0(E) && r.is0(m) ? U.ZERO : new U(E, m, r.ONE);
    }
    static fromBytes(b) {
      const E = U.fromAffine(d(yt(b, void 0, "point")));
      return E.assertValidity(), E;
    }
    static fromHex(b) {
      return U.fromBytes(Na(b));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(b = 8, E = !0) {
      return B.createCache(this, b), E || this.multiply(Bo), this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      w(this);
    }
    hasEvenY() {
      const { y: b } = this.toAffine();
      if (!r.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !r.isOdd(b);
    }
    /** Compare one point to another. */
    equals(b) {
      R(b);
      const { X: E, Y: m, Z: T } = this, { X: k, Y: P, Z: O } = b, I = r.eql(r.mul(E, O), r.mul(k, T)), $ = r.eql(r.mul(m, O), r.mul(P, T));
      return I && $;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new U(this.X, r.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: b, b: E } = s, m = r.mul(E, Bo), { X: T, Y: k, Z: P } = this;
      let O = r.ZERO, I = r.ZERO, $ = r.ZERO, L = r.mul(T, T), z = r.mul(k, k), H = r.mul(P, P), _ = r.mul(T, k);
      return _ = r.add(_, _), $ = r.mul(T, P), $ = r.add($, $), O = r.mul(b, $), I = r.mul(m, H), I = r.add(O, I), O = r.sub(z, I), I = r.add(z, I), I = r.mul(O, I), O = r.mul(_, O), $ = r.mul(m, $), H = r.mul(b, H), _ = r.sub(L, H), _ = r.mul(b, _), _ = r.add(_, $), $ = r.add(L, L), L = r.add($, L), L = r.add(L, H), L = r.mul(L, _), I = r.add(I, L), H = r.mul(k, P), H = r.add(H, H), L = r.mul(H, _), O = r.sub(O, L), $ = r.mul(H, z), $ = r.add($, $), $ = r.add($, $), new U(O, I, $);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(b) {
      R(b);
      const { X: E, Y: m, Z: T } = this, { X: k, Y: P, Z: O } = b;
      let I = r.ZERO, $ = r.ZERO, L = r.ZERO;
      const z = s.a, H = r.mul(s.b, Bo);
      let _ = r.mul(E, k), j = r.mul(m, P), Y = r.mul(T, O), ot = r.add(E, m), q = r.add(k, P);
      ot = r.mul(ot, q), q = r.add(_, j), ot = r.sub(ot, q), q = r.add(E, T);
      let Q = r.add(k, O);
      return q = r.mul(q, Q), Q = r.add(_, Y), q = r.sub(q, Q), Q = r.add(m, T), I = r.add(P, O), Q = r.mul(Q, I), I = r.add(j, Y), Q = r.sub(Q, I), L = r.mul(z, q), I = r.mul(H, Y), L = r.add(I, L), I = r.sub(j, L), L = r.add(j, L), $ = r.mul(I, L), j = r.add(_, _), j = r.add(j, _), Y = r.mul(z, Y), q = r.mul(H, q), j = r.add(j, Y), Y = r.sub(_, Y), Y = r.mul(z, Y), q = r.add(q, Y), _ = r.mul(j, q), $ = r.add($, _), _ = r.mul(Q, q), I = r.mul(ot, I), I = r.sub(I, _), _ = r.mul(ot, j), L = r.mul(Q, L), L = r.add(L, _), new U(I, $, L);
    }
    subtract(b) {
      return this.add(b.negate());
    }
    is0() {
      return this.equals(U.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(b) {
      const { endo: E } = t;
      if (!i.isValidNot0(b))
        throw new Error("invalid scalar: out of range");
      let m, T;
      const k = (P) => B.cached(this, P, (O) => hh(U, O));
      if (E) {
        const { k1neg: P, k1: O, k2neg: I, k2: $ } = N(b), { p: L, f: z } = k(O), { p: H, f: _ } = k($);
        T = z.add(_), m = K(E.beta, L, H, P, I);
      } else {
        const { p: P, f: O } = k(b);
        m = P, T = O;
      }
      return hh(U, [m, T])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(b) {
      const { endo: E } = t, m = this;
      if (!i.isValid(b))
        throw new Error("invalid scalar: out of range");
      if (b === Fn || m.is0())
        return U.ZERO;
      if (b === Di)
        return m;
      if (B.hasCache(this))
        return this.multiply(b);
      if (E) {
        const { k1neg: T, k1: k, k2neg: P, k2: O } = N(b), { p1: I, p2: $ } = DE(U, m, k, O);
        return K(E.beta, I, $, T, P);
      } else
        return B.unsafe(m, b);
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(b) {
      return F(this, b);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: b } = t;
      return o === Di ? !0 : b ? b(U, this) : B.unsafe(this, a).is0();
    }
    clearCofactor() {
      const { clearCofactor: b } = t;
      return o === Di ? this : b ? b(U, this) : this.multiplyUnsafe(o);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(o).is0();
    }
    toBytes(b = !0) {
      return La(b, "isCompressed"), this.assertValidity(), g(U, this, b);
    }
    toHex(b = !0) {
      return Pc(this.toBytes(b));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  const W = i.BITS, B = new _E(U, t.endo ? Math.ceil(W / 2) : W);
  return U.BASE.precompute(8), U;
}
function jy(e) {
  return Uint8Array.of(e ? 2 : 3);
}
function zy(e, t) {
  return {
    secretKey: t.BYTES,
    publicKey: 1 + e.BYTES,
    publicKeyUncompressed: 1 + 2 * e.BYTES,
    publicKeyHasPrefix: !0,
    signature: 2 * t.BYTES
  };
}
function KE(e, t = {}) {
  const { Fn: n } = e, r = t.randomBytes || Nc, i = Object.assign(zy(e.Fp, n), { seed: _y(n.ORDER) });
  function s(g) {
    try {
      const d = n.fromBytes(g);
      return n.isValidNot0(d);
    } catch {
      return !1;
    }
  }
  function o(g, d) {
    const { publicKey: p, publicKeyUncompressed: y } = i;
    try {
      const x = g.length;
      return d === !0 && x !== p || d === !1 && x !== y ? !1 : !!e.fromBytes(g);
    } catch {
      return !1;
    }
  }
  function a(g = r(i.seed)) {
    return Dy(yt(g, i.seed, "seed"), n.ORDER);
  }
  function c(g, d = !0) {
    return e.BASE.multiply(n.fromBytes(g)).toBytes(d);
  }
  function u(g) {
    const { secretKey: d, publicKey: p, publicKeyUncompressed: y } = i;
    if (!Bf(g) || "_lengths" in n && n._lengths || d === p)
      return;
    const x = yt(g, void 0, "key").length;
    return x === p || x === y;
  }
  function l(g, d, p = !0) {
    if (u(g) === !0)
      throw new Error("first arg must be private key");
    if (u(d) === !1)
      throw new Error("second arg must be public key");
    const y = n.fromBytes(g);
    return e.fromBytes(d).multiply(y).toBytes(p);
  }
  const f = {
    isValidSecretKey: s,
    isValidPublicKey: o,
    randomSecretKey: a
  }, h = Fy(a, c);
  return Object.freeze({ getPublicKey: c, getSharedSecret: l, keygen: h, Point: e, utils: f, lengths: i });
}
function jE(e, t, n = {}) {
  xy(t), Nf(n, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  }), n = Object.assign({}, n);
  const r = n.randomBytes || Nc, i = n.hmac || ((E, m) => Wy(t, E, m)), { Fp: s, Fn: o } = e, { ORDER: a, BITS: c } = o, { keygen: u, getPublicKey: l, getSharedSecret: f, utils: h, lengths: g } = KE(e, n), d = {
    prehash: !0,
    lowS: typeof n.lowS == "boolean" ? n.lowS : !0,
    format: "compact",
    extraEntropy: !1
  }, p = a * Ky < s.ORDER;
  function y(E) {
    const m = a >> Di;
    return E > m;
  }
  function x(E, m) {
    if (!o.isValidNot0(m))
      throw new Error(`invalid signature ${E}: out of range 1..Point.Fn.ORDER`);
    return m;
  }
  function S() {
    if (p)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function A(E, m) {
    ml(m);
    const T = g.signature, k = m === "compact" ? T : m === "recovered" ? T + 1 : void 0;
    return yt(E, k);
  }
  class R {
    r;
    s;
    recovery;
    constructor(m, T, k) {
      if (this.r = x("r", m), this.s = x("s", T), k != null) {
        if (S(), ![0, 1, 2, 3].includes(k))
          throw new Error("invalid recovery id");
        this.recovery = k;
      }
      Object.freeze(this);
    }
    static fromBytes(m, T = d.format) {
      A(m, T);
      let k;
      if (T === "der") {
        const { r: $, s: L } = hr.toSig(yt(m));
        return new R($, L);
      }
      T === "recovered" && (k = m[0], T = "compact", m = m.subarray(1));
      const P = g.signature / 2, O = m.subarray(0, P), I = m.subarray(P, P * 2);
      return new R(o.fromBytes(O), o.fromBytes(I), k);
    }
    static fromHex(m, T) {
      return this.fromBytes(Na(m), T);
    }
    assertRecovery() {
      const { recovery: m } = this;
      if (m == null)
        throw new Error("invalid recovery id: must be present");
      return m;
    }
    addRecoveryBit(m) {
      return new R(this.r, this.s, m);
    }
    recoverPublicKey(m) {
      const { r: T, s: k } = this, P = this.assertRecovery(), O = P === 2 || P === 3 ? T + a : T;
      if (!s.isValid(O))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const I = s.toBytes(O), $ = e.fromBytes(En(jy((P & 1) === 0), I)), L = o.inv(O), z = F(yt(m, void 0, "msgHash")), H = o.create(-z * L), _ = o.create(k * L), j = e.BASE.multiplyUnsafe(H).add($.multiplyUnsafe(_));
      if (j.is0())
        throw new Error("invalid recovery: point at infinify");
      return j.assertValidity(), j;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return y(this.s);
    }
    toBytes(m = d.format) {
      if (ml(m), m === "der")
        return Na(hr.hexFromSig(this));
      const { r: T, s: k } = this, P = o.toBytes(T), O = o.toBytes(k);
      return m === "recovered" ? (S(), En(Uint8Array.of(this.assertRecovery()), P, O)) : En(P, O);
    }
    toHex(m) {
      return Pc(this.toBytes(m));
    }
  }
  const N = n.bits2int || function(m) {
    if (m.length > 8192)
      throw new Error("input is too large");
    const T = Yn(m), k = m.length * 8 - c;
    return k > 0 ? T >> BigInt(k) : T;
  }, F = n.bits2int_modN || function(m) {
    return o.create(N(m));
  }, w = Pf(c);
  function K(E) {
    return $y("num < 2^" + c, E, Fn, w), o.toBytes(E);
  }
  function U(E, m) {
    return yt(E, void 0, "message"), m ? yt(t(E), void 0, "prehashed message") : E;
  }
  function W(E, m, T) {
    const { lowS: k, prehash: P, extraEntropy: O } = vu(T, d);
    E = U(E, P);
    const I = F(E), $ = o.fromBytes(m);
    if (!o.isValidNot0($))
      throw new Error("invalid private key");
    const L = [K($), K(I)];
    if (O != null && O !== !1) {
      const j = O === !0 ? r(g.secretKey) : O;
      L.push(yt(j, void 0, "extraEntropy"));
    }
    const z = En(...L), H = I;
    function _(j) {
      const Y = N(j);
      if (!o.isValidNot0(Y))
        return;
      const ot = o.inv(Y), q = e.BASE.multiply(Y).toAffine(), Q = o.create(q.x);
      if (Q === Fn)
        return;
      const ee = o.create(ot * o.create(H + Q * $));
      if (ee === Fn)
        return;
      let Qn = (q.x === Q ? 0 : 2) | Number(q.y & Di), Jn = ee;
      return k && y(ee) && (Jn = o.neg(ee), Qn ^= 1), new R(Q, Jn, p ? void 0 : Qn);
    }
    return { seed: z, k2sig: _ };
  }
  function B(E, m, T = {}) {
    const { seed: k, k2sig: P } = W(E, m, T);
    return AE(t.outputLen, o.BYTES, i)(k, P).toBytes(T.format);
  }
  function v(E, m, T, k = {}) {
    const { lowS: P, prehash: O, format: I } = vu(k, d);
    if (T = yt(T, void 0, "publicKey"), m = U(m, O), !Bf(E)) {
      const $ = E instanceof R ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + $);
    }
    A(E, I);
    try {
      const $ = R.fromBytes(E, I), L = e.fromBytes(T);
      if (P && $.hasHighS())
        return !1;
      const { r: z, s: H } = $, _ = F(m), j = o.inv(H), Y = o.create(_ * j), ot = o.create(z * j), q = e.BASE.multiplyUnsafe(Y).add(L.multiplyUnsafe(ot));
      return q.is0() ? !1 : o.create(q.x) === z;
    } catch {
      return !1;
    }
  }
  function b(E, m, T = {}) {
    const { prehash: k } = vu(T, d);
    return m = U(m, k), R.fromBytes(E, "recovered").recoverPublicKey(m).toBytes();
  }
  return Object.freeze({
    keygen: u,
    getPublicKey: l,
    getSharedSecret: f,
    utils: h,
    lengths: g,
    Point: e,
    sign: B,
    verify: v,
    recoverPublicKey: b,
    Signature: R,
    hash: t
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _c = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
}, zE = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
}, qE = /* @__PURE__ */ BigInt(0), bl = /* @__PURE__ */ BigInt(2);
function GE(e) {
  const t = _c.p, n = BigInt(3), r = BigInt(6), i = BigInt(11), s = BigInt(22), o = BigInt(23), a = BigInt(44), c = BigInt(88), u = e * e * e % t, l = u * u * e % t, f = Se(l, n, t) * l % t, h = Se(f, n, t) * l % t, g = Se(h, bl, t) * u % t, d = Se(g, i, t) * g % t, p = Se(d, s, t) * d % t, y = Se(p, a, t) * p % t, x = Se(y, c, t) * y % t, S = Se(x, a, t) * p % t, A = Se(S, n, t) * l % t, R = Se(A, o, t) * d % t, N = Se(R, r, t) * u % t, F = Se(N, bl, t);
  if (!_a.eql(_a.sqr(F), e))
    throw new Error("Cannot find square root");
  return F;
}
const _a = Uc(_c.p, { sqrt: GE }), Si = /* @__PURE__ */ WE(_c, {
  Fp: _a,
  endo: zE
}), Er = /* @__PURE__ */ jE(Si, yl), mh = {};
function Da(e, ...t) {
  let n = mh[e];
  if (n === void 0) {
    const r = yl(SE(e));
    n = En(r, r), mh[e] = n;
  }
  return yl(En(n, ...t));
}
const Uf = (e) => e.toBytes(!0).slice(1), _f = (e) => e % bl === qE;
function El(e) {
  const { Fn: t, BASE: n } = Si, r = t.fromBytes(e), i = n.multiply(r);
  return { scalar: _f(i.y) ? r : t.neg(r), bytes: Uf(i) };
}
function qy(e) {
  const t = _a;
  if (!t.isValidNot0(e))
    throw new Error("invalid x: Fail if x ‚â• p");
  const n = t.create(e * e), r = t.create(n * e + BigInt(7));
  let i = t.sqrt(r);
  _f(i) || (i = t.neg(i));
  const s = Si.fromAffine({ x: e, y: i });
  return s.assertValidity(), s;
}
const Hs = Yn;
function Gy(...e) {
  return Si.Fn.create(Hs(Da("BIP0340/challenge", ...e)));
}
function bh(e) {
  return El(e).bytes;
}
function YE(e, t, n = Nc(32)) {
  const { Fn: r } = Si, i = yt(e, void 0, "message"), { bytes: s, scalar: o } = El(t), a = yt(n, 32, "auxRand"), c = r.toBytes(o ^ Hs(Da("BIP0340/aux", a))), u = Da("BIP0340/nonce", c, s, i), { bytes: l, scalar: f } = El(u), h = Gy(l, s, i), g = new Uint8Array(64);
  if (g.set(l, 0), g.set(r.toBytes(r.create(f + h * o)), 32), !Yy(g, i, s))
    throw new Error("sign: Invalid signature produced");
  return g;
}
function Yy(e, t, n) {
  const { Fp: r, Fn: i, BASE: s } = Si, o = yt(e, 64, "signature"), a = yt(t, void 0, "message"), c = yt(n, 32, "publicKey");
  try {
    const u = qy(Hs(c)), l = Hs(o.subarray(0, 32));
    if (!r.isValidNot0(l))
      return !1;
    const f = Hs(o.subarray(32, 64));
    if (!i.isValidNot0(f))
      return !1;
    const h = Gy(i.toBytes(l), Uf(u), a), g = s.multiplyUnsafe(f).add(u.multiplyUnsafe(i.neg(h))), { x: d, y: p } = g.toAffine();
    return !(g.is0() || !_f(p) || d !== l);
  } catch {
    return !1;
  }
}
const rn = /* @__PURE__ */ (() => {
  const n = (r = Nc(48)) => Dy(r, _c.n);
  return {
    keygen: Fy(n, bh),
    getPublicKey: bh,
    sign: YE,
    verify: Yy,
    Point: Si,
    utils: {
      randomSecretKey: n,
      taggedHash: Da,
      lift_x: qy,
      pointToBytes: Uf
    },
    lengths: {
      secretKey: 32,
      publicKey: 32,
      publicKeyHasPrefix: !1,
      signature: 64,
      seed: 48
    }
  };
})();
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function ZE(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function io(e, t, n = "") {
  const r = ZE(e), i = e?.length, s = t !== void 0;
  if (!r || s && i !== t) {
    const o = n && `"${n}" `, a = s ? ` of length ${t}` : "", c = r ? `length=${i}` : `type=${typeof e}`;
    throw new Error(o + "expected Uint8Array" + a + ", got " + c);
  }
  return e;
}
function Eh(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function XE(e, t) {
  io(e, void 0, "digestInto() output");
  const n = t.outputLen;
  if (e.length < n)
    throw new Error('"digestInto() output" expected to be of length >=' + n);
}
function so(...e) {
  for (let t = 0; t < e.length; t++)
    e[t].fill(0);
}
function ku(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function an(e, t) {
  return e << 32 - t | e >>> t;
}
function Co(e, t) {
  return e << t | e >>> 32 - t >>> 0;
}
function Zy(e, t = {}) {
  const n = (i, s) => e(s).update(i).digest(), r = e(void 0);
  return n.outputLen = r.outputLen, n.blockLen = r.blockLen, n.create = (i) => e(i), Object.assign(n, t), Object.freeze(n);
}
const QE = (e) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, e])
});
function JE(e, t, n) {
  return e & t ^ ~e & n;
}
function tx(e, t, n) {
  return e & t ^ e & n ^ t & n;
}
let Xy = class {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = !1;
  length = 0;
  pos = 0;
  destroyed = !1;
  constructor(t, n, r, i) {
    this.blockLen = t, this.outputLen = n, this.padOffset = r, this.isLE = i, this.buffer = new Uint8Array(t), this.view = ku(this.buffer);
  }
  update(t) {
    Eh(this), io(t);
    const { view: n, buffer: r, blockLen: i } = this, s = t.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = ku(t);
        for (; i <= s - o; o += i)
          this.process(c, o);
        continue;
      }
      r.set(t.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(n, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Eh(this), XE(t, this), this.finished = !0;
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    n[o++] = 128, so(this.buffer.subarray(o)), this.padOffset > i - o && (this.process(r, 0), o = 0);
    for (let f = o; f < i; f++)
      n[f] = 0;
    r.setBigUint64(i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = ku(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      a.setUint32(4 * f, l[f], s);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t ||= new this.constructor(), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a } = this;
    return t.destroyed = o, t.finished = s, t.length = i, t.pos = a, i % n && t.buffer.set(r), t;
  }
  clone() {
    return this._cloneInto();
  }
};
const nr = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), ex = /* @__PURE__ */ Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]), Qy = Uint8Array.from(new Array(16).fill(0).map((e, t) => t)), nx = Qy.map((e) => (9 * e + 5) % 16), Jy = /* @__PURE__ */ (() => {
  const n = [[Qy], [nx]];
  for (let r = 0; r < 4; r++)
    for (let i of n)
      i.push(i[r].map((s) => ex[s]));
  return n;
})(), tw = Jy[0], ew = Jy[1], nw = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((e) => Uint8Array.from(e)), rx = /* @__PURE__ */ tw.map((e, t) => e.map((n) => nw[t][n])), ix = /* @__PURE__ */ ew.map((e, t) => e.map((n) => nw[t][n])), sx = /* @__PURE__ */ Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), ox = /* @__PURE__ */ Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function xh(e, t, n, r) {
  return e === 0 ? t ^ n ^ r : e === 1 ? t & n | ~t & r : e === 2 ? (t | ~n) ^ r : e === 3 ? t & r | n & ~r : t ^ (n | ~r);
}
const Ro = /* @__PURE__ */ new Uint32Array(16);
let ax = class extends Xy {
  h0 = 1732584193;
  h1 = -271733879;
  h2 = -1732584194;
  h3 = 271733878;
  h4 = -1009589776;
  constructor() {
    super(64, 20, 8, !0);
  }
  get() {
    const { h0: t, h1: n, h2: r, h3: i, h4: s } = this;
    return [t, n, r, i, s];
  }
  set(t, n, r, i, s) {
    this.h0 = t | 0, this.h1 = n | 0, this.h2 = r | 0, this.h3 = i | 0, this.h4 = s | 0;
  }
  process(t, n) {
    for (let g = 0; g < 16; g++, n += 4)
      Ro[g] = t.getUint32(n, !0);
    let r = this.h0 | 0, i = r, s = this.h1 | 0, o = s, a = this.h2 | 0, c = a, u = this.h3 | 0, l = u, f = this.h4 | 0, h = f;
    for (let g = 0; g < 5; g++) {
      const d = 4 - g, p = sx[g], y = ox[g], x = tw[g], S = ew[g], A = rx[g], R = ix[g];
      for (let N = 0; N < 16; N++) {
        const F = Co(r + xh(g, s, a, u) + Ro[x[N]] + p, A[N]) + f | 0;
        r = f, f = u, u = Co(a, 10) | 0, a = s, s = F;
      }
      for (let N = 0; N < 16; N++) {
        const F = Co(i + xh(d, o, c, l) + Ro[S[N]] + y, R[N]) + h | 0;
        i = h, h = l, l = Co(c, 10) | 0, c = o, o = F;
      }
    }
    this.set(this.h1 + a + l | 0, this.h2 + u + h | 0, this.h3 + f + i | 0, this.h4 + r + o | 0, this.h0 + s + c | 0);
  }
  roundClean() {
    so(Ro);
  }
  destroy() {
    this.destroyed = !0, so(this.buffer), this.set(0, 0, 0, 0, 0);
  }
};
const cx = /* @__PURE__ */ Zy(() => new ax()), ux = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), rr = /* @__PURE__ */ new Uint32Array(64);
let lx = class extends Xy {
  constructor(t) {
    super(64, t, 8, !1);
  }
  get() {
    const { A: t, B: n, C: r, D: i, E: s, F: o, G: a, H: c } = this;
    return [t, n, r, i, s, o, a, c];
  }
  // prettier-ignore
  set(t, n, r, i, s, o, a, c) {
    this.A = t | 0, this.B = n | 0, this.C = r | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, n) {
    for (let f = 0; f < 16; f++, n += 4)
      rr[f] = t.getUint32(n, !1);
    for (let f = 16; f < 64; f++) {
      const h = rr[f - 15], g = rr[f - 2], d = an(h, 7) ^ an(h, 18) ^ h >>> 3, p = an(g, 17) ^ an(g, 19) ^ g >>> 10;
      rr[f] = p + rr[f - 7] + d + rr[f - 16] | 0;
    }
    let { A: r, B: i, C: s, D: o, E: a, F: c, G: u, H: l } = this;
    for (let f = 0; f < 64; f++) {
      const h = an(a, 6) ^ an(a, 11) ^ an(a, 25), g = l + h + JE(a, c, u) + ux[f] + rr[f] | 0, p = (an(r, 2) ^ an(r, 13) ^ an(r, 22)) + tx(r, i, s) | 0;
      l = u, u = c, c = a, a = o + g | 0, o = s, s = i, i = r, r = g + p | 0;
    }
    r = r + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, i, s, o, a, c, u, l);
  }
  roundClean() {
    so(rr);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), so(this.buffer);
  }
}, fx = class extends lx {
  // We cannot use array here since array allows indexing by variable
  // which means optimizer/compiler cannot use registers.
  A = nr[0] | 0;
  B = nr[1] | 0;
  C = nr[2] | 0;
  D = nr[3] | 0;
  E = nr[4] | 0;
  F = nr[5] | 0;
  G = nr[6] | 0;
  H = nr[7] | 0;
  constructor() {
    super(32);
  }
};
const ge = /* @__PURE__ */ Zy(
  () => new fx(),
  /* @__PURE__ */ QE(1)
);
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Zi(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function rw(e) {
  if (!Zi(e))
    throw new Error("Uint8Array expected");
}
function iw(e, t) {
  return Array.isArray(t) ? t.length === 0 ? !0 : e ? t.every((n) => typeof n == "string") : t.every((n) => Number.isSafeInteger(n)) : !1;
}
function Df(e) {
  if (typeof e != "function")
    throw new Error("function expected");
  return !0;
}
function Or(e, t) {
  if (typeof t != "string")
    throw new Error(`${e}: string expected`);
  return !0;
}
function ms(e) {
  if (!Number.isSafeInteger(e))
    throw new Error(`invalid integer: ${e}`);
}
function Va(e) {
  if (!Array.isArray(e))
    throw new Error("array expected");
}
function Ma(e, t) {
  if (!iw(!0, t))
    throw new Error(`${e}: array of strings expected`);
}
function Vf(e, t) {
  if (!iw(!1, t))
    throw new Error(`${e}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function xo(...e) {
  const t = (s) => s, n = (s, o) => (a) => s(o(a)), r = e.map((s) => s.encode).reduceRight(n, t), i = e.map((s) => s.decode).reduce(n, t);
  return { encode: r, decode: i };
}
// @__NO_SIDE_EFFECTS__
function Dc(e) {
  const t = typeof e == "string" ? e.split("") : e, n = t.length;
  Ma("alphabet", t);
  const r = new Map(t.map((i, s) => [i, s]));
  return {
    encode: (i) => (Va(i), i.map((s) => {
      if (!Number.isSafeInteger(s) || s < 0 || s >= n)
        throw new Error(`alphabet.encode: digit index outside alphabet "${s}". Allowed: ${e}`);
      return t[s];
    })),
    decode: (i) => (Va(i), i.map((s) => {
      Or("alphabet.decode", s);
      const o = r.get(s);
      if (o === void 0)
        throw new Error(`Unknown letter: "${s}". Allowed: ${e}`);
      return o;
    }))
  };
}
// @__NO_SIDE_EFFECTS__
function Vc(e = "") {
  return Or("join", e), {
    encode: (t) => (Ma("join.decode", t), t.join(e)),
    decode: (t) => (Or("join.decode", t), t.split(e))
  };
}
// @__NO_SIDE_EFFECTS__
function dx(e, t = "=") {
  return ms(e), Or("padding", t), {
    encode(n) {
      for (Ma("padding.encode", n); n.length * e % 8; )
        n.push(t);
      return n;
    },
    decode(n) {
      Ma("padding.decode", n);
      let r = n.length;
      if (r * e % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; r > 0 && n[r - 1] === t; r--)
        if ((r - 1) * e % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      return n.slice(0, r);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function hx(e) {
  return Df(e), { encode: (t) => t, decode: (t) => e(t) };
}
function Th(e, t, n) {
  if (t < 2)
    throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);
  if (n < 2)
    throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);
  if (Va(e), !e.length)
    return [];
  let r = 0;
  const i = [], s = Array.from(e, (a) => {
    if (ms(a), a < 0 || a >= t)
      throw new Error(`invalid integer: ${a}`);
    return a;
  }), o = s.length;
  for (; ; ) {
    let a = 0, c = !0;
    for (let u = r; u < o; u++) {
      const l = s[u], f = t * a, h = f + l;
      if (!Number.isSafeInteger(h) || f / t !== a || h - l !== f)
        throw new Error("convertRadix: carry overflow");
      const g = h / n;
      a = h % n;
      const d = Math.floor(g);
      if (s[u] = d, !Number.isSafeInteger(d) || d * n + a !== h)
        throw new Error("convertRadix: carry overflow");
      if (c)
        d ? c = !1 : r = u;
      else continue;
    }
    if (i.push(a), c)
      break;
  }
  for (let a = 0; a < e.length - 1 && e[a] === 0; a++)
    i.push(0);
  return i.reverse();
}
const sw = (e, t) => t === 0 ? e : sw(t, e % t), Fa = /* @__NO_SIDE_EFFECTS__ */ (e, t) => e + (t - sw(e, t)), oa = /* @__PURE__ */ (() => {
  let e = [];
  for (let t = 0; t < 40; t++)
    e.push(2 ** t);
  return e;
})();
function xl(e, t, n, r) {
  if (Va(e), t <= 0 || t > 32)
    throw new Error(`convertRadix2: wrong from=${t}`);
  if (n <= 0 || n > 32)
    throw new Error(`convertRadix2: wrong to=${n}`);
  if (/* @__PURE__ */ Fa(t, n) > 32)
    throw new Error(`convertRadix2: carry overflow from=${t} to=${n} carryBits=${/* @__PURE__ */ Fa(t, n)}`);
  let i = 0, s = 0;
  const o = oa[t], a = oa[n] - 1, c = [];
  for (const u of e) {
    if (ms(u), u >= o)
      throw new Error(`convertRadix2: invalid data word=${u} from=${t}`);
    if (i = i << t | u, s + t > 32)
      throw new Error(`convertRadix2: carry overflow pos=${s} from=${t}`);
    for (s += t; s >= n; s -= n)
      c.push((i >> s - n & a) >>> 0);
    const l = oa[s];
    if (l === void 0)
      throw new Error("invalid carry");
    i &= l - 1;
  }
  if (i = i << n - s & a, !r && s >= t)
    throw new Error("Excess padding");
  if (!r && i > 0)
    throw new Error(`Non-zero padding: ${i}`);
  return r && s > 0 && c.push(i >>> 0), c;
}
// @__NO_SIDE_EFFECTS__
function px(e) {
  ms(e);
  const t = 2 ** 8;
  return {
    encode: (n) => {
      if (!Zi(n))
        throw new Error("radix.encode input should be Uint8Array");
      return Th(Array.from(n), t, e);
    },
    decode: (n) => (Vf("radix.decode", n), Uint8Array.from(Th(n, e, t)))
  };
}
// @__NO_SIDE_EFFECTS__
function Mf(e, t = !1) {
  if (ms(e), e <= 0 || e > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ Fa(8, e) > 32 || /* @__PURE__ */ Fa(e, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (n) => {
      if (!Zi(n))
        throw new Error("radix2.encode input should be Uint8Array");
      return xl(Array.from(n), 8, e, !t);
    },
    decode: (n) => (Vf("radix2.decode", n), Uint8Array.from(xl(n, e, 8, t)))
  };
}
function Sh(e) {
  return Df(e), function(...t) {
    try {
      return e.apply(null, t);
    } catch {
    }
  };
}
function gx(e, t) {
  return ms(e), Df(t), {
    encode(n) {
      if (!Zi(n))
        throw new Error("checksum.encode: input should be Uint8Array");
      const r = t(n).slice(0, e), i = new Uint8Array(n.length + e);
      return i.set(n), i.set(r, n.length), i;
    },
    decode(n) {
      if (!Zi(n))
        throw new Error("checksum.decode: input should be Uint8Array");
      const r = n.slice(0, -e), i = n.slice(-e), s = t(r).slice(0, e);
      for (let o = 0; o < e; o++)
        if (s[o] !== i[o])
          throw new Error("Invalid checksum");
      return r;
    }
  };
}
const yx = typeof Uint8Array.from([]).toBase64 == "function" && typeof Uint8Array.fromBase64 == "function", wx = (e, t) => {
  Or("base64", e);
  const n = /^[A-Za-z0-9=+/]+$/, r = "base64";
  if (e.length > 0 && !n.test(e))
    throw new Error("invalid base64");
  return Uint8Array.fromBase64(e, { alphabet: r, lastChunkHandling: "strict" });
}, qt = yx ? {
  encode(e) {
    return rw(e), e.toBase64();
  },
  decode(e) {
    return wx(e);
  }
} : /* @__PURE__ */ xo(/* @__PURE__ */ Mf(6), /* @__PURE__ */ Dc("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ dx(6), /* @__PURE__ */ Vc("")), mx = /* @__NO_SIDE_EFFECTS__ */ (e) => /* @__PURE__ */ xo(/* @__PURE__ */ px(58), /* @__PURE__ */ Dc(e), /* @__PURE__ */ Vc("")), Tl = /* @__PURE__ */ mx("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), bx = (e) => /* @__PURE__ */ xo(gx(4, (t) => e(e(t))), Tl), Sl = /* @__PURE__ */ xo(/* @__PURE__ */ Dc("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ Vc("")), vh = [996825010, 642813549, 513874426, 1027748829, 705979059];
function vs(e) {
  const t = e >> 25;
  let n = (e & 33554431) << 5;
  for (let r = 0; r < vh.length; r++)
    (t >> r & 1) === 1 && (n ^= vh[r]);
  return n;
}
function kh(e, t, n = 1) {
  const r = e.length;
  let i = 1;
  for (let s = 0; s < r; s++) {
    const o = e.charCodeAt(s);
    if (o < 33 || o > 126)
      throw new Error(`Invalid prefix (${e})`);
    i = vs(i) ^ o >> 5;
  }
  i = vs(i);
  for (let s = 0; s < r; s++)
    i = vs(i) ^ e.charCodeAt(s) & 31;
  for (let s of t)
    i = vs(i) ^ s;
  for (let s = 0; s < 6; s++)
    i = vs(i);
  return i ^= n, Sl.encode(xl([i % oa[30]], 30, 5, !1));
}
// @__NO_SIDE_EFFECTS__
function ow(e) {
  const t = e === "bech32" ? 1 : 734539939, n = /* @__PURE__ */ Mf(5), r = n.decode, i = n.encode, s = Sh(r);
  function o(f, h, g = 90) {
    Or("bech32.encode prefix", f), Zi(h) && (h = Array.from(h)), Vf("bech32.encode", h);
    const d = f.length;
    if (d === 0)
      throw new TypeError(`Invalid prefix length ${d}`);
    const p = d + 7 + h.length;
    if (g !== !1 && p > g)
      throw new TypeError(`Length ${p} exceeds limit ${g}`);
    const y = f.toLowerCase(), x = kh(y, h, t);
    return `${y}1${Sl.encode(h)}${x}`;
  }
  function a(f, h = 90) {
    Or("bech32.decode input", f);
    const g = f.length;
    if (g < 8 || h !== !1 && g > h)
      throw new TypeError(`invalid string length: ${g} (${f}). Expected (8..${h})`);
    const d = f.toLowerCase();
    if (f !== d && f !== f.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    const p = d.lastIndexOf("1");
    if (p === 0 || p === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const y = d.slice(0, p), x = d.slice(p + 1);
    if (x.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const S = Sl.decode(x).slice(0, -6), A = kh(y, S, t);
    if (!x.endsWith(A))
      throw new Error(`Invalid checksum in ${f}: expected "${A}"`);
    return { prefix: y, words: S };
  }
  const c = Sh(a);
  function u(f) {
    const { prefix: h, words: g } = a(f, !1);
    return { prefix: h, words: g, bytes: r(g) };
  }
  function l(f, h) {
    return o(f, i(h));
  }
  return {
    encode: o,
    decode: a,
    encodeFromBytes: l,
    decodeToBytes: u,
    decodeUnsafe: c,
    fromWords: r,
    fromWordsUnsafe: s,
    toWords: i
  };
}
const vl = /* @__PURE__ */ ow("bech32"), Oi = /* @__PURE__ */ ow("bech32m"), Ex = {
  encode: (e) => new TextDecoder().decode(e),
  decode: (e) => new TextEncoder().encode(e)
}, xx = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", Tx = {
  encode(e) {
    return rw(e), e.toHex();
  },
  decode(e) {
    return Or("hex", e), Uint8Array.fromHex(e);
  }
}, D = xx ? Tx : /* @__PURE__ */ xo(/* @__PURE__ */ Mf(4), /* @__PURE__ */ Dc("0123456789abcdef"), /* @__PURE__ */ Vc(""), /* @__PURE__ */ hx((e) => {
  if (typeof e != "string" || e.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);
  return e.toLowerCase();
})), At = /* @__PURE__ */ Uint8Array.of(), aw = /* @__PURE__ */ Uint8Array.of(0);
function Xi(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function Be(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function Sx(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    if (!Be(i))
      throw new Error("Uint8Array expected");
    t += i.length;
  }
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const s = e[r];
    n.set(s, i), i += s.length;
  }
  return n;
}
const cw = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
function To(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function In(e) {
  return Number.isSafeInteger(e);
}
const Ff = {
  equalBytes: Xi,
  isBytes: Be,
  concatBytes: Sx
}, uw = (e) => {
  if (e !== null && typeof e != "string" && !Ze(e) && !Be(e) && !In(e))
    throw new Error(`lengthCoder: expected null | number | Uint8Array | CoderType, got ${e} (${typeof e})`);
  return {
    encodeStream(t, n) {
      if (e === null)
        return;
      if (Ze(e))
        return e.encodeStream(t, n);
      let r;
      if (typeof e == "number" ? r = e : typeof e == "string" && (r = zn.resolve(t.stack, e)), typeof r == "bigint" && (r = Number(r)), r === void 0 || r !== n)
        throw t.err(`Wrong length: ${r} len=${e} exp=${n} (${typeof n})`);
    },
    decodeStream(t) {
      let n;
      if (Ze(e) ? n = Number(e.decodeStream(t)) : typeof e == "number" ? n = e : typeof e == "string" && (n = zn.resolve(t.stack, e)), typeof n == "bigint" && (n = Number(n)), typeof n != "number")
        throw t.err(`Wrong length: ${n}`);
      return n;
    }
  };
}, Mt = {
  BITS: 32,
  FULL_MASK: -1 >>> 0,
  // 1<<32 will overflow
  len: (e) => Math.ceil(e / 32),
  create: (e) => new Uint32Array(Mt.len(e)),
  clean: (e) => e.fill(0),
  debug: (e) => Array.from(e).map((t) => (t >>> 0).toString(2).padStart(32, "0")),
  checkLen: (e, t) => {
    if (Mt.len(t) !== e.length)
      throw new Error(`wrong length=${e.length}. Expected: ${Mt.len(t)}`);
  },
  chunkLen: (e, t, n) => {
    if (t < 0)
      throw new Error(`wrong pos=${t}`);
    if (t + n > e)
      throw new Error(`wrong range=${t}/${n} of ${e}`);
  },
  set: (e, t, n, r = !0) => !r && (e[t] & n) !== 0 ? !1 : (e[t] |= n, !0),
  pos: (e, t) => ({
    chunk: Math.floor((e + t) / 32),
    mask: 1 << 32 - (e + t) % 32 - 1
  }),
  indices: (e, t, n = !1) => {
    Mt.checkLen(e, t);
    const { FULL_MASK: r, BITS: i } = Mt, s = i - t % i, o = s ? r >>> s << s : r, a = [];
    for (let c = 0; c < e.length; c++) {
      let u = e[c];
      if (n && (u = ~u), c === e.length - 1 && (u &= o), u !== 0)
        for (let l = 0; l < i; l++) {
          const f = 1 << i - l - 1;
          u & f && a.push(c * i + l);
        }
    }
    return a;
  },
  range: (e) => {
    const t = [];
    let n;
    for (const r of e)
      n === void 0 || r !== n.pos + n.length ? t.push(n = { pos: r, length: 1 }) : n.length += 1;
    return t;
  },
  rangeDebug: (e, t, n = !1) => `[${Mt.range(Mt.indices(e, t, n)).map((r) => `(${r.pos}/${r.length})`).join(", ")}]`,
  setRange: (e, t, n, r, i = !0) => {
    Mt.chunkLen(t, n, r);
    const { FULL_MASK: s, BITS: o } = Mt, a = n % o ? Math.floor(n / o) : void 0, c = n + r, u = c % o ? Math.floor(c / o) : void 0;
    if (a !== void 0 && a === u)
      return Mt.set(e, a, s >>> o - r << o - r - n, i);
    if (a !== void 0 && !Mt.set(e, a, s >>> n % o, i))
      return !1;
    const l = a !== void 0 ? a + 1 : n / o, f = u !== void 0 ? u : c / o;
    for (let h = l; h < f; h++)
      if (!Mt.set(e, h, s, i))
        return !1;
    return !(u !== void 0 && a !== u && !Mt.set(e, u, s << o - c % o, i));
  }
}, zn = {
  /**
   * Internal method for handling stack of paths (debug, errors, dynamic fields via path)
   * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).
   * Also, this makes impossible:
   * - pushing field when stack is empty
   * - pushing field inside of field (real bug)
   * NOTE: we don't want to do '.pop' on error!
   */
  pushObj: (e, t, n) => {
    const r = { obj: t };
    e.push(r), n((i, s) => {
      r.field = i, s(), r.field = void 0;
    }), e.pop();
  },
  path: (e) => {
    const t = [];
    for (const n of e)
      n.field !== void 0 && t.push(n.field);
    return t.join("/");
  },
  err: (e, t, n) => {
    const r = new Error(`${e}(${zn.path(t)}): ${typeof n == "string" ? n : n.message}`);
    return n instanceof Error && n.stack && (r.stack = n.stack), r;
  },
  resolve: (e, t) => {
    const n = t.split("/"), r = e.map((o) => o.obj);
    let i = 0;
    for (; i < n.length && n[i] === ".."; i++)
      r.pop();
    let s = r.pop();
    for (; i < n.length; i++) {
      if (!s || s[n[i]] === void 0)
        return;
      s = s[n[i]];
    }
    return s;
  }
};
let vx = class lw {
  pos = 0;
  data;
  opts;
  stack;
  parent;
  parentOffset;
  bitBuf = 0;
  bitPos = 0;
  bs;
  // bitset
  view;
  constructor(t, n = {}, r = [], i = void 0, s = 0) {
    this.data = t, this.opts = n, this.stack = r, this.parent = i, this.parentOffset = s, this.view = cw(t);
  }
  /** Internal method for pointers. */
  _enablePointers() {
    if (this.parent)
      return this.parent._enablePointers();
    this.bs || (this.bs = Mt.create(this.data.length), Mt.setRange(this.bs, this.data.length, 0, this.pos, this.opts.allowMultipleReads));
  }
  markBytesBS(t, n) {
    return this.parent ? this.parent.markBytesBS(this.parentOffset + t, n) : !n || !this.bs ? !0 : Mt.setRange(this.bs, this.data.length, t, n, !1);
  }
  markBytes(t) {
    const n = this.pos;
    this.pos += t;
    const r = this.markBytesBS(n, t);
    if (!this.opts.allowMultipleReads && !r)
      throw this.err(`multiple read pos=${this.pos} len=${t}`);
    return r;
  }
  pushObj(t, n) {
    return zn.pushObj(this.stack, t, n);
  }
  readView(t, n) {
    if (!Number.isFinite(t))
      throw this.err(`readView: wrong length=${t}`);
    if (this.pos + t > this.data.length)
      throw this.err("readView: Unexpected end of buffer");
    const r = n(this.view, this.pos);
    return this.markBytes(t), r;
  }
  // read bytes by absolute offset
  absBytes(t) {
    if (t > this.data.length)
      throw new Error("Unexpected end of buffer");
    return this.data.subarray(t);
  }
  finish() {
    if (!this.opts.allowUnreadBytes) {
      if (this.bitPos)
        throw this.err(`${this.bitPos} bits left after unpack: ${D.encode(this.data.slice(this.pos))}`);
      if (this.bs && !this.parent) {
        const t = Mt.indices(this.bs, this.data.length, !0);
        if (t.length) {
          const n = Mt.range(t).map(({ pos: r, length: i }) => `(${r}/${i})[${D.encode(this.data.subarray(r, r + i))}]`).join(", ");
          throw this.err(`unread byte ranges: ${n} (total=${this.data.length})`);
        } else
          return;
      }
      if (!this.isEnd())
        throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${D.encode(this.data.slice(this.pos))}`);
    }
  }
  // User methods
  err(t) {
    return zn.err("Reader", this.stack, t);
  }
  offsetReader(t) {
    if (t > this.data.length)
      throw this.err("offsetReader: Unexpected end of buffer");
    return new lw(this.absBytes(t), this.opts, this.stack, this, t);
  }
  bytes(t, n = !1) {
    if (this.bitPos)
      throw this.err("readBytes: bitPos not empty");
    if (!Number.isFinite(t))
      throw this.err(`readBytes: wrong length=${t}`);
    if (this.pos + t > this.data.length)
      throw this.err("readBytes: Unexpected end of buffer");
    const r = this.data.subarray(this.pos, this.pos + t);
    return n || this.markBytes(t), r;
  }
  byte(t = !1) {
    if (this.bitPos)
      throw this.err("readByte: bitPos not empty");
    if (this.pos + 1 > this.data.length)
      throw this.err("readBytes: Unexpected end of buffer");
    const n = this.data[this.pos];
    return t || this.markBytes(1), n;
  }
  get leftBytes() {
    return this.data.length - this.pos;
  }
  get totalBytes() {
    return this.data.length;
  }
  isEnd() {
    return this.pos >= this.data.length && !this.bitPos;
  }
  // bits are read in BE mode (left to right): (0b1000_0000).readBits(1) == 1
  bits(t) {
    if (t > 32)
      throw this.err("BitReader: cannot read more than 32 bits in single call");
    let n = 0;
    for (; t; ) {
      this.bitPos || (this.bitBuf = this.byte(), this.bitPos = 8);
      const r = Math.min(t, this.bitPos);
      this.bitPos -= r, n = n << r | this.bitBuf >> this.bitPos & 2 ** r - 1, this.bitBuf &= 2 ** this.bitPos - 1, t -= r;
    }
    return n >>> 0;
  }
  find(t, n = this.pos) {
    if (!Be(t))
      throw this.err(`find: needle is not bytes! ${t}`);
    if (this.bitPos)
      throw this.err("findByte: bitPos not empty");
    if (!t.length)
      throw this.err("find: needle is empty");
    for (let r = n; (r = this.data.indexOf(t[0], r)) !== -1; r++) {
      if (r === -1 || this.data.length - r < t.length)
        return;
      if (Xi(t, this.data.subarray(r, r + t.length)))
        return r;
    }
  }
}, kx = class {
  pos = 0;
  stack;
  // We could have a single buffer here and re-alloc it with
  // x1.5-2 size each time it full, but it will be slower:
  // basic/encode bench: 395ns -> 560ns
  buffers = [];
  ptrs = [];
  bitBuf = 0;
  bitPos = 0;
  viewBuf = new Uint8Array(8);
  view;
  finished = !1;
  constructor(t = []) {
    this.stack = t, this.view = cw(this.viewBuf);
  }
  pushObj(t, n) {
    return zn.pushObj(this.stack, t, n);
  }
  writeView(t, n) {
    if (this.finished)
      throw this.err("buffer: finished");
    if (!In(t) || t > 8)
      throw new Error(`wrong writeView length=${t}`);
    n(this.view), this.bytes(this.viewBuf.slice(0, t)), this.viewBuf.fill(0);
  }
  // User methods
  err(t) {
    if (this.finished)
      throw this.err("buffer: finished");
    return zn.err("Reader", this.stack, t);
  }
  bytes(t) {
    if (this.finished)
      throw this.err("buffer: finished");
    if (this.bitPos)
      throw this.err("writeBytes: ends with non-empty bit buffer");
    this.buffers.push(t), this.pos += t.length;
  }
  byte(t) {
    if (this.finished)
      throw this.err("buffer: finished");
    if (this.bitPos)
      throw this.err("writeByte: ends with non-empty bit buffer");
    this.buffers.push(new Uint8Array([t])), this.pos++;
  }
  finish(t = !0) {
    if (this.finished)
      throw this.err("buffer: finished");
    if (this.bitPos)
      throw this.err("buffer: ends with non-empty bit buffer");
    const n = this.buffers.concat(this.ptrs.map((s) => s.buffer)), r = n.map((s) => s.length).reduce((s, o) => s + o, 0), i = new Uint8Array(r);
    for (let s = 0, o = 0; s < n.length; s++) {
      const a = n[s];
      i.set(a, o), o += a.length;
    }
    for (let s = this.pos, o = 0; o < this.ptrs.length; o++) {
      const a = this.ptrs[o];
      i.set(a.ptr.encode(s), a.pos), s += a.buffer.length;
    }
    if (t) {
      this.buffers = [];
      for (const s of this.ptrs)
        s.buffer.fill(0);
      this.ptrs = [], this.finished = !0, this.bitBuf = 0;
    }
    return i;
  }
  bits(t, n) {
    if (n > 32)
      throw this.err("writeBits: cannot write more than 32 bits in single call");
    if (t >= 2 ** n)
      throw this.err(`writeBits: value (${t}) >= 2**bits (${n})`);
    for (; n; ) {
      const r = Math.min(n, 8 - this.bitPos);
      this.bitBuf = this.bitBuf << r | t >> n - r, this.bitPos += r, n -= r, t &= 2 ** n - 1, this.bitPos === 8 && (this.bitPos = 0, this.buffers.push(new Uint8Array([this.bitBuf])), this.pos++);
    }
  }
};
const kl = (e) => Uint8Array.from(e).reverse();
function Ax(e, t, n) {
  if (n) {
    const r = 2n ** (t - 1n);
    if (e < -r || e >= r)
      throw new Error(`value out of signed bounds. Expected ${-r} <= ${e} < ${r}`);
  } else if (0n > e || e >= 2n ** t)
    throw new Error(`value out of unsigned bounds. Expected 0 <= ${e} < ${2n ** t}`);
}
function fw(e) {
  return {
    // NOTE: we cannot export validate here, since it is likely mistake.
    encodeStream: e.encodeStream,
    decodeStream: e.decodeStream,
    size: e.size,
    encode: (t) => {
      const n = new kx();
      return e.encodeStream(n, t), n.finish();
    },
    decode: (t, n = {}) => {
      const r = new vx(t, n), i = e.decodeStream(r);
      return r.finish(), i;
    }
  };
}
function le(e, t) {
  if (!Ze(e))
    throw new Error(`validate: invalid inner value ${e}`);
  if (typeof t != "function")
    throw new Error("validate: fn should be function");
  return fw({
    size: e.size,
    encodeStream: (n, r) => {
      let i;
      try {
        i = t(r);
      } catch (s) {
        throw n.err(s);
      }
      e.encodeStream(n, i);
    },
    decodeStream: (n) => {
      const r = e.decodeStream(n);
      try {
        return t(r);
      } catch (i) {
        throw n.err(i);
      }
    }
  });
}
const fe = (e) => {
  const t = fw(e);
  return e.validate ? le(t, e.validate) : t;
}, Mc = (e) => To(e) && typeof e.decode == "function" && typeof e.encode == "function";
function Ze(e) {
  return To(e) && Mc(e) && typeof e.encodeStream == "function" && typeof e.decodeStream == "function" && (e.size === void 0 || In(e.size));
}
function $x() {
  return {
    encode: (e) => {
      if (!Array.isArray(e))
        throw new Error("array expected");
      const t = {};
      for (const n of e) {
        if (!Array.isArray(n) || n.length !== 2)
          throw new Error("array of two elements expected");
        const r = n[0], i = n[1];
        if (t[r] !== void 0)
          throw new Error(`key(${r}) appears twice in struct`);
        t[r] = i;
      }
      return t;
    },
    decode: (e) => {
      if (!To(e))
        throw new Error(`expected plain object, got ${e}`);
      return Object.entries(e);
    }
  };
}
const Ix = {
  encode: (e) => {
    if (typeof e != "bigint")
      throw new Error(`expected bigint, got ${typeof e}`);
    if (e > BigInt(Number.MAX_SAFE_INTEGER))
      throw new Error(`element bigger than MAX_SAFE_INTEGER=${e}`);
    return Number(e);
  },
  decode: (e) => {
    if (!In(e))
      throw new Error("element is not a safe integer");
    return BigInt(e);
  }
};
function Ox(e) {
  if (!To(e))
    throw new Error("plain object expected");
  return {
    encode: (t) => {
      if (!In(t) || !(t in e))
        throw new Error(`wrong value ${t}`);
      return e[t];
    },
    decode: (t) => {
      if (typeof t != "string")
        throw new Error(`wrong value ${typeof t}`);
      return e[t];
    }
  };
}
function Bx(e, t = !1) {
  if (!In(e))
    throw new Error(`decimal/precision: wrong value ${e}`);
  if (typeof t != "boolean")
    throw new Error(`decimal/round: expected boolean, got ${typeof t}`);
  const n = 10n ** BigInt(e);
  return {
    encode: (r) => {
      if (typeof r != "bigint")
        throw new Error(`expected bigint, got ${typeof r}`);
      let i = (r < 0n ? -r : r).toString(10), s = i.length - e;
      s < 0 && (i = i.padStart(i.length - s, "0"), s = 0);
      let o = i.length - 1;
      for (; o >= s && i[o] === "0"; o--)
        ;
      let a = i.slice(0, s), c = i.slice(s, o + 1);
      return a || (a = "0"), r < 0n && (a = "-" + a), c ? `${a}.${c}` : a;
    },
    decode: (r) => {
      if (typeof r != "string")
        throw new Error(`expected string, got ${typeof r}`);
      if (r === "-0")
        throw new Error("negative zero is not allowed");
      let i = !1;
      if (r.startsWith("-") && (i = !0, r = r.slice(1)), !/^(0|[1-9]\d*)(\.\d+)?$/.test(r))
        throw new Error(`wrong string value=${r}`);
      let s = r.indexOf(".");
      s = s === -1 ? r.length : s;
      const o = r.slice(0, s), a = r.slice(s + 1).replace(/0+$/, ""), c = BigInt(o) * n;
      if (!t && a.length > e)
        throw new Error(`fractional part cannot be represented with this precision (num=${r}, prec=${e})`);
      const u = Math.min(a.length, e), l = BigInt(a.slice(0, u)) * 10n ** BigInt(e - u), f = c + l;
      return i ? -f : f;
    }
  };
}
function Cx(e) {
  if (!Array.isArray(e))
    throw new Error(`expected array, got ${typeof e}`);
  for (const t of e)
    if (!Mc(t))
      throw new Error(`wrong base coder ${t}`);
  return {
    encode: (t) => {
      for (const n of e) {
        const r = n.encode(t);
        if (r !== void 0)
          return r;
      }
      throw new Error(`match/encode: cannot find match in ${t}`);
    },
    decode: (t) => {
      for (const n of e) {
        const r = n.decode(t);
        if (r !== void 0)
          return r;
      }
      throw new Error(`match/decode: cannot find match in ${t}`);
    }
  };
}
const dw = (e) => {
  if (!Mc(e))
    throw new Error("BaseCoder expected");
  return { encode: e.decode, decode: e.encode };
}, Fc = { dict: $x, numberBigint: Ix, tsEnum: Ox, decimal: Bx, match: Cx, reverse: dw }, Hf = (e, t = !1, n = !1, r = !0) => {
  if (!In(e))
    throw new Error(`bigint/size: wrong value ${e}`);
  if (typeof t != "boolean")
    throw new Error(`bigint/le: expected boolean, got ${typeof t}`);
  if (typeof n != "boolean")
    throw new Error(`bigint/signed: expected boolean, got ${typeof n}`);
  if (typeof r != "boolean")
    throw new Error(`bigint/sized: expected boolean, got ${typeof r}`);
  const i = BigInt(e), s = 2n ** (8n * i - 1n);
  return fe({
    size: r ? e : void 0,
    encodeStream: (o, a) => {
      n && a < 0 && (a = a | s);
      const c = [];
      for (let l = 0; l < e; l++)
        c.push(Number(a & 255n)), a >>= 8n;
      let u = new Uint8Array(c).reverse();
      if (!r) {
        let l = 0;
        for (l = 0; l < u.length && u[l] === 0; l++)
          ;
        u = u.subarray(l);
      }
      o.bytes(t ? u.reverse() : u);
    },
    decodeStream: (o) => {
      const a = o.bytes(r ? e : Math.min(e, o.leftBytes)), c = t ? a : kl(a);
      let u = 0n;
      for (let l = 0; l < c.length; l++)
        u |= BigInt(c[l]) << 8n * BigInt(l);
      return n && u & s && (u = (u ^ s) - s), u;
    },
    validate: (o) => {
      if (typeof o != "bigint")
        throw new Error(`bigint: invalid value: ${o}`);
      return Ax(o, 8n * i, !!n), o;
    }
  });
}, hw = /* @__PURE__ */ Hf(32, !1), aa = /* @__PURE__ */ Hf(8, !0), Rx = /* @__PURE__ */ Hf(8, !0, !0), Px = (e, t) => fe({
  size: e,
  encodeStream: (n, r) => n.writeView(e, (i) => t.write(i, r)),
  decodeStream: (n) => n.readView(e, t.read),
  validate: (n) => {
    if (typeof n != "number")
      throw new Error(`viewCoder: expected number, got ${typeof n}`);
    return t.validate && t.validate(n), n;
  }
}), So = (e, t, n) => {
  const r = e * 8, i = 2 ** (r - 1), s = (c) => {
    if (!In(c))
      throw new Error(`sintView: value is not safe integer: ${c}`);
    if (c < -i || c >= i)
      throw new Error(`sintView: value out of bounds. Expected ${-i} <= ${c} < ${i}`);
  }, o = 2 ** r, a = (c) => {
    if (!In(c))
      throw new Error(`uintView: value is not safe integer: ${c}`);
    if (0 > c || c >= o)
      throw new Error(`uintView: value out of bounds. Expected 0 <= ${c} < ${o}`);
  };
  return Px(e, {
    write: n.write,
    read: n.read,
    validate: t ? s : a
  });
}, dt = /* @__PURE__ */ So(4, !1, {
  read: (e, t) => e.getUint32(t, !0),
  write: (e, t) => e.setUint32(0, t, !0)
}), Nx = /* @__PURE__ */ So(4, !1, {
  read: (e, t) => e.getUint32(t, !1),
  write: (e, t) => e.setUint32(0, t, !1)
}), Bi = /* @__PURE__ */ So(4, !0, {
  read: (e, t) => e.getInt32(t, !0),
  write: (e, t) => e.setInt32(0, t, !0)
}), Ah = /* @__PURE__ */ So(2, !1, {
  read: (e, t) => e.getUint16(t, !0),
  write: (e, t) => e.setUint16(0, t, !0)
}), Tr = /* @__PURE__ */ So(1, !1, {
  read: (e, t) => e.getUint8(t),
  write: (e, t) => e.setUint8(0, t)
}), vt = (e, t = !1) => {
  if (typeof t != "boolean")
    throw new Error(`bytes/le: expected boolean, got ${typeof t}`);
  const n = uw(e), r = Be(e);
  return fe({
    size: typeof e == "number" ? e : void 0,
    encodeStream: (i, s) => {
      r || n.encodeStream(i, s.length), i.bytes(t ? kl(s) : s), r && i.bytes(e);
    },
    decodeStream: (i) => {
      let s;
      if (r) {
        const o = i.find(e);
        if (!o)
          throw i.err("bytes: cannot find terminator");
        s = i.bytes(o - i.pos), i.bytes(e.length);
      } else
        s = i.bytes(e === null ? i.leftBytes : n.decodeStream(i));
      return t ? kl(s) : s;
    },
    validate: (i) => {
      if (!Be(i))
        throw new Error(`bytes: invalid value ${i}`);
      return i;
    }
  });
};
function Lx(e, t) {
  if (!Ze(t))
    throw new Error(`prefix: invalid inner value ${t}`);
  return Br(vt(e), dw(t));
}
const Wf = (e, t = !1) => le(Br(vt(e, t), Ex), (n) => {
  if (typeof n != "string")
    throw new Error(`expected string, got ${typeof n}`);
  return n;
}), Ux = (e, t = { isLE: !1, with0x: !1 }) => {
  let n = Br(vt(e, t.isLE), D);
  const r = t.with0x;
  if (typeof r != "boolean")
    throw new Error(`hex/with0x: expected boolean, got ${typeof r}`);
  return r && (n = Br(n, {
    encode: (i) => `0x${i}`,
    decode: (i) => {
      if (!i.startsWith("0x"))
        throw new Error("hex(with0x=true).encode input should start with 0x");
      return i.slice(2);
    }
  })), n;
};
function Br(e, t) {
  if (!Ze(e))
    throw new Error(`apply: invalid inner value ${e}`);
  if (!Mc(t))
    throw new Error(`apply: invalid base value ${e}`);
  return fe({
    size: e.size,
    encodeStream: (n, r) => {
      let i;
      try {
        i = t.decode(r);
      } catch (s) {
        throw n.err("" + s);
      }
      return e.encodeStream(n, i);
    },
    decodeStream: (n) => {
      const r = e.decodeStream(n);
      try {
        return t.encode(r);
      } catch (i) {
        throw n.err("" + i);
      }
    }
  });
}
const _x = (e, t = !1) => {
  if (!Be(e))
    throw new Error(`flag/flagValue: expected Uint8Array, got ${typeof e}`);
  if (typeof t != "boolean")
    throw new Error(`flag/xor: expected boolean, got ${typeof t}`);
  return fe({
    size: e.length,
    encodeStream: (n, r) => {
      !!r !== t && n.bytes(e);
    },
    decodeStream: (n) => {
      let r = n.leftBytes >= e.length;
      return r && (r = Xi(n.bytes(e.length, !0), e), r && n.bytes(e.length)), r !== t;
    },
    validate: (n) => {
      if (n !== void 0 && typeof n != "boolean")
        throw new Error(`flag: expected boolean value or undefined, got ${typeof n}`);
      return n;
    }
  });
};
function Dx(e, t, n) {
  if (!Ze(t))
    throw new Error(`flagged: invalid inner value ${t}`);
  return fe({
    encodeStream: (r, i) => {
      zn.resolve(r.stack, e) && t.encodeStream(r, i);
    },
    decodeStream: (r) => {
      let i = !1;
      if (i = !!zn.resolve(r.stack, e), i)
        return t.decodeStream(r);
    }
  });
}
function Kf(e, t, n = !0) {
  if (!Ze(e))
    throw new Error(`magic: invalid inner value ${e}`);
  if (typeof n != "boolean")
    throw new Error(`magic: expected boolean, got ${typeof n}`);
  return fe({
    size: e.size,
    encodeStream: (r, i) => e.encodeStream(r, t),
    decodeStream: (r) => {
      const i = e.decodeStream(r);
      if (n && typeof i != "object" && i !== t || Be(t) && !Xi(t, i))
        throw r.err(`magic: invalid value: ${i} !== ${t}`);
    },
    validate: (r) => {
      if (r !== void 0)
        throw new Error(`magic: wrong value=${typeof r}`);
      return r;
    }
  });
}
function pw(e) {
  let t = 0;
  for (const n of e) {
    if (n.size === void 0)
      return;
    if (!In(n.size))
      throw new Error(`sizeof: wrong element size=${t}`);
    t += n.size;
  }
  return t;
}
function jt(e) {
  if (!To(e))
    throw new Error(`struct: expected plain object, got ${e}`);
  for (const t in e)
    if (!Ze(e[t]))
      throw new Error(`struct: field ${t} is not CoderType`);
  return fe({
    size: pw(Object.values(e)),
    encodeStream: (t, n) => {
      t.pushObj(n, (r) => {
        for (const i in e)
          r(i, () => e[i].encodeStream(t, n[i]));
      });
    },
    decodeStream: (t) => {
      const n = {};
      return t.pushObj(n, (r) => {
        for (const i in e)
          r(i, () => n[i] = e[i].decodeStream(t));
      }), n;
    },
    validate: (t) => {
      if (typeof t != "object" || t === null)
        throw new Error(`struct: invalid value ${t}`);
      return t;
    }
  });
}
function Vx(e) {
  if (!Array.isArray(e))
    throw new Error(`Packed.Tuple: got ${typeof e} instead of array`);
  for (let t = 0; t < e.length; t++)
    if (!Ze(e[t]))
      throw new Error(`tuple: field ${t} is not CoderType`);
  return fe({
    size: pw(e),
    encodeStream: (t, n) => {
      if (!Array.isArray(n))
        throw t.err(`tuple: invalid value ${n}`);
      t.pushObj(n, (r) => {
        for (let i = 0; i < e.length; i++)
          r(`${i}`, () => e[i].encodeStream(t, n[i]));
      });
    },
    decodeStream: (t) => {
      const n = [];
      return t.pushObj(n, (r) => {
        for (let i = 0; i < e.length; i++)
          r(`${i}`, () => n.push(e[i].decodeStream(t)));
      }), n;
    },
    validate: (t) => {
      if (!Array.isArray(t))
        throw new Error(`tuple: invalid value ${t}`);
      if (t.length !== e.length)
        throw new Error(`tuple: wrong length=${t.length}, expected ${e.length}`);
      return t;
    }
  });
}
function ce(e, t) {
  if (!Ze(t))
    throw new Error(`array: invalid inner value ${t}`);
  const n = uw(typeof e == "string" ? `../${e}` : e);
  return fe({
    size: typeof e == "number" && t.size ? e * t.size : void 0,
    encodeStream: (r, i) => {
      const s = r;
      s.pushObj(i, (o) => {
        Be(e) || n.encodeStream(r, i.length);
        for (let a = 0; a < i.length; a++)
          o(`${a}`, () => {
            const c = i[a], u = r.pos;
            if (t.encodeStream(r, c), Be(e)) {
              if (e.length > s.pos - u)
                return;
              const l = s.finish(!1).subarray(u, s.pos);
              if (Xi(l.subarray(0, e.length), e))
                throw s.err(`array: inner element encoding same as separator. elm=${c} data=${l}`);
            }
          });
      }), Be(e) && r.bytes(e);
    },
    decodeStream: (r) => {
      const i = [];
      return r.pushObj(i, (s) => {
        if (e === null)
          for (let o = 0; !r.isEnd() && (s(`${o}`, () => i.push(t.decodeStream(r))), !(t.size && r.leftBytes < t.size)); o++)
            ;
        else if (Be(e))
          for (let o = 0; ; o++) {
            if (Xi(r.bytes(e.length, !0), e)) {
              r.bytes(e.length);
              break;
            }
            s(`${o}`, () => i.push(t.decodeStream(r)));
          }
        else {
          let o;
          s("arrayLen", () => o = n.decodeStream(r));
          for (let a = 0; a < o; a++)
            s(`${a}`, () => i.push(t.decodeStream(r)));
        }
      }), i;
    },
    validate: (r) => {
      if (!Array.isArray(r))
        throw new Error(`array: invalid value ${r}`);
      return r;
    }
  });
}
const bs = Er.Point, $h = bs.Fn, gw = bs.Fn.ORDER, jf = (e) => e % 2n === 0n, Et = Ff.isBytes, mr = Ff.concatBytes, Pt = Ff.equalBytes, yw = (e) => cx(ge(e)), ir = (...e) => ge(ge(mr(...e))), ww = rn.getPublicKey, Mx = Er.getPublicKey, Ih = (e) => e.r < gw / 2n;
function Fx(e, t, n = !1) {
  let r = Er.Signature.fromBytes(Er.sign(e, t, { prehash: !1 }));
  if (n && !Ih(r)) {
    const i = new Uint8Array(32);
    let s = 0;
    for (; !Ih(r); )
      if (i.set(dt.encode(s++)), r = Er.Signature.fromBytes(Er.sign(e, t, { prehash: !1, extraEntropy: i })), s > 4294967295)
        throw new Error("lowR counter overflow: report the error");
  }
  return r.toBytes("der");
}
const Oh = rn.sign, zf = rn.utils.taggedHash, ye = {
  ecdsa: 0,
  schnorr: 1
};
function Qi(e, t) {
  const n = e.length;
  if (t === ye.ecdsa) {
    if (n === 32)
      throw new Error("Expected non-Schnorr key");
    return bs.fromBytes(e), e;
  } else if (t === ye.schnorr) {
    if (n !== 32)
      throw new Error("Expected 32-byte Schnorr key");
    return rn.utils.lift_x(Yn(e)), e;
  } else
    throw new Error("Unknown key type");
}
function mw(e, t) {
  const r = rn.utils.taggedHash("TapTweak", e, t), i = Yn(r);
  if (i >= gw)
    throw new Error("tweak higher than curve order");
  return i;
}
function Hx(e, t = Uint8Array.of()) {
  const n = rn.utils, r = Yn(e), i = bs.BASE.multiply(r), s = jf(i.y) ? r : $h.neg(r), o = n.pointToBytes(i), a = mw(o, t);
  return Lc($h.add(s, a), 32);
}
function Al(e, t) {
  const n = rn.utils, r = mw(e, t), s = n.lift_x(Yn(e)).add(bs.BASE.multiply(r)), o = jf(s.y) ? 0 : 1;
  return [n.pointToBytes(s), o];
}
const qf = ge(bs.BASE.toBytes(!1)), Ji = {
  bech32: "bc",
  pubKeyHash: 0,
  scriptHash: 5,
  wif: 128
}, Po = {
  bech32: "tb",
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
function Ha(e, t) {
  if (!Et(e) || !Et(t))
    throw new Error(`cmp: wrong type a=${typeof e} b=${typeof t}`);
  const n = Math.min(e.length, t.length);
  for (let r = 0; r < n; r++)
    if (e[r] != t[r])
      return Math.sign(e[r] - t[r]);
  return Math.sign(e.length - t.length);
}
function bw(e) {
  const t = {};
  for (const n in e) {
    if (t[e[n]] !== void 0)
      throw new Error("duplicate key");
    t[e[n]] = n;
  }
  return t;
}
const Dt = {
  OP_0: 0,
  PUSHDATA1: 76,
  PUSHDATA2: 77,
  PUSHDATA4: 78,
  "1NEGATE": 79,
  RESERVED: 80,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  // Control
  NOP: 97,
  VER: 98,
  IF: 99,
  NOTIF: 100,
  VERIF: 101,
  VERNOTIF: 102,
  ELSE: 103,
  ENDIF: 104,
  VERIFY: 105,
  RETURN: 106,
  // Stack
  TOALTSTACK: 107,
  FROMALTSTACK: 108,
  "2DROP": 109,
  "2DUP": 110,
  "3DUP": 111,
  "2OVER": 112,
  "2ROT": 113,
  "2SWAP": 114,
  IFDUP: 115,
  DEPTH: 116,
  DROP: 117,
  DUP: 118,
  NIP: 119,
  OVER: 120,
  PICK: 121,
  ROLL: 122,
  ROT: 123,
  SWAP: 124,
  TUCK: 125,
  // Splice
  CAT: 126,
  SUBSTR: 127,
  LEFT: 128,
  RIGHT: 129,
  SIZE: 130,
  // Boolean logic
  INVERT: 131,
  AND: 132,
  OR: 133,
  XOR: 134,
  EQUAL: 135,
  EQUALVERIFY: 136,
  RESERVED1: 137,
  RESERVED2: 138,
  // Numbers
  "1ADD": 139,
  "1SUB": 140,
  "2MUL": 141,
  "2DIV": 142,
  NEGATE: 143,
  ABS: 144,
  NOT: 145,
  "0NOTEQUAL": 146,
  ADD: 147,
  SUB: 148,
  MUL: 149,
  DIV: 150,
  MOD: 151,
  LSHIFT: 152,
  RSHIFT: 153,
  BOOLAND: 154,
  BOOLOR: 155,
  NUMEQUAL: 156,
  NUMEQUALVERIFY: 157,
  NUMNOTEQUAL: 158,
  LESSTHAN: 159,
  GREATERTHAN: 160,
  LESSTHANOREQUAL: 161,
  GREATERTHANOREQUAL: 162,
  MIN: 163,
  MAX: 164,
  WITHIN: 165,
  // Crypto
  RIPEMD160: 166,
  SHA1: 167,
  SHA256: 168,
  HASH160: 169,
  HASH256: 170,
  CODESEPARATOR: 171,
  CHECKSIG: 172,
  CHECKSIGVERIFY: 173,
  CHECKMULTISIG: 174,
  CHECKMULTISIGVERIFY: 175,
  // Expansion
  NOP1: 176,
  CHECKLOCKTIMEVERIFY: 177,
  CHECKSEQUENCEVERIFY: 178,
  NOP4: 179,
  NOP5: 180,
  NOP6: 181,
  NOP7: 182,
  NOP8: 183,
  NOP9: 184,
  NOP10: 185,
  // BIP 342
  CHECKSIGADD: 186,
  // Invalid
  INVALID: 255
}, Wx = bw(Dt);
function Gf(e = 6, t = !1) {
  return fe({
    encodeStream: (n, r) => {
      if (r === 0n)
        return;
      const i = r < 0, s = BigInt(r), o = [];
      for (let a = i ? -s : s; a; a >>= 8n)
        o.push(Number(a & 0xffn));
      o[o.length - 1] >= 128 ? o.push(i ? 128 : 0) : i && (o[o.length - 1] |= 128), n.bytes(new Uint8Array(o));
    },
    decodeStream: (n) => {
      const r = n.leftBytes;
      if (r > e)
        throw new Error(`ScriptNum: number (${r}) bigger than limit=${e}`);
      if (r === 0)
        return 0n;
      if (t) {
        const o = n.bytes(r, !0);
        if ((o[o.length - 1] & 127) === 0 && (r <= 1 || (o[o.length - 2] & 128) === 0))
          throw new Error("Non-minimally encoded ScriptNum");
      }
      let i = 0, s = 0n;
      for (let o = 0; o < r; ++o)
        i = n.byte(), s |= BigInt(i) << 8n * BigInt(o);
      return i >= 128 && (s &= 2n ** BigInt(r * 8) - 1n >> 1n, s = -s), s;
    }
  });
}
function Kx(e, t = 4, n = !0) {
  if (typeof e == "number")
    return e;
  if (Et(e))
    try {
      const r = Gf(t, n).decode(e);
      return r > Number.MAX_SAFE_INTEGER ? void 0 : Number(r);
    } catch {
      return;
    }
}
const nt = fe({
  encodeStream: (e, t) => {
    for (let n of t) {
      if (typeof n == "string") {
        if (Dt[n] === void 0)
          throw new Error(`Unknown opcode=${n}`);
        e.byte(Dt[n]);
        continue;
      } else if (typeof n == "number") {
        if (n === 0) {
          e.byte(0);
          continue;
        } else if (1 <= n && n <= 16) {
          e.byte(Dt.OP_1 - 1 + n);
          continue;
        }
      }
      if (typeof n == "number" && (n = Gf().encode(BigInt(n))), !Et(n))
        throw new Error(`Wrong Script OP=${n} (${typeof n})`);
      const r = n.length;
      r < Dt.PUSHDATA1 ? e.byte(r) : r <= 255 ? (e.byte(Dt.PUSHDATA1), e.byte(r)) : r <= 65535 ? (e.byte(Dt.PUSHDATA2), e.bytes(Ah.encode(r))) : (e.byte(Dt.PUSHDATA4), e.bytes(dt.encode(r))), e.bytes(n);
    }
  },
  decodeStream: (e) => {
    const t = [];
    for (; !e.isEnd(); ) {
      const n = e.byte();
      if (Dt.OP_0 < n && n <= Dt.PUSHDATA4) {
        let r;
        if (n < Dt.PUSHDATA1)
          r = n;
        else if (n === Dt.PUSHDATA1)
          r = Tr.decodeStream(e);
        else if (n === Dt.PUSHDATA2)
          r = Ah.decodeStream(e);
        else if (n === Dt.PUSHDATA4)
          r = dt.decodeStream(e);
        else
          throw new Error("Should be not possible");
        t.push(e.bytes(r));
      } else if (n === 0)
        t.push(0);
      else if (Dt.OP_1 <= n && n <= Dt.OP_16)
        t.push(n - (Dt.OP_1 - 1));
      else {
        const r = Wx[n];
        if (r === void 0)
          throw new Error(`Unknown opcode=${n.toString(16)}`);
        t.push(r);
      }
    }
    return t;
  }
}), Bh = {
  253: [253, 2, 253n, 65535n],
  254: [254, 4, 65536n, 4294967295n],
  255: [255, 8, 4294967296n, 18446744073709551615n]
}, Hc = fe({
  encodeStream: (e, t) => {
    if (typeof t == "number" && (t = BigInt(t)), 0n <= t && t <= 252n)
      return e.byte(Number(t));
    for (const [n, r, i, s] of Object.values(Bh))
      if (!(i > t || t > s)) {
        e.byte(n);
        for (let o = 0; o < r; o++)
          e.byte(Number(t >> 8n * BigInt(o) & 0xffn));
        return;
      }
    throw e.err(`VarInt too big: ${t}`);
  },
  decodeStream: (e) => {
    const t = e.byte();
    if (t <= 252)
      return BigInt(t);
    const [n, r, i] = Bh[t];
    let s = 0n;
    for (let o = 0; o < r; o++)
      s |= BigInt(e.byte()) << 8n * BigInt(o);
    if (s < i)
      throw e.err(`Wrong CompactSize(${8 * r})`);
    return s;
  }
}), Xe = Br(Hc, Fc.numberBigint), Ke = vt(Hc), oo = ce(Xe, Ke), Wa = (e) => ce(Hc, e), Ew = jt({
  txid: vt(32, !0),
  // hash(prev_tx),
  index: dt,
  // output number of previous tx
  finalScriptSig: Ke,
  // btc merges input and output script, executes it. If ok = tx passes
  sequence: dt
  // ?
}), ri = jt({ amount: aa, script: Ke }), jx = jt({
  version: Bi,
  segwitFlag: _x(new Uint8Array([0, 1])),
  inputs: Wa(Ew),
  outputs: Wa(ri),
  witnesses: Dx("segwitFlag", ce("inputs/length", oo)),
  // < 500000000	Block number at which this transaction is unlocked
  // >= 500000000	UNIX timestamp at which this transaction is unlocked
  // Handled as part of PSBTv2
  lockTime: dt
});
function zx(e) {
  if (e.segwitFlag && e.witnesses && !e.witnesses.length)
    throw new Error("Segwit flag with empty witnesses array");
  return e;
}
const Vi = le(jx, zx), Vs = jt({
  version: Bi,
  inputs: Wa(Ew),
  outputs: Wa(ri),
  lockTime: dt
}), $l = le(vt(null), (e) => Qi(e, ye.ecdsa)), Ka = le(vt(32), (e) => Qi(e, ye.schnorr)), Ch = le(vt(null), (e) => {
  if (e.length !== 64 && e.length !== 65)
    throw new Error("Schnorr signature should be 64 or 65 bytes long");
  return e;
}), Wc = jt({
  fingerprint: Nx,
  path: ce(null, dt)
}), xw = jt({
  hashes: ce(Xe, vt(32)),
  der: Wc
}), qx = vt(78), Gx = jt({ pubKey: Ka, leafHash: vt(32) }), Yx = jt({
  version: Tr,
  // With parity :(
  internalKey: vt(32),
  merklePath: ce(null, vt(32))
}), xn = le(Yx, (e) => {
  if (e.merklePath.length > 128)
    throw new Error("TaprootControlBlock: merklePath should be of length 0..128 (inclusive)");
  return e;
}), Zx = ce(null, jt({
  depth: Tr,
  version: Tr,
  script: Ke
})), Ct = vt(null), Rh = vt(20), ks = vt(32), Yf = {
  unsignedTx: [0, !1, Vs, [0], [0], !1],
  xpub: [1, qx, Wc, [], [0, 2], !1],
  txVersion: [2, !1, dt, [2], [2], !1],
  fallbackLocktime: [3, !1, dt, [], [2], !1],
  inputCount: [4, !1, Xe, [2], [2], !1],
  outputCount: [5, !1, Xe, [2], [2], !1],
  txModifiable: [6, !1, Tr, [], [2], !1],
  // TODO: bitfield
  version: [251, !1, dt, [], [0, 2], !1],
  proprietary: [252, Ct, Ct, [], [0, 2], !1]
}, Kc = {
  nonWitnessUtxo: [0, !1, Vi, [], [0, 2], !1],
  witnessUtxo: [1, !1, ri, [], [0, 2], !1],
  partialSig: [2, $l, Ct, [], [0, 2], !1],
  sighashType: [3, !1, dt, [], [0, 2], !1],
  redeemScript: [4, !1, Ct, [], [0, 2], !1],
  witnessScript: [5, !1, Ct, [], [0, 2], !1],
  bip32Derivation: [6, $l, Wc, [], [0, 2], !1],
  finalScriptSig: [7, !1, Ct, [], [0, 2], !1],
  finalScriptWitness: [8, !1, oo, [], [0, 2], !1],
  porCommitment: [9, !1, Ct, [], [0, 2], !1],
  ripemd160: [10, Rh, Ct, [], [0, 2], !1],
  sha256: [11, ks, Ct, [], [0, 2], !1],
  hash160: [12, Rh, Ct, [], [0, 2], !1],
  hash256: [13, ks, Ct, [], [0, 2], !1],
  txid: [14, !1, ks, [2], [2], !0],
  index: [15, !1, dt, [2], [2], !0],
  sequence: [16, !1, dt, [], [2], !0],
  requiredTimeLocktime: [17, !1, dt, [], [2], !1],
  requiredHeightLocktime: [18, !1, dt, [], [2], !1],
  tapKeySig: [19, !1, Ch, [], [0, 2], !1],
  tapScriptSig: [20, Gx, Ch, [], [0, 2], !1],
  tapLeafScript: [21, xn, Ct, [], [0, 2], !1],
  tapBip32Derivation: [22, ks, xw, [], [0, 2], !1],
  tapInternalKey: [23, !1, Ka, [], [0, 2], !1],
  tapMerkleRoot: [24, !1, ks, [], [0, 2], !1],
  proprietary: [252, Ct, Ct, [], [0, 2], !1]
}, Xx = [
  "txid",
  "sequence",
  "index",
  "witnessUtxo",
  "nonWitnessUtxo",
  "finalScriptSig",
  "finalScriptWitness",
  "unknown"
], Qx = [
  "partialSig",
  "finalScriptSig",
  "finalScriptWitness",
  "tapKeySig",
  "tapScriptSig"
], ao = {
  redeemScript: [0, !1, Ct, [], [0, 2], !1],
  witnessScript: [1, !1, Ct, [], [0, 2], !1],
  bip32Derivation: [2, $l, Wc, [], [0, 2], !1],
  amount: [3, !1, Rx, [2], [2], !0],
  script: [4, !1, Ct, [2], [2], !0],
  tapInternalKey: [5, !1, Ka, [], [0, 2], !1],
  tapTree: [6, !1, Zx, [], [0, 2], !1],
  tapBip32Derivation: [7, Ka, xw, [], [0, 2], !1],
  proprietary: [252, Ct, Ct, [], [0, 2], !1]
}, Jx = [], Ph = ce(aw, jt({
  //  <key> := <keylen> <keytype> <keydata> WHERE keylen = len(keytype)+len(keydata)
  key: Lx(Xe, jt({ type: Xe, key: vt(null) })),
  //  <value> := <valuelen> <valuedata>
  value: vt(Xe)
}));
function Il(e) {
  const [t, n, r, i, s, o] = e;
  return { type: t, kc: n, vc: r, reqInc: i, allowInc: s, silentIgnore: o };
}
jt({ type: Xe, key: vt(null) });
function Zf(e) {
  const t = {};
  for (const n in e) {
    const [r, i, s] = e[n];
    t[r] = [n, i, s];
  }
  return fe({
    encodeStream: (n, r) => {
      let i = [];
      for (const s in e) {
        const o = r[s];
        if (o === void 0)
          continue;
        const [a, c, u] = e[s];
        if (!c)
          i.push({ key: { type: a, key: At }, value: u.encode(o) });
        else {
          const l = o.map(([f, h]) => [
            c.encode(f),
            u.encode(h)
          ]);
          l.sort((f, h) => Ha(f[0], h[0]));
          for (const [f, h] of l)
            i.push({ key: { key: f, type: a }, value: h });
        }
      }
      if (r.unknown) {
        r.unknown.sort((s, o) => Ha(s[0].key, o[0].key));
        for (const [s, o] of r.unknown)
          i.push({ key: s, value: o });
      }
      Ph.encodeStream(n, i);
    },
    decodeStream: (n) => {
      const r = Ph.decodeStream(n), i = {}, s = {};
      for (const o of r) {
        let a = "unknown", c = o.key.key, u = o.value;
        if (t[o.key.type]) {
          const [l, f, h] = t[o.key.type];
          if (a = l, !f && c.length)
            throw new Error(`PSBT: Non-empty key for ${a} (key=${D.encode(c)} value=${D.encode(u)}`);
          if (c = f ? f.decode(c) : void 0, u = h.decode(u), !f) {
            if (i[a])
              throw new Error(`PSBT: Same keys: ${a} (key=${c} value=${u})`);
            i[a] = u, s[a] = !0;
            continue;
          }
        } else
          c = { type: o.key.type, key: o.key.key };
        if (s[a])
          throw new Error(`PSBT: Key type with empty key and no key=${a} val=${u}`);
        i[a] || (i[a] = []), i[a].push([c, u]);
      }
      return i;
    }
  });
}
const Xf = le(Zf(Kc), (e) => {
  if (e.finalScriptWitness && !e.finalScriptWitness.length)
    throw new Error("validateInput: empty finalScriptWitness");
  if (e.partialSig && !e.partialSig.length)
    throw new Error("Empty partialSig");
  if (e.partialSig)
    for (const [t] of e.partialSig)
      Qi(t, ye.ecdsa);
  if (e.bip32Derivation)
    for (const [t] of e.bip32Derivation)
      Qi(t, ye.ecdsa);
  if (e.requiredTimeLocktime !== void 0 && e.requiredTimeLocktime < 5e8)
    throw new Error(`validateInput: wrong timeLocktime=${e.requiredTimeLocktime}`);
  if (e.requiredHeightLocktime !== void 0 && (e.requiredHeightLocktime <= 0 || e.requiredHeightLocktime >= 5e8))
    throw new Error(`validateInput: wrong heighLocktime=${e.requiredHeightLocktime}`);
  if (e.tapLeafScript)
    for (const [t, n] of e.tapLeafScript) {
      if ((t.version & 254) !== n[n.length - 1])
        throw new Error("validateInput: tapLeafScript version mimatch");
      if (n[n.length - 1] & 1)
        throw new Error("validateInput: tapLeafScript version has parity bit!");
    }
  return e;
}), Qf = le(Zf(ao), (e) => {
  if (e.bip32Derivation)
    for (const [t] of e.bip32Derivation)
      Qi(t, ye.ecdsa);
  return e;
}), Tw = le(Zf(Yf), (e) => {
  if ((e.version || 0) === 0) {
    if (!e.unsignedTx)
      throw new Error("PSBTv0: missing unsignedTx");
    for (const n of e.unsignedTx.inputs)
      if (n.finalScriptSig && n.finalScriptSig.length)
        throw new Error("PSBTv0: input scriptSig found in unsignedTx");
  }
  return e;
}), tT = jt({
  magic: Kf(Wf(new Uint8Array([255])), "psbt"),
  global: Tw,
  inputs: ce("global/unsignedTx/inputs/length", Xf),
  outputs: ce(null, Qf)
}), eT = jt({
  magic: Kf(Wf(new Uint8Array([255])), "psbt"),
  global: Tw,
  inputs: ce("global/inputCount", Xf),
  outputs: ce("global/outputCount", Qf)
});
jt({
  magic: Kf(Wf(new Uint8Array([255])), "psbt"),
  items: ce(null, Br(ce(aw, Vx([Ux(Xe), vt(Hc)])), Fc.dict()))
});
function Au(e, t, n) {
  for (const r in n) {
    if (r === "unknown" || !t[r])
      continue;
    const { allowInc: i } = Il(t[r]);
    if (!i.includes(e))
      throw new Error(`PSBTv${e}: field ${r} is not allowed`);
  }
  for (const r in t) {
    const { reqInc: i } = Il(t[r]);
    if (i.includes(e) && n[r] === void 0)
      throw new Error(`PSBTv${e}: missing required field ${r}`);
  }
}
function Nh(e, t, n) {
  const r = {};
  for (const i in n) {
    const s = i;
    if (s !== "unknown") {
      if (!t[s])
        continue;
      const { allowInc: o, silentIgnore: a } = Il(t[s]);
      if (!o.includes(e)) {
        if (a)
          continue;
        throw new Error(`Failed to serialize in PSBTv${e}: ${s} but versions allows inclusion=${o}`);
      }
    }
    r[s] = n[s];
  }
  return r;
}
function Sw(e) {
  const t = e && e.global && e.global.version || 0;
  Au(t, Yf, e.global);
  for (const o of e.inputs)
    Au(t, Kc, o);
  for (const o of e.outputs)
    Au(t, ao, o);
  const n = t ? e.global.inputCount : e.global.unsignedTx.inputs.length;
  if (e.inputs.length < n)
    throw new Error("Not enough inputs");
  const r = e.inputs.slice(n);
  if (r.length > 1 || r.length && Object.keys(r[0]).length)
    throw new Error(`Unexpected inputs left in tx=${r}`);
  const i = t ? e.global.outputCount : e.global.unsignedTx.outputs.length;
  if (e.outputs.length < i)
    throw new Error("Not outputs inputs");
  const s = e.outputs.slice(i);
  if (s.length > 1 || s.length && Object.keys(s[0]).length)
    throw new Error(`Unexpected outputs left in tx=${s}`);
  return e;
}
function Ol(e, t, n, r, i) {
  const s = { ...n, ...t };
  for (const o in e) {
    const a = o, [c, u, l] = e[a], f = r && !r.includes(o);
    if (t[o] === void 0 && o in t) {
      if (f)
        throw new Error(`Cannot remove signed field=${o}`);
      delete s[o];
    } else if (u) {
      const h = n && n[o] ? n[o] : [];
      let g = t[a];
      if (g) {
        if (!Array.isArray(g))
          throw new Error(`keyMap(${o}): KV pairs should be [k, v][]`);
        g = g.map((y) => {
          if (y.length !== 2)
            throw new Error(`keyMap(${o}): KV pairs should be [k, v][]`);
          return [
            typeof y[0] == "string" ? u.decode(D.decode(y[0])) : y[0],
            typeof y[1] == "string" ? l.decode(D.decode(y[1])) : y[1]
          ];
        });
        const d = {}, p = (y, x, S) => {
          if (d[y] === void 0) {
            d[y] = [x, S];
            return;
          }
          const A = D.encode(l.encode(d[y][1])), R = D.encode(l.encode(S));
          if (A !== R)
            throw new Error(`keyMap(${a}): same key=${y} oldVal=${A} newVal=${R}`);
        };
        for (const [y, x] of h) {
          const S = D.encode(u.encode(y));
          p(S, y, x);
        }
        for (const [y, x] of g) {
          const S = D.encode(u.encode(y));
          if (x === void 0) {
            if (f)
              throw new Error(`Cannot remove signed field=${a}/${y}`);
            delete d[S];
          } else
            p(S, y, x);
        }
        s[a] = Object.values(d);
      }
    } else if (typeof s[o] == "string")
      s[o] = l.decode(D.decode(s[o]));
    else if (f && o in t && n && n[o] !== void 0 && !Pt(l.encode(t[o]), l.encode(n[o])))
      throw new Error(`Cannot change signed field=${o}`);
  }
  for (const o in s)
    if (!e[o]) {
      if (i && o === "unknown")
        continue;
      delete s[o];
    }
  return s;
}
const Lh = le(tT, Sw), Uh = le(eT, Sw), nT = {
  encode(e) {
    if (!(e.length !== 2 || e[0] !== 1 || !Et(e[1]) || D.encode(e[1]) !== "4e73"))
      return { type: "p2a", script: nt.encode(e) };
  },
  decode: (e) => {
    if (e.type === "p2a")
      return [1, D.decode("4e73")];
  }
};
function Ci(e, t) {
  try {
    return Qi(e, t), !0;
  } catch {
    return !1;
  }
}
const rT = {
  encode(e) {
    if (!(e.length !== 2 || !Et(e[0]) || !Ci(e[0], ye.ecdsa) || e[1] !== "CHECKSIG"))
      return { type: "pk", pubkey: e[0] };
  },
  decode: (e) => e.type === "pk" ? [e.pubkey, "CHECKSIG"] : void 0
}, iT = {
  encode(e) {
    if (!(e.length !== 5 || e[0] !== "DUP" || e[1] !== "HASH160" || !Et(e[2])) && !(e[3] !== "EQUALVERIFY" || e[4] !== "CHECKSIG"))
      return { type: "pkh", hash: e[2] };
  },
  decode: (e) => e.type === "pkh" ? ["DUP", "HASH160", e.hash, "EQUALVERIFY", "CHECKSIG"] : void 0
}, sT = {
  encode(e) {
    if (!(e.length !== 3 || e[0] !== "HASH160" || !Et(e[1]) || e[2] !== "EQUAL"))
      return { type: "sh", hash: e[1] };
  },
  decode: (e) => e.type === "sh" ? ["HASH160", e.hash, "EQUAL"] : void 0
}, oT = {
  encode(e) {
    if (!(e.length !== 2 || e[0] !== 0 || !Et(e[1])) && e[1].length === 32)
      return { type: "wsh", hash: e[1] };
  },
  decode: (e) => e.type === "wsh" ? [0, e.hash] : void 0
}, aT = {
  encode(e) {
    if (!(e.length !== 2 || e[0] !== 0 || !Et(e[1])) && e[1].length === 20)
      return { type: "wpkh", hash: e[1] };
  },
  decode: (e) => e.type === "wpkh" ? [0, e.hash] : void 0
}, cT = {
  encode(e) {
    const t = e.length - 1;
    if (e[t] !== "CHECKMULTISIG")
      return;
    const n = e[0], r = e[t - 1];
    if (typeof n != "number" || typeof r != "number")
      return;
    const i = e.slice(1, -2);
    if (r === i.length) {
      for (const s of i)
        if (!Et(s))
          return;
      return { type: "ms", m: n, pubkeys: i };
    }
  },
  // checkmultisig(n, ..pubkeys, m)
  decode: (e) => e.type === "ms" ? [e.m, ...e.pubkeys, e.pubkeys.length, "CHECKMULTISIG"] : void 0
}, uT = {
  encode(e) {
    if (!(e.length !== 2 || e[0] !== 1 || !Et(e[1])))
      return { type: "tr", pubkey: e[1] };
  },
  decode: (e) => e.type === "tr" ? [1, e.pubkey] : void 0
}, lT = {
  encode(e) {
    const t = e.length - 1;
    if (e[t] !== "CHECKSIG")
      return;
    const n = [];
    for (let r = 0; r < t; r++) {
      const i = e[r];
      if (r & 1) {
        if (i !== "CHECKSIGVERIFY" || r === t - 1)
          return;
        continue;
      }
      if (!Et(i))
        return;
      n.push(i);
    }
    return { type: "tr_ns", pubkeys: n };
  },
  decode: (e) => {
    if (e.type !== "tr_ns")
      return;
    const t = [];
    for (let n = 0; n < e.pubkeys.length - 1; n++)
      t.push(e.pubkeys[n], "CHECKSIGVERIFY");
    return t.push(e.pubkeys[e.pubkeys.length - 1], "CHECKSIG"), t;
  }
}, fT = {
  encode(e) {
    const t = e.length - 1;
    if (e[t] !== "NUMEQUAL" || e[1] !== "CHECKSIG")
      return;
    const n = [], r = Kx(e[t - 1]);
    if (typeof r == "number") {
      for (let i = 0; i < t - 1; i++) {
        const s = e[i];
        if (i & 1) {
          if (s !== (i === 1 ? "CHECKSIG" : "CHECKSIGADD"))
            throw new Error("OutScript.encode/tr_ms: wrong element");
          continue;
        }
        if (!Et(s))
          throw new Error("OutScript.encode/tr_ms: wrong key element");
        n.push(s);
      }
      return { type: "tr_ms", pubkeys: n, m: r };
    }
  },
  decode: (e) => {
    if (e.type !== "tr_ms")
      return;
    const t = [e.pubkeys[0], "CHECKSIG"];
    for (let n = 1; n < e.pubkeys.length; n++)
      t.push(e.pubkeys[n], "CHECKSIGADD");
    return t.push(e.m, "NUMEQUAL"), t;
  }
}, dT = {
  encode(e) {
    return { type: "unknown", script: nt.encode(e) };
  },
  decode: (e) => e.type === "unknown" ? nt.decode(e.script) : void 0
}, hT = [
  nT,
  rT,
  iT,
  sT,
  oT,
  aT,
  cT,
  uT,
  lT,
  fT,
  dT
], pT = Br(nt, Fc.match(hT)), Ot = le(pT, (e) => {
  if (e.type === "pk" && !Ci(e.pubkey, ye.ecdsa))
    throw new Error("OutScript/pk: wrong key");
  if ((e.type === "pkh" || e.type === "sh" || e.type === "wpkh") && (!Et(e.hash) || e.hash.length !== 20))
    throw new Error(`OutScript/${e.type}: wrong hash`);
  if (e.type === "wsh" && (!Et(e.hash) || e.hash.length !== 32))
    throw new Error("OutScript/wsh: wrong hash");
  if (e.type === "tr" && (!Et(e.pubkey) || !Ci(e.pubkey, ye.schnorr)))
    throw new Error("OutScript/tr: wrong taproot public key");
  if ((e.type === "ms" || e.type === "tr_ns" || e.type === "tr_ms") && !Array.isArray(e.pubkeys))
    throw new Error("OutScript/multisig: wrong pubkeys array");
  if (e.type === "ms") {
    const t = e.pubkeys.length;
    for (const n of e.pubkeys)
      if (!Ci(n, ye.ecdsa))
        throw new Error("OutScript/multisig: wrong pubkey");
    if (e.m <= 0 || t > 16 || e.m > t)
      throw new Error("OutScript/multisig: invalid params");
  }
  if (e.type === "tr_ns" || e.type === "tr_ms") {
    for (const t of e.pubkeys)
      if (!Ci(t, ye.schnorr))
        throw new Error(`OutScript/${e.type}: wrong pubkey`);
  }
  if (e.type === "tr_ms") {
    const t = e.pubkeys.length;
    if (e.m <= 0 || t > 999 || e.m > t)
      throw new Error("OutScript/tr_ms: invalid params");
  }
  return e;
});
function _h(e, t) {
  if (!Pt(e.hash, ge(t)))
    throw new Error("checkScript: wsh wrong witnessScript hash");
  const n = Ot.decode(t);
  if (n.type === "tr" || n.type === "tr_ns" || n.type === "tr_ms")
    throw new Error(`checkScript: P2${n.type} cannot be wrapped in P2SH`);
  if (n.type === "wpkh" || n.type === "sh")
    throw new Error(`checkScript: P2${n.type} cannot be wrapped in P2WSH`);
}
function vw(e, t, n) {
  if (e) {
    const r = Ot.decode(e);
    if (r.type === "tr_ns" || r.type === "tr_ms" || r.type === "ms" || r.type == "pk")
      throw new Error(`checkScript: non-wrapped ${r.type}`);
    if (r.type === "sh" && t) {
      if (!Pt(r.hash, yw(t)))
        throw new Error("checkScript: sh wrong redeemScript hash");
      const i = Ot.decode(t);
      if (i.type === "tr" || i.type === "tr_ns" || i.type === "tr_ms")
        throw new Error(`checkScript: P2${i.type} cannot be wrapped in P2SH`);
      if (i.type === "sh")
        throw new Error("checkScript: P2SH cannot be wrapped in P2SH");
    }
    r.type === "wsh" && n && _h(r, n);
  }
  if (t) {
    const r = Ot.decode(t);
    r.type === "wsh" && n && _h(r, n);
  }
}
function gT(e) {
  const t = {};
  for (const n of e) {
    const r = D.encode(n);
    if (t[r])
      throw new Error(`Multisig: non-uniq pubkey: ${e.map(D.encode)}`);
    t[r] = !0;
  }
}
function yT(e, t, n = !1, r) {
  const i = Ot.decode(e);
  if (i.type === "unknown" && n)
    return;
  if (!["tr_ns", "tr_ms"].includes(i.type))
    throw new Error(`P2TR: invalid leaf script=${i.type}`);
  const s = i;
  if (!n && s.pubkeys)
    for (const o of s.pubkeys) {
      if (Pt(o, qf))
        throw new Error("Unspendable taproot key in leaf script");
      if (Pt(o, t))
        throw new Error("Using P2TR with leaf script with same key as internal key is not supported");
    }
}
function kw(e) {
  const t = Array.from(e);
  for (; t.length >= 2; ) {
    t.sort((o, a) => (a.weight || 1) - (o.weight || 1));
    const r = t.pop(), i = t.pop(), s = (i?.weight || 1) + (r?.weight || 1);
    t.push({
      weight: s,
      // Unwrap children array
      // TODO: Very hard to remove any here
      childs: [i?.childs || i, r?.childs || r]
    });
  }
  const n = t[0];
  return n?.childs || n;
}
function Bl(e, t = []) {
  if (!e)
    throw new Error("taprootAddPath: empty tree");
  if (e.type === "leaf")
    return { ...e, path: t };
  if (e.type !== "branch")
    throw new Error(`taprootAddPath: wrong type=${e}`);
  return {
    ...e,
    path: t,
    // Left element has right hash in path and otherwise
    left: Bl(e.left, [e.right.hash, ...t]),
    right: Bl(e.right, [e.left.hash, ...t])
  };
}
function Cl(e) {
  if (!e)
    throw new Error("taprootAddPath: empty tree");
  if (e.type === "leaf")
    return [e];
  if (e.type !== "branch")
    throw new Error(`taprootWalkTree: wrong type=${e}`);
  return [...Cl(e.left), ...Cl(e.right)];
}
function Rl(e, t, n = !1, r) {
  if (!e)
    throw new Error("taprootHashTree: empty tree");
  if (Array.isArray(e) && e.length === 1 && (e = e[0]), !Array.isArray(e)) {
    const { leafVersion: c, script: u } = e;
    if (e.tapLeafScript || e.tapMerkleRoot && !Pt(e.tapMerkleRoot, At))
      throw new Error("P2TR: tapRoot leafScript cannot have tree");
    const l = typeof u == "string" ? D.decode(u) : u;
    if (!Et(l))
      throw new Error(`checkScript: wrong script type=${l}`);
    return yT(l, t, n), {
      type: "leaf",
      version: c,
      script: l,
      hash: Mi(l, c)
    };
  }
  if (e.length !== 2 && (e = kw(e)), e.length !== 2)
    throw new Error("hashTree: non binary tree!");
  const i = Rl(e[0], t, n), s = Rl(e[1], t, n);
  let [o, a] = [i.hash, s.hash];
  return Ha(a, o) === -1 && ([o, a] = [a, o]), { type: "branch", left: i, right: s, hash: zf("TapBranch", o, a) };
}
const co = 192, Mi = (e, t = co) => zf("TapLeaf", new Uint8Array([t]), Ke.encode(e));
function wT(e, t, n = Ji, r = !1, i) {
  if (!e && !t)
    throw new Error("p2tr: should have pubKey or scriptTree (or both)");
  const s = typeof e == "string" ? D.decode(e) : e || qf;
  if (!Ci(s, ye.schnorr))
    throw new Error("p2tr: non-schnorr pubkey");
  if (t) {
    let o = Bl(Rl(t, s, r));
    const a = o.hash, [c, u] = Al(s, a), l = Cl(o).map((f) => ({
      ...f,
      controlBlock: xn.encode({
        version: (f.version || co) + u,
        internalKey: s,
        merklePath: f.path
      })
    }));
    return {
      type: "tr",
      script: Ot.encode({ type: "tr", pubkey: c }),
      address: Cr(n).encode({ type: "tr", pubkey: c }),
      // For tests
      tweakedPubkey: c,
      // PSBT stuff
      tapInternalKey: s,
      leaves: l,
      tapLeafScript: l.map((f) => [
        xn.decode(f.controlBlock),
        mr(f.script, new Uint8Array([f.version || co]))
      ]),
      tapMerkleRoot: a
    };
  } else {
    const o = Al(s, At)[0];
    return {
      type: "tr",
      script: Ot.encode({ type: "tr", pubkey: o }),
      address: Cr(n).encode({ type: "tr", pubkey: o }),
      // For tests
      tweakedPubkey: o,
      // PSBT stuff
      tapInternalKey: s
    };
  }
}
function mT(e, t, n = !1) {
  return n || gT(t), {
    type: "tr_ms",
    script: Ot.encode({ type: "tr_ms", pubkeys: t, m: e })
  };
}
const Aw = bx(ge);
function $w(e, t) {
  if (t.length < 2 || t.length > 40)
    throw new Error("Witness: invalid length");
  if (e > 16)
    throw new Error("Witness: invalid version");
  if (e === 0 && !(t.length === 20 || t.length === 32))
    throw new Error("Witness: invalid length for version");
}
function $u(e, t, n = Ji) {
  $w(e, t);
  const r = e === 0 ? vl : Oi;
  return r.encode(n.bech32, [e].concat(r.toWords(t)));
}
function Dh(e, t) {
  return Aw.encode(mr(Uint8Array.from(t), e));
}
function Cr(e = Ji) {
  return {
    encode(t) {
      const { type: n } = t;
      if (n === "wpkh")
        return $u(0, t.hash, e);
      if (n === "wsh")
        return $u(0, t.hash, e);
      if (n === "tr")
        return $u(1, t.pubkey, e);
      if (n === "pkh")
        return Dh(t.hash, [e.pubKeyHash]);
      if (n === "sh")
        return Dh(t.hash, [e.scriptHash]);
      throw new Error(`Unknown address type=${n}`);
    },
    decode(t) {
      if (t.length < 14 || t.length > 74)
        throw new Error("Invalid address length");
      if (e.bech32 && t.toLowerCase().startsWith(`${e.bech32}1`)) {
        let r;
        try {
          if (r = vl.decode(t), r.words[0] !== 0)
            throw new Error(`bech32: wrong version=${r.words[0]}`);
        } catch {
          if (r = Oi.decode(t), r.words[0] === 0)
            throw new Error(`bech32m: wrong version=${r.words[0]}`);
        }
        if (r.prefix !== e.bech32)
          throw new Error(`wrong bech32 prefix=${r.prefix}`);
        const [i, ...s] = r.words, o = vl.fromWords(s);
        if ($w(i, o), i === 0 && o.length === 32)
          return { type: "wsh", hash: o };
        if (i === 0 && o.length === 20)
          return { type: "wpkh", hash: o };
        if (i === 1 && o.length === 32)
          return { type: "tr", pubkey: o };
        throw new Error("Unknown witness program");
      }
      const n = Aw.decode(t);
      if (n.length !== 21)
        throw new Error("Invalid base58 address");
      if (n[0] === e.pubKeyHash)
        return { type: "pkh", hash: n.slice(1) };
      if (n[0] === e.scriptHash)
        return {
          type: "sh",
          hash: n.slice(1)
        };
      throw new Error(`Invalid address prefix=${n[0]}`);
    }
  };
}
const No = new Uint8Array(32), bT = {
  amount: 0xffffffffffffffffn,
  script: At
}, ET = (e) => Math.ceil(e / 4), xT = 8, TT = 2, qr = 0, Jf = 4294967295;
Fc.decimal(xT);
const Ws = (e, t) => e === void 0 ? t : e;
function ja(e) {
  if (Array.isArray(e))
    return e.map((t) => ja(t));
  if (Et(e))
    return Uint8Array.from(e);
  if (["number", "bigint", "boolean", "string", "undefined"].includes(typeof e))
    return e;
  if (e === null)
    return e;
  if (typeof e == "object")
    return Object.fromEntries(Object.entries(e).map(([t, n]) => [t, ja(n)]));
  throw new Error(`cloneDeep: unknown type=${e} (${typeof e})`);
}
const at = {
  DEFAULT: 0,
  ALL: 1,
  NONE: 2,
  SINGLE: 3,
  ANYONECANPAY: 128
}, Rr = {
  DEFAULT: at.DEFAULT,
  ALL: at.ALL,
  NONE: at.NONE,
  SINGLE: at.SINGLE,
  DEFAULT_ANYONECANPAY: at.DEFAULT | at.ANYONECANPAY,
  ALL_ANYONECANPAY: at.ALL | at.ANYONECANPAY,
  NONE_ANYONECANPAY: at.NONE | at.ANYONECANPAY,
  SINGLE_ANYONECANPAY: at.SINGLE | at.ANYONECANPAY
}, ST = bw(Rr);
function vT(e, t, n, r = At) {
  return Pt(n, t) && (e = Hx(e, r), t = ww(e)), { privKey: e, pubKey: t };
}
function Gr(e) {
  if (e.script === void 0 || e.amount === void 0)
    throw new Error("Transaction/output: script and amount required");
  return { script: e.script, amount: e.amount };
}
function As(e) {
  if (e.txid === void 0 || e.index === void 0)
    throw new Error("Transaction/input: txid and index required");
  return {
    txid: e.txid,
    index: e.index,
    sequence: Ws(e.sequence, Jf),
    finalScriptSig: Ws(e.finalScriptSig, At)
  };
}
function Iu(e) {
  for (const t in e) {
    const n = t;
    Xx.includes(n) || delete e[n];
  }
}
const Ou = jt({ txid: vt(32, !0), index: dt });
function kT(e) {
  if (typeof e != "number" || typeof ST[e] != "string")
    throw new Error(`Invalid SigHash=${e}`);
  return e;
}
function Vh(e) {
  const t = e & 31;
  return {
    isAny: !!(e & at.ANYONECANPAY),
    isNone: t === at.NONE,
    isSingle: t === at.SINGLE
  };
}
function AT(e) {
  if (e !== void 0 && {}.toString.call(e) !== "[object Object]")
    throw new Error(`Wrong object type for transaction options: ${e}`);
  const t = {
    ...e,
    // Defaults
    version: Ws(e.version, TT),
    lockTime: Ws(e.lockTime, 0),
    PSBTVersion: Ws(e.PSBTVersion, 0)
  };
  if (typeof t.allowUnknowInput < "u" && (e.allowUnknownInputs = t.allowUnknowInput), typeof t.allowUnknowOutput < "u" && (e.allowUnknownOutputs = t.allowUnknowOutput), typeof t.lockTime != "number")
    throw new Error("Transaction lock time should be number");
  if (dt.encode(t.lockTime), t.PSBTVersion !== 0 && t.PSBTVersion !== 2)
    throw new Error(`Unknown PSBT version ${t.PSBTVersion}`);
  for (const n of [
    "allowUnknownVersion",
    "allowUnknownOutputs",
    "allowUnknownInputs",
    "disableScriptCheck",
    "bip174jsCompat",
    "allowLegacyWitnessUtxo",
    "lowR"
  ]) {
    const r = t[n];
    if (r !== void 0 && typeof r != "boolean")
      throw new Error(`Transation options wrong type: ${n}=${r} (${typeof r})`);
  }
  if (t.allowUnknownVersion ? typeof t.version == "number" : ![-1, 0, 1, 2, 3].includes(t.version))
    throw new Error(`Unknown version: ${t.version}`);
  if (t.customScripts !== void 0) {
    const n = t.customScripts;
    if (!Array.isArray(n))
      throw new Error(`wrong custom scripts type (expected array): customScripts=${n} (${typeof n})`);
    for (const r of n) {
      if (typeof r.encode != "function" || typeof r.decode != "function")
        throw new Error(`wrong script=${r} (${typeof r})`);
      if (r.finalizeTaproot !== void 0 && typeof r.finalizeTaproot != "function")
        throw new Error(`wrong script=${r} (${typeof r})`);
    }
  }
  return Object.freeze(t);
}
function Mh(e) {
  if (e.nonWitnessUtxo && e.index !== void 0) {
    const t = e.nonWitnessUtxo.outputs.length - 1;
    if (e.index > t)
      throw new Error(`validateInput: index(${e.index}) not in nonWitnessUtxo`);
    const n = e.nonWitnessUtxo.outputs[e.index];
    if (e.witnessUtxo && (!Pt(e.witnessUtxo.script, n.script) || e.witnessUtxo.amount !== n.amount))
      throw new Error("validateInput: witnessUtxo different from nonWitnessUtxo");
    if (e.txid) {
      if (e.nonWitnessUtxo.outputs.length - 1 < e.index)
        throw new Error("nonWitnessUtxo: incorect output index");
      const i = ze.fromRaw(Vi.encode(e.nonWitnessUtxo), {
        allowUnknownOutputs: !0,
        disableScriptCheck: !0,
        allowUnknownInputs: !0
      }), s = D.encode(e.txid);
      if (i.isFinal && i.id !== s)
        throw new Error(`nonWitnessUtxo: wrong txid, exp=${s} got=${i.id}`);
    }
  }
  return e;
}
function ca(e) {
  if (e.nonWitnessUtxo) {
    if (e.index === void 0)
      throw new Error("Unknown input index");
    return e.nonWitnessUtxo.outputs[e.index];
  } else {
    if (e.witnessUtxo)
      return e.witnessUtxo;
    throw new Error("Cannot find previous output info");
  }
}
function Fh(e, t, n, r = !1, i = !1) {
  let { nonWitnessUtxo: s, txid: o } = e;
  typeof s == "string" && (s = D.decode(s)), Et(s) && (s = Vi.decode(s)), !("nonWitnessUtxo" in e) && s === void 0 && (s = t?.nonWitnessUtxo), typeof o == "string" && (o = D.decode(o)), o === void 0 && (o = t?.txid);
  let a = { ...t, ...e, nonWitnessUtxo: s, txid: o };
  !("nonWitnessUtxo" in e) && a.nonWitnessUtxo === void 0 && delete a.nonWitnessUtxo, a.sequence === void 0 && (a.sequence = Jf), a.tapMerkleRoot === null && delete a.tapMerkleRoot, a = Ol(Kc, a, t, n, i), Xf.encode(a);
  let c;
  return a.nonWitnessUtxo && a.index !== void 0 ? c = a.nonWitnessUtxo.outputs[a.index] : a.witnessUtxo && (c = a.witnessUtxo), c && !r && vw(c && c.script, a.redeemScript, a.witnessScript), a;
}
function Hh(e, t = !1) {
  let n = "legacy", r = at.ALL;
  const i = ca(e), s = Ot.decode(i.script);
  let o = s.type, a = s;
  const c = [s];
  if (s.type === "tr")
    return r = at.DEFAULT, {
      txType: "taproot",
      type: "tr",
      last: s,
      lastScript: i.script,
      defaultSighash: r,
      sighash: e.sighashType || r
    };
  {
    if ((s.type === "wpkh" || s.type === "wsh") && (n = "segwit"), s.type === "sh") {
      if (!e.redeemScript)
        throw new Error("inputType: sh without redeemScript");
      let h = Ot.decode(e.redeemScript);
      (h.type === "wpkh" || h.type === "wsh") && (n = "segwit"), c.push(h), a = h, o += `-${h.type}`;
    }
    if (a.type === "wsh") {
      if (!e.witnessScript)
        throw new Error("inputType: wsh without witnessScript");
      let h = Ot.decode(e.witnessScript);
      h.type === "wsh" && (n = "segwit"), c.push(h), a = h, o += `-${h.type}`;
    }
    const u = c[c.length - 1];
    if (u.type === "sh" || u.type === "wsh")
      throw new Error("inputType: sh/wsh cannot be terminal type");
    const l = Ot.encode(u), f = {
      type: o,
      txType: n,
      last: u,
      lastScript: l,
      defaultSighash: r,
      sighash: e.sighashType || r
    };
    if (n === "legacy" && !t && !e.nonWitnessUtxo)
      throw new Error("Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure");
    return f;
  }
}
let ze = class ua {
  global = {};
  inputs = [];
  // use getInput()
  outputs = [];
  // use getOutput()
  opts;
  constructor(t = {}) {
    const n = this.opts = AT(t);
    n.lockTime !== qr && (this.global.fallbackLocktime = n.lockTime), this.global.txVersion = n.version;
  }
  // Import
  static fromRaw(t, n = {}) {
    const r = Vi.decode(t), i = new ua({ ...n, version: r.version, lockTime: r.lockTime });
    for (const s of r.outputs)
      i.addOutput(s);
    if (i.outputs = r.outputs, i.inputs = r.inputs, r.witnesses)
      for (let s = 0; s < r.witnesses.length; s++)
        i.inputs[s].finalScriptWitness = r.witnesses[s];
    return i;
  }
  // PSBT
  static fromPSBT(t, n = {}) {
    let r;
    try {
      r = Lh.decode(t);
    } catch (f) {
      try {
        r = Uh.decode(t);
      } catch {
        throw f;
      }
    }
    const i = r.global.version || 0;
    if (i !== 0 && i !== 2)
      throw new Error(`Wrong PSBT version=${i}`);
    const s = r.global.unsignedTx, o = i === 0 ? s?.version : r.global.txVersion, a = i === 0 ? s?.lockTime : r.global.fallbackLocktime, c = new ua({ ...n, version: o, lockTime: a, PSBTVersion: i }), u = i === 0 ? s?.inputs.length : r.global.inputCount;
    c.inputs = r.inputs.slice(0, u).map((f, h) => Mh({
      finalScriptSig: At,
      ...r.global.unsignedTx?.inputs[h],
      ...f
    }));
    const l = i === 0 ? s?.outputs.length : r.global.outputCount;
    return c.outputs = r.outputs.slice(0, l).map((f, h) => ({
      ...f,
      ...r.global.unsignedTx?.outputs[h]
    })), c.global = { ...r.global, txVersion: o }, a !== qr && (c.global.fallbackLocktime = a), c;
  }
  toPSBT(t = this.opts.PSBTVersion) {
    if (t !== 0 && t !== 2)
      throw new Error(`Wrong PSBT version=${t}`);
    const n = this.inputs.map((s) => Mh(Nh(t, Kc, s)));
    for (const s of n)
      s.partialSig && !s.partialSig.length && delete s.partialSig, s.finalScriptSig && !s.finalScriptSig.length && delete s.finalScriptSig, s.finalScriptWitness && !s.finalScriptWitness.length && delete s.finalScriptWitness;
    const r = this.outputs.map((s) => Nh(t, ao, s)), i = { ...this.global };
    return t === 0 ? (i.unsignedTx = Vs.decode(Vs.encode({
      version: this.version,
      lockTime: this.lockTime,
      inputs: this.inputs.map(As).map((s) => ({
        ...s,
        finalScriptSig: At
      })),
      outputs: this.outputs.map(Gr)
    })), delete i.fallbackLocktime, delete i.txVersion) : (i.version = t, i.txVersion = this.version, i.inputCount = this.inputs.length, i.outputCount = this.outputs.length, i.fallbackLocktime && i.fallbackLocktime === qr && delete i.fallbackLocktime), this.opts.bip174jsCompat && (n.length || n.push({}), r.length || r.push({})), (t === 0 ? Lh : Uh).encode({
      global: i,
      inputs: n,
      outputs: r
    });
  }
  // BIP370 lockTime (https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#determining-lock-time)
  get lockTime() {
    let t = qr, n = 0, r = qr, i = 0;
    for (const s of this.inputs)
      s.requiredHeightLocktime && (t = Math.max(t, s.requiredHeightLocktime), n++), s.requiredTimeLocktime && (r = Math.max(r, s.requiredTimeLocktime), i++);
    return n && n >= i ? t : r !== qr ? r : this.global.fallbackLocktime || qr;
  }
  get version() {
    if (this.global.txVersion === void 0)
      throw new Error("No global.txVersion");
    return this.global.txVersion;
  }
  inputStatus(t) {
    this.checkInputIdx(t);
    const n = this.inputs[t];
    return n.finalScriptSig && n.finalScriptSig.length || n.finalScriptWitness && n.finalScriptWitness.length ? "finalized" : n.tapKeySig || n.tapScriptSig && n.tapScriptSig.length || n.partialSig && n.partialSig.length ? "signed" : "unsigned";
  }
  // Cannot replace unpackSighash, tests rely on very generic implemenetation with signing inputs outside of range
  // We will lose some vectors -> smaller test coverage of preimages (very important!)
  inputSighash(t) {
    this.checkInputIdx(t);
    const n = this.inputs[t].sighashType, r = n === void 0 ? at.DEFAULT : n, i = r === at.DEFAULT ? at.ALL : r & 3;
    return { sigInputs: r & at.ANYONECANPAY, sigOutputs: i };
  }
  // Very nice for debug purposes, but slow. If there is too much inputs/outputs to add, will be quadratic.
  // Some cache will be nice, but there chance to have bugs with cache invalidation
  signStatus() {
    let t = !0, n = !0, r = [], i = [];
    for (let s = 0; s < this.inputs.length; s++) {
      if (this.inputStatus(s) === "unsigned")
        continue;
      const { sigInputs: a, sigOutputs: c } = this.inputSighash(s);
      if (a === at.ANYONECANPAY ? r.push(s) : t = !1, c === at.ALL)
        n = !1;
      else if (c === at.SINGLE)
        i.push(s);
      else if (c !== at.NONE) throw new Error(`Wrong signature hash output type: ${c}`);
    }
    return { addInput: t, addOutput: n, inputs: r, outputs: i };
  }
  get isFinal() {
    for (let t = 0; t < this.inputs.length; t++)
      if (this.inputStatus(t) !== "finalized")
        return !1;
    return !0;
  }
  // Info utils
  get hasWitnesses() {
    let t = !1;
    for (const n of this.inputs)
      n.finalScriptWitness && n.finalScriptWitness.length && (t = !0);
    return t;
  }
  // https://en.bitcoin.it/wiki/Weight_units
  get weight() {
    if (!this.isFinal)
      throw new Error("Transaction is not finalized");
    let t = 32;
    const n = this.outputs.map(Gr);
    t += 4 * Xe.encode(this.outputs.length).length;
    for (const r of n)
      t += 32 + 4 * Ke.encode(r.script).length;
    this.hasWitnesses && (t += 2), t += 4 * Xe.encode(this.inputs.length).length;
    for (const r of this.inputs)
      t += 160 + 4 * Ke.encode(r.finalScriptSig || At).length, this.hasWitnesses && r.finalScriptWitness && (t += oo.encode(r.finalScriptWitness).length);
    return t;
  }
  get vsize() {
    return ET(this.weight);
  }
  toBytes(t = !1, n = !1) {
    return Vi.encode({
      version: this.version,
      lockTime: this.lockTime,
      inputs: this.inputs.map(As).map((r) => ({
        ...r,
        finalScriptSig: t && r.finalScriptSig || At
      })),
      outputs: this.outputs.map(Gr),
      witnesses: this.inputs.map((r) => r.finalScriptWitness || []),
      segwitFlag: n && this.hasWitnesses
    });
  }
  get unsignedTx() {
    return this.toBytes(!1, !1);
  }
  get hex() {
    return D.encode(this.toBytes(!0, this.hasWitnesses));
  }
  get hash() {
    return D.encode(ir(this.toBytes(!0)));
  }
  get id() {
    return D.encode(ir(this.toBytes(!0)).reverse());
  }
  // Input stuff
  checkInputIdx(t) {
    if (!Number.isSafeInteger(t) || 0 > t || t >= this.inputs.length)
      throw new Error(`Wrong input index=${t}`);
  }
  getInput(t) {
    return this.checkInputIdx(t), ja(this.inputs[t]);
  }
  get inputsLength() {
    return this.inputs.length;
  }
  // Modification
  addInput(t, n = !1) {
    if (!n && !this.signStatus().addInput)
      throw new Error("Tx has signed inputs, cannot add new one");
    return this.inputs.push(Fh(t, void 0, void 0, this.opts.disableScriptCheck)), this.inputs.length - 1;
  }
  updateInput(t, n, r = !1) {
    this.checkInputIdx(t);
    let i;
    if (!r) {
      const s = this.signStatus();
      (!s.addInput || s.inputs.includes(t)) && (i = Qx);
    }
    this.inputs[t] = Fh(n, this.inputs[t], i, this.opts.disableScriptCheck, this.opts.allowUnknown);
  }
  // Output stuff
  checkOutputIdx(t) {
    if (!Number.isSafeInteger(t) || 0 > t || t >= this.outputs.length)
      throw new Error(`Wrong output index=${t}`);
  }
  getOutput(t) {
    return this.checkOutputIdx(t), ja(this.outputs[t]);
  }
  getOutputAddress(t, n = Ji) {
    const r = this.getOutput(t);
    if (r.script)
      return Cr(n).encode(Ot.decode(r.script));
  }
  get outputsLength() {
    return this.outputs.length;
  }
  normalizeOutput(t, n, r) {
    let { amount: i, script: s } = t;
    if (i === void 0 && (i = n?.amount), typeof i != "bigint")
      throw new Error(`Wrong amount type, should be of type bigint in sats, but got ${i} of type ${typeof i}`);
    typeof s == "string" && (s = D.decode(s)), s === void 0 && (s = n?.script);
    let o = { ...n, ...t, amount: i, script: s };
    if (o.amount === void 0 && delete o.amount, o = Ol(ao, o, n, r, this.opts.allowUnknown), Qf.encode(o), o.script && !this.opts.allowUnknownOutputs && Ot.decode(o.script).type === "unknown")
      throw new Error("Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure");
    return this.opts.disableScriptCheck || vw(o.script, o.redeemScript, o.witnessScript), o;
  }
  addOutput(t, n = !1) {
    if (!n && !this.signStatus().addOutput)
      throw new Error("Tx has signed outputs, cannot add new one");
    return this.outputs.push(this.normalizeOutput(t)), this.outputs.length - 1;
  }
  updateOutput(t, n, r = !1) {
    this.checkOutputIdx(t);
    let i;
    if (!r) {
      const s = this.signStatus();
      (!s.addOutput || s.outputs.includes(t)) && (i = Jx);
    }
    this.outputs[t] = this.normalizeOutput(n, this.outputs[t], i);
  }
  addOutputAddress(t, n, r = Ji) {
    return this.addOutput({ script: Ot.encode(Cr(r).decode(t)), amount: n });
  }
  // Utils
  get fee() {
    let t = 0n;
    for (const r of this.inputs) {
      const i = ca(r);
      if (!i)
        throw new Error("Empty input amount");
      t += i.amount;
    }
    const n = this.outputs.map(Gr);
    for (const r of n)
      t -= r.amount;
    return t;
  }
  // Signing
  // Based on https://github.com/bitcoin/bitcoin/blob/5871b5b5ab57a0caf9b7514eb162c491c83281d5/test/functional/test_framework/script.py#L624
  // There is optimization opportunity to re-use hashes for multiple inputs for witness v0/v1,
  // but we are trying to be less complicated for audit purpose for now.
  preimageLegacy(t, n, r) {
    const { isAny: i, isNone: s, isSingle: o } = Vh(r);
    if (t < 0 || !Number.isSafeInteger(t))
      throw new Error(`Invalid input idx=${t}`);
    if (o && t >= this.outputs.length || t >= this.inputs.length)
      return hw.encode(1n);
    n = nt.encode(nt.decode(n).filter((l) => l !== "CODESEPARATOR"));
    let a = this.inputs.map(As).map((l, f) => ({
      ...l,
      finalScriptSig: f === t ? n : At
    }));
    i ? a = [a[t]] : (s || o) && (a = a.map((l, f) => ({
      ...l,
      sequence: f === t ? l.sequence : 0
    })));
    let c = this.outputs.map(Gr);
    s ? c = [] : o && (c = c.slice(0, t).fill(bT).concat([c[t]]));
    const u = Vi.encode({
      lockTime: this.lockTime,
      version: this.version,
      segwitFlag: !1,
      inputs: a,
      outputs: c
    });
    return ir(u, Bi.encode(r));
  }
  preimageWitnessV0(t, n, r, i) {
    const { isAny: s, isNone: o, isSingle: a } = Vh(r);
    let c = No, u = No, l = No;
    const f = this.inputs.map(As), h = this.outputs.map(Gr);
    s || (c = ir(...f.map(Ou.encode))), !s && !a && !o && (u = ir(...f.map((d) => dt.encode(d.sequence)))), !a && !o ? l = ir(...h.map(ri.encode)) : a && t < h.length && (l = ir(ri.encode(h[t])));
    const g = f[t];
    return ir(Bi.encode(this.version), c, u, vt(32, !0).encode(g.txid), dt.encode(g.index), Ke.encode(n), aa.encode(i), dt.encode(g.sequence), l, dt.encode(this.lockTime), dt.encode(r));
  }
  preimageWitnessV1(t, n, r, i, s = -1, o, a = 192, c) {
    if (!Array.isArray(i) || this.inputs.length !== i.length)
      throw new Error(`Invalid amounts array=${i}`);
    if (!Array.isArray(n) || this.inputs.length !== n.length)
      throw new Error(`Invalid prevOutScript array=${n}`);
    const u = [
      Tr.encode(0),
      Tr.encode(r),
      // U8 sigHash
      Bi.encode(this.version),
      dt.encode(this.lockTime)
    ], l = r === at.DEFAULT ? at.ALL : r & 3, f = r & at.ANYONECANPAY, h = this.inputs.map(As), g = this.outputs.map(Gr);
    f !== at.ANYONECANPAY && u.push(...[
      h.map(Ou.encode),
      i.map(aa.encode),
      n.map(Ke.encode),
      h.map((p) => dt.encode(p.sequence))
    ].map((p) => ge(mr(...p)))), l === at.ALL && u.push(ge(mr(...g.map(ri.encode))));
    const d = (c ? 1 : 0) | (o ? 2 : 0);
    if (u.push(new Uint8Array([d])), f === at.ANYONECANPAY) {
      const p = h[t];
      u.push(Ou.encode(p), aa.encode(i[t]), Ke.encode(n[t]), dt.encode(p.sequence));
    } else
      u.push(dt.encode(t));
    return d & 1 && u.push(ge(Ke.encode(c || At))), l === at.SINGLE && u.push(t < g.length ? ge(ri.encode(g[t])) : No), o && u.push(Mi(o, a), Tr.encode(0), Bi.encode(s)), zf("TapSighash", ...u);
  }
  // Signer can be privateKey OR instance of bip32 HD stuff
  signIdx(t, n, r, i) {
    this.checkInputIdx(n);
    const s = this.inputs[n], o = Hh(s, this.opts.allowLegacyWitnessUtxo);
    if (!Et(t)) {
      if (!s.bip32Derivation || !s.bip32Derivation.length)
        throw new Error("bip32Derivation: empty");
      const l = s.bip32Derivation.filter((h) => h[1].fingerprint == t.fingerprint).map(([h, { path: g }]) => {
        let d = t;
        for (const p of g)
          d = d.deriveChild(p);
        if (!Pt(d.publicKey, h))
          throw new Error("bip32Derivation: wrong pubKey");
        if (!d.privateKey)
          throw new Error("bip32Derivation: no privateKey");
        return d;
      });
      if (!l.length)
        throw new Error(`bip32Derivation: no items with fingerprint=${t.fingerprint}`);
      let f = !1;
      for (const h of l)
        this.signIdx(h.privateKey, n) && (f = !0);
      return f;
    }
    r ? r.forEach(kT) : r = [o.defaultSighash];
    const a = o.sighash;
    if (!r.includes(a))
      throw new Error(`Input with not allowed sigHash=${a}. Allowed: ${r.join(", ")}`);
    const { sigOutputs: c } = this.inputSighash(n);
    if (c === at.SINGLE && n >= this.outputs.length)
      throw new Error(`Input with sighash SINGLE, but there is no output with corresponding index=${n}`);
    const u = ca(s);
    if (o.txType === "taproot") {
      const l = this.inputs.map(ca), f = l.map((y) => y.script), h = l.map((y) => y.amount);
      let g = !1, d = ww(t), p = s.tapMerkleRoot || At;
      if (s.tapInternalKey) {
        const { pubKey: y, privKey: x } = vT(t, d, s.tapInternalKey, p), [S] = Al(s.tapInternalKey, p);
        if (Pt(S, y)) {
          const A = this.preimageWitnessV1(n, f, a, h), R = mr(Oh(A, x, i), a !== at.DEFAULT ? new Uint8Array([a]) : At);
          this.updateInput(n, { tapKeySig: R }, !0), g = !0;
        }
      }
      if (s.tapLeafScript) {
        s.tapScriptSig = s.tapScriptSig || [];
        for (const [y, x] of s.tapLeafScript) {
          const S = x.subarray(0, -1), A = nt.decode(S), R = x[x.length - 1], N = Mi(S, R);
          if (A.findIndex((U) => Et(U) && Pt(U, d)) === -1)
            continue;
          const w = this.preimageWitnessV1(n, f, a, h, void 0, S, R), K = mr(Oh(w, t, i), a !== at.DEFAULT ? new Uint8Array([a]) : At);
          this.updateInput(n, { tapScriptSig: [[{ pubKey: d, leafHash: N }, K]] }, !0), g = !0;
        }
      }
      if (!g)
        throw new Error("No taproot scripts signed");
      return !0;
    } else {
      const l = Mx(t);
      let f = !1;
      const h = yw(l);
      for (const p of nt.decode(o.lastScript))
        Et(p) && (Pt(p, l) || Pt(p, h)) && (f = !0);
      if (!f)
        throw new Error(`Input script doesn't have pubKey: ${o.lastScript}`);
      let g;
      if (o.txType === "legacy")
        g = this.preimageLegacy(n, o.lastScript, a);
      else if (o.txType === "segwit") {
        let p = o.lastScript;
        o.last.type === "wpkh" && (p = Ot.encode({ type: "pkh", hash: o.last.hash })), g = this.preimageWitnessV0(n, p, a, u.amount);
      } else
        throw new Error(`Transaction/sign: unknown tx type: ${o.txType}`);
      const d = Fx(g, t, this.opts.lowR);
      this.updateInput(n, {
        partialSig: [[l, mr(d, new Uint8Array([a]))]]
      }, !0);
    }
    return !0;
  }
  // This is bad API. Will work if user creates and signs tx, but if
  // there is some complex workflow with exchanging PSBT and signing them,
  // then it is better to validate which output user signs. How could a better API look like?
  // Example: user adds input, sends to another party, then signs received input (mixer etc),
  // another user can add different input for same key and user will sign it.
  // Even worse: another user can add bip32 derivation, and spend money from different address.
  // Better api: signIdx
  sign(t, n, r) {
    let i = 0;
    for (let s = 0; s < this.inputs.length; s++)
      try {
        this.signIdx(t, s, n, r) && i++;
      } catch {
      }
    if (!i)
      throw new Error("No inputs signed");
    return i;
  }
  finalizeIdx(t) {
    if (this.checkInputIdx(t), this.fee < 0n)
      throw new Error("Outputs spends more than inputs amount");
    const n = this.inputs[t], r = Hh(n, this.opts.allowLegacyWitnessUtxo);
    if (r.txType === "taproot") {
      if (n.tapKeySig)
        n.finalScriptWitness = [n.tapKeySig];
      else if (n.tapLeafScript && n.tapScriptSig) {
        const c = n.tapLeafScript.sort((u, l) => xn.encode(u[0]).length - xn.encode(l[0]).length);
        for (const [u, l] of c) {
          const f = l.slice(0, -1), h = l[l.length - 1], g = Ot.decode(f), d = Mi(f, h), p = n.tapScriptSig.filter((x) => Pt(x[0].leafHash, d));
          let y = [];
          if (g.type === "tr_ms") {
            const x = g.m, S = g.pubkeys;
            let A = 0;
            for (const R of S) {
              const N = p.findIndex((F) => Pt(F[0].pubKey, R));
              if (A === x || N === -1) {
                y.push(At);
                continue;
              }
              y.push(p[N][1]), A++;
            }
            if (A !== x)
              continue;
          } else if (g.type === "tr_ns") {
            for (const x of g.pubkeys) {
              const S = p.findIndex((A) => Pt(A[0].pubKey, x));
              S !== -1 && y.push(p[S][1]);
            }
            if (y.length !== g.pubkeys.length)
              continue;
          } else if (g.type === "unknown" && this.opts.allowUnknownInputs) {
            const x = nt.decode(f);
            if (y = p.map(([{ pubKey: S }, A]) => {
              const R = x.findIndex((N) => Et(N) && Pt(N, S));
              if (R === -1)
                throw new Error("finalize/taproot: cannot find position of pubkey in script");
              return { signature: A, pos: R };
            }).sort((S, A) => S.pos - A.pos).map((S) => S.signature), !y.length)
              continue;
          } else {
            const x = this.opts.customScripts;
            if (x)
              for (const S of x) {
                if (!S.finalizeTaproot)
                  continue;
                const A = nt.decode(f), R = S.encode(A);
                if (R === void 0)
                  continue;
                const N = S.finalizeTaproot(f, R, p);
                if (N) {
                  n.finalScriptWitness = N.concat(xn.encode(u)), n.finalScriptSig = At, Iu(n);
                  return;
                }
              }
            throw new Error("Finalize: Unknown tapLeafScript");
          }
          n.finalScriptWitness = y.reverse().concat([f, xn.encode(u)]);
          break;
        }
        if (!n.finalScriptWitness)
          throw new Error("finalize/taproot: empty witness");
      } else
        throw new Error("finalize/taproot: unknown input");
      n.finalScriptSig = At, Iu(n);
      return;
    }
    if (!n.partialSig || !n.partialSig.length)
      throw new Error("Not enough partial sign");
    let i = At, s = [];
    if (r.last.type === "ms") {
      const c = r.last.m, u = r.last.pubkeys;
      let l = [];
      for (const f of u) {
        const h = n.partialSig.find((g) => Pt(f, g[0]));
        h && l.push(h[1]);
      }
      if (l = l.slice(0, c), l.length !== c)
        throw new Error(`Multisig: wrong signatures count, m=${c} n=${u.length} signatures=${l.length}`);
      i = nt.encode([0, ...l]);
    } else if (r.last.type === "pk")
      i = nt.encode([n.partialSig[0][1]]);
    else if (r.last.type === "pkh")
      i = nt.encode([n.partialSig[0][1], n.partialSig[0][0]]);
    else if (r.last.type === "wpkh")
      i = At, s = [n.partialSig[0][1], n.partialSig[0][0]];
    else if (r.last.type === "unknown" && !this.opts.allowUnknownInputs)
      throw new Error("Unknown inputs not allowed");
    let o, a;
    if (r.type.includes("wsh-") && (i.length && r.lastScript.length && (s = nt.decode(i).map((c) => {
      if (c === 0)
        return At;
      if (Et(c))
        return c;
      throw new Error(`Wrong witness op=${c}`);
    })), s = s.concat(r.lastScript)), r.txType === "segwit" && (a = s), r.type.startsWith("sh-wsh-") ? o = nt.encode([nt.encode([0, ge(r.lastScript)])]) : r.type.startsWith("sh-") ? o = nt.encode([...nt.decode(i), r.lastScript]) : r.type.startsWith("wsh-") || r.txType !== "segwit" && (o = i), !o && !a)
      throw new Error("Unknown error finalizing input");
    o && (n.finalScriptSig = o), a && (n.finalScriptWitness = a), Iu(n);
  }
  finalize() {
    for (let t = 0; t < this.inputs.length; t++)
      this.finalizeIdx(t);
  }
  extract() {
    if (!this.isFinal)
      throw new Error("Transaction has unfinalized inputs");
    if (!this.outputs.length)
      throw new Error("Transaction has no outputs");
    if (this.fee < 0n)
      throw new Error("Outputs spends more than inputs amount");
    return this.toBytes(!0, !0);
  }
  combine(t) {
    for (const i of ["PSBTVersion", "version", "lockTime"])
      if (this.opts[i] !== t.opts[i])
        throw new Error(`Transaction/combine: different ${i} this=${this.opts[i]} other=${t.opts[i]}`);
    for (const i of ["inputs", "outputs"])
      if (this[i].length !== t[i].length)
        throw new Error(`Transaction/combine: different ${i} length this=${this[i].length} other=${t[i].length}`);
    const n = this.global.unsignedTx ? Vs.encode(this.global.unsignedTx) : At, r = t.global.unsignedTx ? Vs.encode(t.global.unsignedTx) : At;
    if (!Pt(n, r))
      throw new Error("Transaction/combine: different unsigned tx");
    this.global = Ol(Yf, this.global, t.global, void 0, this.opts.allowUnknown);
    for (let i = 0; i < this.inputs.length; i++)
      this.updateInput(i, t.inputs[i], !0);
    for (let i = 0; i < this.outputs.length; i++)
      this.updateOutput(i, t.outputs[i], !0);
    return this;
  }
  clone() {
    return ua.fromPSBT(this.toPSBT(this.opts.PSBTVersion), this.opts);
  }
}, Re = class extends ze {
  constructor(t) {
    super(Bu(t));
  }
  static fromPSBT(t, n) {
    return ze.fromPSBT(t, Bu(n));
  }
  static fromRaw(t, n) {
    return ze.fromRaw(t, Bu(n));
  }
};
Re.ARK_TX_OPTS = {
  allowUnknown: !0,
  allowUnknownOutputs: !0,
  allowUnknownInputs: !0
};
function Bu(e) {
  return { ...Re.ARK_TX_OPTS, ...e };
}
let $T = class extends Error {
  idx;
  // Indice of participant
  constructor(t, n) {
    super(n), this.idx = t;
  }
};
const { taggedHash: Iw } = rn.utils, mi = Er.Point, Ae = mi.Fn, Pr = Er.lengths.publicKey, Pl = new Uint8Array(Pr), Wh = Br(vt(33), {
  decode: (e) => Ow(e) ? Pl : e.toBytes(!0),
  encode: (e) => Rf(e, Pl) ? mi.ZERO : mi.fromBytes(e)
}), Kh = le(hw, (e) => ($y("n", e, 1n, Ae.ORDER), e));
jt({ R1: Wh, R2: Wh });
jt({ k1: Kh, k2: Kh, publicKey: vt(Pr) });
function uo(e, ...t) {
  if (!Array.isArray(e))
    throw new Error("expected array");
  e.forEach((n) => io(n, ...t));
}
const IT = (e, ...t) => Ae.create(Ae.fromBytes(Iw(e, ...t), !0));
function OT(e) {
  return mi.BASE.multiply(e);
}
function Ow(e) {
  return e.equals(mi.ZERO);
}
function BT(e) {
  return uo(e, Pr), e.sort(Ha);
}
function CT(e) {
  uo(e, Pr);
  for (let t = 1; t < e.length; t++)
    if (!Rf(e[t], e[0]))
      return e[t];
  return Pl;
}
function RT(e) {
  return uo(e, Pr), Iw("KeyAgg list", ...e);
}
function PT(e, t, n) {
  return io(e, Pr), io(t, Pr), Rf(e, t) ? 1n : IT("KeyAgg coefficient", n, e);
}
function jh(e, t = [], n = []) {
  if (uo(e, Pr), uo(t, 32), t.length !== n.length)
    throw new Error("The tweaks and isXonly arrays must have the same length");
  const r = CT(e), i = RT(e);
  let s = mi.ZERO;
  for (let c = 0; c < e.length; c++) {
    let u;
    try {
      u = mi.fromBytes(e[c]);
    } catch {
      throw new $T(c, "pubkey");
    }
    s = s.add(u.multiply(PT(e[c], r, i)));
  }
  let o = Ae.ONE, a = Ae.ZERO;
  for (let c = 0; c < t.length; c++) {
    const u = n[c] && !jf(s.y) ? Ae.neg(Ae.ONE) : Ae.ONE, l = Ae.fromBytes(t[c]);
    if (s = s.multiply(u).add(OT(l)), Ow(s))
      throw new Error("The result of tweaking cannot be infinity");
    o = Ae.mul(u, o), a = Ae.add(l, Ae.mul(u, a));
  }
  return { aggPublicKey: s, gAcc: o, tweakAcc: a };
}
function NT(e, t, n = {}) {
  e = BT(e);
  const { aggPublicKey: r } = jh(e);
  if (!n.taprootTweak)
    return {
      preTweakedKey: r.toBytes(!0),
      finalKey: r.toBytes(!0)
    };
  const i = rn.utils.taggedHash("TapTweak", r.toBytes(!0).subarray(1), n.taprootTweak ?? new Uint8Array(0)), { aggPublicKey: s } = jh(e, [i], [!0]);
  return {
    preTweakedKey: r.toBytes(!0),
    finalKey: s.toBytes(!0)
  };
}
function Bw(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Cu, zh;
function LT() {
  if (zh) return Cu;
  zh = 1;
  const e = 4294967295, t = 1 << 31, n = 9, r = 65535, i = 1 << 22, s = r, o = 1 << n, a = r << n;
  function c(l) {
    return l & t ? {} : l & i ? {
      seconds: (l & r) << n
    } : {
      blocks: l & r
    };
  }
  function u({ blocks: l, seconds: f }) {
    if (l !== void 0 && f !== void 0) throw new TypeError("Cannot encode blocks AND seconds");
    if (l === void 0 && f === void 0) return e;
    if (f !== void 0) {
      if (!Number.isFinite(f)) throw new TypeError("Expected Number seconds");
      if (f > a) throw new TypeError("Expected Number seconds <= " + a);
      if (f % o !== 0) throw new TypeError("Expected Number seconds as a multiple of " + o);
      return i | f >> n;
    }
    if (!Number.isFinite(l)) throw new TypeError("Expected Number blocks");
    if (l > r) throw new TypeError("Expected Number blocks <= " + s);
    return l;
  }
  return Cu = { decode: c, encode: u }, Cu;
}
var lo = LT(), me;
(function(e) {
  e.VtxoTaprootTree = "taptree", e.VtxoTreeExpiry = "expiry", e.Cosigner = "cosigner", e.ConditionWitness = "condition";
})(me || (me = {}));
const td = 222;
function Cw(e, t, n, r) {
  e.updateInput(t, {
    unknown: [
      ...e.getInput(t)?.unknown ?? [],
      n.encode(r)
    ]
  });
}
function UT(e, t, n) {
  const r = e.getInput(t)?.unknown ?? [], i = [];
  for (const s of r) {
    const o = n.decode(s);
    o && i.push(o);
  }
  return i;
}
const ed = {
  key: me.VtxoTaprootTree,
  encode: (e) => [
    {
      type: td,
      key: jc[me.VtxoTaprootTree]
    },
    e
  ],
  decode: (e) => nd(() => rd(e[0], me.VtxoTaprootTree) ? e[1] : null)
}, Rw = {
  key: me.ConditionWitness,
  encode: (e) => [
    {
      type: td,
      key: jc[me.ConditionWitness]
    },
    oo.encode(e)
  ],
  decode: (e) => nd(() => rd(e[0], me.ConditionWitness) ? oo.decode(e[1]) : null)
}, _T = {
  key: me.Cosigner,
  encode: (e) => [
    {
      type: td,
      key: new Uint8Array([
        ...jc[me.Cosigner],
        e.index
      ])
    },
    e.key
  ],
  decode: (e) => nd(() => rd(e[0], me.Cosigner) ? {
    index: e[0].key[e[0].key.length - 1],
    key: e[1]
  } : null)
};
me.VtxoTreeExpiry;
const jc = Object.fromEntries(Object.values(me).map((e) => [
  e,
  new TextEncoder().encode(e)
])), nd = (e) => {
  try {
    return e();
  } catch {
    return null;
  }
};
function rd(e, t) {
  const n = D.encode(jc[t]);
  return D.encode(new Uint8Array([e.type, ...e.key])).includes(n);
}
Object.values(Rr).filter((e) => typeof e == "number");
let Sr = class Pw {
  constructor(t, n, r, i = 0) {
    if (this.serverPubKey = t, this.vtxoTaprootKey = n, this.hrp = r, this.version = i, t.length !== 32)
      throw new Error("Invalid server public key length, expected 32 bytes, got " + t.length);
    if (n.length !== 32)
      throw new Error("Invalid vtxo taproot public key length, expected 32 bytes, got " + n.length);
  }
  static decode(t) {
    const n = Oi.decodeUnsafe(t, 1023);
    if (!n)
      throw new Error("Invalid address");
    const r = new Uint8Array(Oi.fromWords(n.words));
    if (r.length !== 65)
      throw new Error("Invalid data length, expected 65 bytes, got " + r.length);
    const i = r[0], s = r.slice(1, 33), o = r.slice(33, 65);
    return new Pw(s, o, n.prefix, i);
  }
  encode() {
    const t = new Uint8Array(65);
    t[0] = this.version, t.set(this.serverPubKey, 1), t.set(this.vtxoTaprootKey, 33);
    const n = Oi.toWords(t);
    return Oi.encode(this.hrp, n, 1023);
  }
  // pkScript is the script that should be used to send non-dust funds to the address
  get pkScript() {
    return nt.encode(["OP_1", this.vtxoTaprootKey]);
  }
  // subdustPkScript is the script that should be used to send sub-dust funds to the address
  get subdustPkScript() {
    return nt.encode(["RETURN", this.vtxoTaprootKey]);
  }
};
const za = Gf(void 0, !0);
var Ut;
(function(e) {
  e.Multisig = "multisig", e.CSVMultisig = "csv-multisig", e.ConditionCSVMultisig = "condition-csv-multisig", e.ConditionMultisig = "condition-multisig", e.CLTVMultisig = "cltv-multisig";
})(Ut || (Ut = {}));
function Nw(e) {
  const t = [
    tn,
    Yt,
    fo,
    qa,
    ts
  ];
  for (const n of t)
    try {
      return n.decode(e);
    } catch {
      continue;
    }
  throw new Error(`Failed to decode: script ${D.encode(e)} is not a valid tapscript`);
}
var tn;
(function(e) {
  let t;
  (function(a) {
    a[a.CHECKSIG = 0] = "CHECKSIG", a[a.CHECKSIGADD = 1] = "CHECKSIGADD";
  })(t = e.MultisigType || (e.MultisigType = {}));
  function n(a) {
    if (a.pubkeys.length === 0)
      throw new Error("At least 1 pubkey is required");
    for (const u of a.pubkeys)
      if (u.length !== 32)
        throw new Error(`Invalid pubkey length: expected 32, got ${u.length}`);
    if (a.type || (a.type = t.CHECKSIG), a.type === t.CHECKSIGADD)
      return {
        type: Ut.Multisig,
        params: a,
        script: mT(a.pubkeys.length, a.pubkeys).script
      };
    const c = [];
    for (let u = 0; u < a.pubkeys.length; u++)
      c.push(a.pubkeys[u]), u < a.pubkeys.length - 1 ? c.push("CHECKSIGVERIFY") : c.push("CHECKSIG");
    return {
      type: Ut.Multisig,
      params: a,
      script: nt.encode(c)
    };
  }
  e.encode = n;
  function r(a) {
    if (a.length === 0)
      throw new Error("Failed to decode: script is empty");
    try {
      return i(a);
    } catch {
      try {
        return s(a);
      } catch (u) {
        throw new Error(`Failed to decode script: ${u instanceof Error ? u.message : String(u)}`);
      }
    }
  }
  e.decode = r;
  function i(a) {
    const c = nt.decode(a), u = [];
    let l = !1;
    for (let h = 0; h < c.length; h++) {
      const g = c[h];
      if (typeof g != "string" && typeof g != "number") {
        if (g.length !== 32)
          throw new Error(`Invalid pubkey length: expected 32, got ${g.length}`);
        if (u.push(g), h + 1 >= c.length || c[h + 1] !== "CHECKSIGADD" && c[h + 1] !== "CHECKSIG")
          throw new Error("Expected CHECKSIGADD or CHECKSIG after pubkey");
        h++;
        continue;
      }
      if (h === c.length - 1) {
        if (g !== "NUMEQUAL")
          throw new Error("Expected NUMEQUAL at end of script");
        l = !0;
      }
    }
    if (!l)
      throw new Error("Missing NUMEQUAL operation");
    if (u.length === 0)
      throw new Error("Invalid script: must have at least 1 pubkey");
    const f = n({
      pubkeys: u,
      type: t.CHECKSIGADD
    });
    if (D.encode(f.script) !== D.encode(a))
      throw new Error("Invalid script format: script reconstruction mismatch");
    return {
      type: Ut.Multisig,
      params: { pubkeys: u, type: t.CHECKSIGADD },
      script: a
    };
  }
  function s(a) {
    const c = nt.decode(a), u = [];
    for (let f = 0; f < c.length; f++) {
      const h = c[f];
      if (typeof h != "string" && typeof h != "number") {
        if (h.length !== 32)
          throw new Error(`Invalid pubkey length: expected 32, got ${h.length}`);
        if (u.push(h), f + 1 >= c.length)
          throw new Error("Unexpected end of script");
        const g = c[f + 1];
        if (g !== "CHECKSIGVERIFY" && g !== "CHECKSIG")
          throw new Error("Expected CHECKSIGVERIFY or CHECKSIG after pubkey");
        if (f === c.length - 2 && g !== "CHECKSIG")
          throw new Error("Last operation must be CHECKSIG");
        f++;
        continue;
      }
    }
    if (u.length === 0)
      throw new Error("Invalid script: must have at least 1 pubkey");
    const l = n({ pubkeys: u, type: t.CHECKSIG });
    if (D.encode(l.script) !== D.encode(a))
      throw new Error("Invalid script format: script reconstruction mismatch");
    return {
      type: Ut.Multisig,
      params: { pubkeys: u, type: t.CHECKSIG },
      script: a
    };
  }
  function o(a) {
    return a.type === Ut.Multisig;
  }
  e.is = o;
})(tn || (tn = {}));
var Yt;
(function(e) {
  function t(i) {
    for (const u of i.pubkeys)
      if (u.length !== 32)
        throw new Error(`Invalid pubkey length: expected 32, got ${u.length}`);
    const s = za.encode(BigInt(lo.encode(i.timelock.type === "blocks" ? { blocks: Number(i.timelock.value) } : { seconds: Number(i.timelock.value) }))), o = [
      s.length === 1 ? s[0] : s,
      "CHECKSEQUENCEVERIFY",
      "DROP"
    ], a = tn.encode(i), c = new Uint8Array([
      ...nt.encode(o),
      ...a.script
    ]);
    return {
      type: Ut.CSVMultisig,
      params: i,
      script: c
    };
  }
  e.encode = t;
  function n(i) {
    if (i.length === 0)
      throw new Error("Failed to decode: script is empty");
    const s = nt.decode(i);
    if (s.length < 3)
      throw new Error("Invalid script: too short (expected at least 3)");
    const o = s[0];
    if (typeof o == "string")
      throw new Error("Invalid script: expected sequence number");
    if (s[1] !== "CHECKSEQUENCEVERIFY" || s[2] !== "DROP")
      throw new Error("Invalid script: expected CHECKSEQUENCEVERIFY DROP");
    const a = new Uint8Array(nt.encode(s.slice(3)));
    let c;
    try {
      c = tn.decode(a);
    } catch (g) {
      throw new Error(`Invalid multisig script: ${g instanceof Error ? g.message : String(g)}`);
    }
    let u;
    typeof o == "number" ? u = o : u = Number(za.decode(o));
    const l = lo.decode(u), f = l.blocks !== void 0 ? { type: "blocks", value: BigInt(l.blocks) } : { type: "seconds", value: BigInt(l.seconds) }, h = t({
      timelock: f,
      ...c.params
    });
    if (D.encode(h.script) !== D.encode(i))
      throw new Error("Invalid script format: script reconstruction mismatch");
    return {
      type: Ut.CSVMultisig,
      params: {
        timelock: f,
        ...c.params
      },
      script: i
    };
  }
  e.decode = n;
  function r(i) {
    return i.type === Ut.CSVMultisig;
  }
  e.is = r;
})(Yt || (Yt = {}));
var fo;
(function(e) {
  function t(i) {
    const s = new Uint8Array([
      ...i.conditionScript,
      ...nt.encode(["VERIFY"]),
      ...Yt.encode(i).script
    ]);
    return {
      type: Ut.ConditionCSVMultisig,
      params: i,
      script: s
    };
  }
  e.encode = t;
  function n(i) {
    if (i.length === 0)
      throw new Error("Failed to decode: script is empty");
    const s = nt.decode(i);
    if (s.length < 1)
      throw new Error("Invalid script: too short (expected at least 1)");
    let o = -1;
    for (let f = s.length - 1; f >= 0; f--)
      s[f] === "VERIFY" && (o = f);
    if (o === -1)
      throw new Error("Invalid script: missing VERIFY operation");
    const a = new Uint8Array(nt.encode(s.slice(0, o))), c = new Uint8Array(nt.encode(s.slice(o + 1)));
    let u;
    try {
      u = Yt.decode(c);
    } catch (f) {
      throw new Error(`Invalid CSV multisig script: ${f instanceof Error ? f.message : String(f)}`);
    }
    const l = t({
      conditionScript: a,
      ...u.params
    });
    if (D.encode(l.script) !== D.encode(i))
      throw new Error("Invalid script format: script reconstruction mismatch");
    return {
      type: Ut.ConditionCSVMultisig,
      params: {
        conditionScript: a,
        ...u.params
      },
      script: i
    };
  }
  e.decode = n;
  function r(i) {
    return i.type === Ut.ConditionCSVMultisig;
  }
  e.is = r;
})(fo || (fo = {}));
var qa;
(function(e) {
  function t(i) {
    const s = new Uint8Array([
      ...i.conditionScript,
      ...nt.encode(["VERIFY"]),
      ...tn.encode(i).script
    ]);
    return {
      type: Ut.ConditionMultisig,
      params: i,
      script: s
    };
  }
  e.encode = t;
  function n(i) {
    if (i.length === 0)
      throw new Error("Failed to decode: script is empty");
    const s = nt.decode(i);
    if (s.length < 1)
      throw new Error("Invalid script: too short (expected at least 1)");
    let o = -1;
    for (let f = s.length - 1; f >= 0; f--)
      s[f] === "VERIFY" && (o = f);
    if (o === -1)
      throw new Error("Invalid script: missing VERIFY operation");
    const a = new Uint8Array(nt.encode(s.slice(0, o))), c = new Uint8Array(nt.encode(s.slice(o + 1)));
    let u;
    try {
      u = tn.decode(c);
    } catch (f) {
      throw new Error(`Invalid multisig script: ${f instanceof Error ? f.message : String(f)}`);
    }
    const l = t({
      conditionScript: a,
      ...u.params
    });
    if (D.encode(l.script) !== D.encode(i))
      throw new Error("Invalid script format: script reconstruction mismatch");
    return {
      type: Ut.ConditionMultisig,
      params: {
        conditionScript: a,
        ...u.params
      },
      script: i
    };
  }
  e.decode = n;
  function r(i) {
    return i.type === Ut.ConditionMultisig;
  }
  e.is = r;
})(qa || (qa = {}));
var ts;
(function(e) {
  function t(i) {
    const s = za.encode(i.absoluteTimelock), o = [
      s.length === 1 ? s[0] : s,
      "CHECKLOCKTIMEVERIFY",
      "DROP"
    ], a = nt.encode(o), c = new Uint8Array([
      ...a,
      ...tn.encode(i).script
    ]);
    return {
      type: Ut.CLTVMultisig,
      params: i,
      script: c
    };
  }
  e.encode = t;
  function n(i) {
    if (i.length === 0)
      throw new Error("Failed to decode: script is empty");
    const s = nt.decode(i);
    if (s.length < 3)
      throw new Error("Invalid script: too short (expected at least 3)");
    const o = s[0];
    if (typeof o == "string" || typeof o == "number")
      throw new Error("Invalid script: expected locktime number");
    if (s[1] !== "CHECKLOCKTIMEVERIFY" || s[2] !== "DROP")
      throw new Error("Invalid script: expected CHECKLOCKTIMEVERIFY DROP");
    const a = new Uint8Array(nt.encode(s.slice(3)));
    let c;
    try {
      c = tn.decode(a);
    } catch (f) {
      throw new Error(`Invalid multisig script: ${f instanceof Error ? f.message : String(f)}`);
    }
    const u = za.decode(o), l = t({
      absoluteTimelock: u,
      ...c.params
    });
    if (D.encode(l.script) !== D.encode(i))
      throw new Error("Invalid script format: script reconstruction mismatch");
    return {
      type: Ut.CLTVMultisig,
      params: {
        absoluteTimelock: u,
        ...c.params
      },
      script: i
    };
  }
  e.decode = n;
  function r(i) {
    return i.type === Ut.CLTVMultisig;
  }
  e.is = r;
})(ts || (ts = {}));
const qh = ao.tapTree[2];
function Ks(e) {
  return e[1].subarray(0, e[1].length - 1);
}
let Pe = class Lw {
  static decode(t) {
    const r = qh.decode(t).map((i) => i.script);
    return new Lw(r);
  }
  constructor(t) {
    this.scripts = t;
    const n = t.length % 2 !== 0 ? t.slice().reverse() : t, r = kw(n.map((s) => ({
      script: s,
      leafVersion: co
    }))), i = wT(qf, r, void 0, !0);
    if (!i.tapLeafScript || i.tapLeafScript.length !== t.length)
      throw new Error("invalid scripts");
    this.leaves = i.tapLeafScript, this.tweakedPublicKey = i.tweakedPubkey;
  }
  encode() {
    return qh.encode(this.scripts.map((n) => ({
      depth: 1,
      version: co,
      script: n
    })));
  }
  address(t, n) {
    return new Sr(n, this.tweakedPublicKey, t);
  }
  get pkScript() {
    return nt.encode(["OP_1", this.tweakedPublicKey]);
  }
  onchainAddress(t) {
    return Cr(t).encode({
      type: "tr",
      pubkey: this.tweakedPublicKey
    });
  }
  findLeaf(t) {
    const n = this.leaves.find((r) => D.encode(Ks(r)) === t);
    if (!n)
      throw new Error(`leaf '${t}' not found`);
    return n;
  }
  exitPaths() {
    const t = [];
    for (const n of this.leaves)
      try {
        const r = Yt.decode(Ks(n));
        t.push(r);
        continue;
      } catch {
        try {
          const i = fo.decode(Ks(n));
          t.push(i);
        } catch {
          continue;
        }
      }
    return t;
  }
};
var Ga;
(function(e) {
  class t extends Pe {
    constructor(i) {
      n(i);
      const { sender: s, receiver: o, server: a, preimageHash: c, refundLocktime: u, unilateralClaimDelay: l, unilateralRefundDelay: f, unilateralRefundWithoutReceiverDelay: h } = i, g = DT(c), d = qa.encode({
        conditionScript: g,
        pubkeys: [o, a]
      }).script, p = tn.encode({
        pubkeys: [s, o, a]
      }).script, y = ts.encode({
        absoluteTimelock: u,
        pubkeys: [s, a]
      }).script, x = fo.encode({
        conditionScript: g,
        timelock: l,
        pubkeys: [o]
      }).script, S = Yt.encode({
        timelock: f,
        pubkeys: [s, o]
      }).script, A = Yt.encode({
        timelock: h,
        pubkeys: [s]
      }).script;
      super([
        d,
        p,
        y,
        x,
        S,
        A
      ]), this.options = i, this.claimScript = D.encode(d), this.refundScript = D.encode(p), this.refundWithoutReceiverScript = D.encode(y), this.unilateralClaimScript = D.encode(x), this.unilateralRefundScript = D.encode(S), this.unilateralRefundWithoutReceiverScript = D.encode(A);
    }
    claim() {
      return this.findLeaf(this.claimScript);
    }
    refund() {
      return this.findLeaf(this.refundScript);
    }
    refundWithoutReceiver() {
      return this.findLeaf(this.refundWithoutReceiverScript);
    }
    unilateralClaim() {
      return this.findLeaf(this.unilateralClaimScript);
    }
    unilateralRefund() {
      return this.findLeaf(this.unilateralRefundScript);
    }
    unilateralRefundWithoutReceiver() {
      return this.findLeaf(this.unilateralRefundWithoutReceiverScript);
    }
  }
  e.Script = t;
  function n(r) {
    const { sender: i, receiver: s, server: o, preimageHash: a, refundLocktime: c, unilateralClaimDelay: u, unilateralRefundDelay: l, unilateralRefundWithoutReceiverDelay: f } = r;
    if (!a || a.length !== 20)
      throw new Error("preimage hash must be 20 bytes");
    if (!s || s.length !== 32)
      throw new Error("Invalid public key length (receiver)");
    if (!i || i.length !== 32)
      throw new Error("Invalid public key length (sender)");
    if (!o || o.length !== 32)
      throw new Error("Invalid public key length (server)");
    if (typeof c != "bigint" || c <= 0n)
      throw new Error("refund locktime must be greater than 0");
    if (!u || typeof u.value != "bigint" || u.value <= 0n)
      throw new Error("unilateral claim delay must greater than 0");
    if (u.type === "seconds" && u.value % 512n !== 0n)
      throw new Error("seconds timelock must be multiple of 512");
    if (u.type === "seconds" && u.value < 512n)
      throw new Error("seconds timelock must be greater or equal to 512");
    if (!l || typeof l.value != "bigint" || l.value <= 0n)
      throw new Error("unilateral refund delay must greater than 0");
    if (l.type === "seconds" && l.value % 512n !== 0n)
      throw new Error("seconds timelock must be multiple of 512");
    if (l.type === "seconds" && l.value < 512n)
      throw new Error("seconds timelock must be greater or equal to 512");
    if (!f || typeof f.value != "bigint" || f.value <= 0n)
      throw new Error("unilateral refund without receiver delay must greater than 0");
    if (f.type === "seconds" && f.value % 512n !== 0n)
      throw new Error("seconds timelock must be multiple of 512");
    if (f.type === "seconds" && f.value < 512n)
      throw new Error("seconds timelock must be greater or equal to 512");
  }
})(Ga || (Ga = {}));
function DT(e) {
  return nt.encode(["HASH160", e, "EQUAL"]);
}
var di;
(function(e) {
  class t extends Pe {
    constructor(r) {
      const { pubKey: i, serverPubKey: s, csvTimelock: o = t.DEFAULT_TIMELOCK } = r, a = tn.encode({
        pubkeys: [i, s]
      }).script, c = Yt.encode({
        timelock: o,
        pubkeys: [i]
      }).script;
      super([a, c]), this.options = r, this.forfeitScript = D.encode(a), this.exitScript = D.encode(c);
    }
    forfeit() {
      return this.findLeaf(this.forfeitScript);
    }
    exit() {
      return this.findLeaf(this.exitScript);
    }
  }
  t.DEFAULT_TIMELOCK = {
    value: 144n,
    type: "blocks"
  }, e.Script = t;
})(di || (di = {}));
async function* Nl(e) {
  const t = [], n = [];
  let r = null, i = null;
  const s = (a) => {
    r ? (r(a), r = null) : t.push(a);
  }, o = () => {
    const a = new Error("EventSource error");
    i ? (i(a), i = null) : n.push(a);
  };
  e.addEventListener("message", s), e.addEventListener("error", o);
  try {
    for (; ; ) {
      if (t.length > 0) {
        yield t.shift();
        continue;
      }
      if (n.length > 0)
        throw n.shift();
      const a = await new Promise((c, u) => {
        r = c, i = u;
      }).finally(() => {
        r = null, i = null;
      });
      a && (yield a);
    }
  } finally {
    e.removeEventListener("message", s), e.removeEventListener("error", o);
  }
}
let Uw = class extends Error {
  constructor(t, n, r, i) {
    super(n), this.code = t, this.message = n, this.name = r, this.metadata = i;
  }
};
function VT(e) {
  try {
    if (!(e instanceof Error))
      return;
    const t = JSON.parse(e.message);
    if (!("details" in t) || !Array.isArray(t.details))
      return;
    for (const n of t.details) {
      if (!("@type" in n) || n["@type"] !== "type.googleapis.com/ark.v1.ErrorDetails" || !("code" in n))
        continue;
      const i = n.code;
      if (!("message" in n))
        continue;
      const s = n.message;
      if (!("name" in n))
        continue;
      const o = n.name;
      let a;
      return "metadata" in n && MT(n.metadata) && (a = n.metadata), new Uw(i, s, o, a);
    }
    return;
  } catch {
    return;
  }
}
function MT(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
var vn;
(function(e) {
  function t(i, s, o = []) {
    if (typeof i != "string" && (i = r(i)), s.length == 0)
      throw new Error("intent proof requires at least one input");
    zT(s), GT(o);
    const a = YT(i, s[0].witnessUtxo.script);
    return ZT(a, s, o);
  }
  e.create = t;
  function n(i) {
    let s = 0n;
    for (let a = 0; a < i.inputsLength; a++) {
      const c = i.getInput(a);
      if (c.witnessUtxo === void 0)
        throw new Error("intent proof input requires witness utxo");
      s += c.witnessUtxo.amount;
    }
    let o = 0n;
    for (let a = 0; a < i.outputsLength; a++) {
      const c = i.getOutput(a);
      if (c.amount === void 0)
        throw new Error("intent proof output requires amount");
      o += c.amount;
    }
    if (o > s)
      throw new Error(`intent proof output amount is greater than input amount: ${o} > ${s}`);
    return Number(s - o);
  }
  e.fee = n;
  function r(i) {
    switch (i.type) {
      case "register":
        return JSON.stringify({
          type: "register",
          onchain_output_indexes: i.onchain_output_indexes,
          valid_at: i.valid_at,
          expire_at: i.expire_at,
          cosigners_public_keys: i.cosigners_public_keys
        });
      case "delete":
        return JSON.stringify({
          type: "delete",
          expire_at: i.expire_at
        });
      case "get-pending-tx":
        return JSON.stringify({
          type: "get-pending-tx",
          expire_at: i.expire_at
        });
    }
  }
  e.encodeMessage = r;
})(vn || (vn = {}));
const FT = new Uint8Array([Dt.RETURN]), HT = new Uint8Array(32).fill(0), WT = 4294967295, KT = "ark-intent-proof-message";
function jT(e) {
  if (e.index === void 0)
    throw new Error("intent proof input requires index");
  if (e.txid === void 0)
    throw new Error("intent proof input requires txid");
  if (e.witnessUtxo === void 0)
    throw new Error("intent proof input requires witness utxo");
  return !0;
}
function zT(e) {
  return e.forEach(jT), !0;
}
function qT(e) {
  if (e.amount === void 0)
    throw new Error("intent proof output requires amount");
  if (e.script === void 0)
    throw new Error("intent proof output requires script");
  return !0;
}
function GT(e) {
  return e.forEach(qT), !0;
}
function YT(e, t) {
  const n = XT(e), r = new Re({
    version: 0
  });
  return r.addInput({
    txid: HT,
    // zero hash
    index: WT,
    sequence: 0
  }), r.addOutput({
    amount: 0n,
    script: t
  }), r.updateInput(0, {
    finalScriptSig: nt.encode(["OP_0", n])
  }), r;
}
function ZT(e, t, n) {
  const r = t[0], i = t.map((o) => o.sequence || 0).reduce((o, a) => Math.max(o, a), 0), s = new Re({
    version: 2,
    lockTime: i
  });
  s.addInput({
    ...r,
    txid: e.id,
    index: 0,
    witnessUtxo: {
      script: r.witnessUtxo.script,
      amount: 0n
    },
    sighashType: Rr.ALL
  });
  for (const [o, a] of t.entries())
    s.addInput({
      ...a,
      sighashType: Rr.ALL
    }), a.unknown?.length && s.updateInput(o + 1, {
      unknown: a.unknown
    });
  n.length === 0 && (n = [
    {
      amount: 0n,
      script: FT
    }
  ]);
  for (const o of n)
    s.addOutput({
      amount: o.amount,
      script: o.script
    });
  return s;
}
function XT(e) {
  return rn.utils.taggedHash(KT, new TextEncoder().encode(e));
}
var Ht;
(function(e) {
  e.BatchStarted = "batch_started", e.BatchFinalization = "batch_finalization", e.BatchFinalized = "batch_finalized", e.BatchFailed = "batch_failed", e.TreeSigningStarted = "tree_signing_started", e.TreeNonces = "tree_nonces", e.TreeTx = "tree_tx", e.TreeSignature = "tree_signature";
})(Ht || (Ht = {}));
let _w = class {
  constructor(t) {
    this.serverUrl = t;
  }
  async getInfo() {
    const t = `${this.serverUrl}/v1/info`, n = await fetch(t);
    if (!n.ok) {
      const i = await n.text();
      cn(i, `Failed to get server info: ${n.statusText}`);
    }
    const r = await n.json();
    return {
      boardingExitDelay: BigInt(r.boardingExitDelay ?? 0),
      checkpointTapscript: r.checkpointTapscript ?? "",
      deprecatedSigners: r.deprecatedSigners?.map((i) => ({
        cutoffDate: BigInt(i.cutoffDate ?? 0),
        pubkey: i.pubkey ?? ""
      })) ?? [],
      digest: r.digest ?? "",
      dust: BigInt(r.dust ?? 0),
      fees: {
        intentFee: r.fees?.intentFee ?? {},
        txFeeRate: r?.fees?.txFeeRate ?? ""
      },
      forfeitAddress: r.forfeitAddress ?? "",
      forfeitPubkey: r.forfeitPubkey ?? "",
      network: r.network ?? "",
      scheduledSession: "scheduledSession" in r && r.scheduledSession != null ? {
        duration: BigInt(r.scheduledSession.duration ?? 0),
        nextStartTime: BigInt(r.scheduledSession.nextStartTime ?? 0),
        nextEndTime: BigInt(r.scheduledSession.nextEndTime ?? 0),
        period: BigInt(r.scheduledSession.period ?? 0),
        fees: r.scheduledSession.fees ?? {}
      } : void 0,
      serviceStatus: r.serviceStatus ?? {},
      sessionDuration: BigInt(r.sessionDuration ?? 0),
      signerPubkey: r.signerPubkey ?? "",
      unilateralExitDelay: BigInt(r.unilateralExitDelay ?? 0),
      utxoMaxAmount: BigInt(r.utxoMaxAmount ?? -1),
      utxoMinAmount: BigInt(r.utxoMinAmount ?? 0),
      version: r.version ?? "",
      vtxoMaxAmount: BigInt(r.vtxoMaxAmount ?? -1),
      vtxoMinAmount: BigInt(r.vtxoMinAmount ?? 0)
    };
  }
  async submitTx(t, n) {
    const r = `${this.serverUrl}/v1/tx/submit`, i = await fetch(r, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        signedArkTx: t,
        checkpointTxs: n
      })
    });
    if (!i.ok) {
      const o = await i.text();
      cn(o, `Failed to submit virtual transaction: ${o}`);
    }
    const s = await i.json();
    return {
      arkTxid: s.arkTxid,
      finalArkTx: s.finalArkTx,
      signedCheckpointTxs: s.signedCheckpointTxs
    };
  }
  async finalizeTx(t, n) {
    const r = `${this.serverUrl}/v1/tx/finalize`, i = await fetch(r, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        arkTxid: t,
        finalCheckpointTxs: n
      })
    });
    if (!i.ok) {
      const s = await i.text();
      cn(s, `Failed to finalize offchain transaction: ${s}`);
    }
  }
  async registerIntent(t) {
    const n = `${this.serverUrl}/v1/batch/registerIntent`, r = await fetch(n, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        intent: {
          proof: t.proof,
          message: vn.encodeMessage(t.message)
        }
      })
    });
    if (!r.ok) {
      const s = await r.text();
      cn(s, `Failed to register intent: ${s}`);
    }
    return (await r.json()).intentId;
  }
  async deleteIntent(t) {
    const n = `${this.serverUrl}/v1/batch/deleteIntent`, r = await fetch(n, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        intent: {
          proof: t.proof,
          message: vn.encodeMessage(t.message)
        }
      })
    });
    if (!r.ok) {
      const i = await r.text();
      cn(i, `Failed to delete intent: ${i}`);
    }
  }
  async confirmRegistration(t) {
    const n = `${this.serverUrl}/v1/batch/ack`, r = await fetch(n, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        intentId: t
      })
    });
    if (!r.ok) {
      const i = await r.text();
      cn(i, `Failed to confirm registration: ${i}`);
    }
  }
  async submitTreeNonces(t, n, r) {
    const i = `${this.serverUrl}/v1/batch/tree/submitNonces`, s = await fetch(i, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        batchId: t,
        pubkey: n,
        treeNonces: QT(r)
      })
    });
    if (!s.ok) {
      const o = await s.text();
      cn(o, `Failed to submit tree nonces: ${o}`);
    }
  }
  async submitTreeSignatures(t, n, r) {
    const i = `${this.serverUrl}/v1/batch/tree/submitSignatures`, s = await fetch(i, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        batchId: t,
        pubkey: n,
        treeSignatures: JT(r)
      })
    });
    if (!s.ok) {
      const o = await s.text();
      cn(o, `Failed to submit tree signatures: ${o}`);
    }
  }
  async submitSignedForfeitTxs(t, n) {
    const r = `${this.serverUrl}/v1/batch/submitForfeitTxs`, i = await fetch(r, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        signedForfeitTxs: t,
        signedCommitmentTx: n
      })
    });
    if (!i.ok) {
      const s = await i.text();
      cn(s, `Failed to submit forfeit transactions: ${i.statusText}`);
    }
  }
  async *getEventStream(t, n) {
    const r = `${this.serverUrl}/v1/batch/events`, i = n.length > 0 ? `?${n.map((s) => `topics=${encodeURIComponent(s)}`).join("&")}` : "";
    for (; !t?.aborted; )
      try {
        const s = new EventSource(r + i), o = () => {
          s.close();
        };
        t?.addEventListener("abort", o);
        try {
          for await (const a of Nl(s)) {
            if (t?.aborted)
              break;
            try {
              const c = JSON.parse(a.data), u = this.parseSettlementEvent(c);
              u && (yield u);
            } catch (c) {
              throw console.error("Failed to parse event:", c), c;
            }
          }
        } finally {
          t?.removeEventListener("abort", o), s.close();
        }
      } catch (s) {
        if (s instanceof Error && s.name === "AbortError")
          break;
        if (Ll(s)) {
          console.debug("Timeout error ignored");
          continue;
        }
        throw console.error("Event stream error:", s), s;
      }
  }
  async *getTransactionsStream(t) {
    const n = `${this.serverUrl}/v1/txs`;
    for (; !t?.aborted; )
      try {
        const r = new EventSource(n), i = () => {
          r.close();
        };
        t?.addEventListener("abort", i);
        try {
          for await (const s of Nl(r)) {
            if (t?.aborted)
              break;
            try {
              const o = JSON.parse(s.data), a = this.parseTransactionNotification(o);
              a && (yield a);
            } catch (o) {
              throw console.error("Failed to parse transaction notification:", o), o;
            }
          }
        } finally {
          t?.removeEventListener("abort", i), r.close();
        }
      } catch (r) {
        if (r instanceof Error && r.name === "AbortError")
          break;
        if (Ll(r)) {
          console.debug("Timeout error ignored");
          continue;
        }
        throw console.error("Transaction stream error:", r), r;
      }
  }
  async getPendingTxs(t) {
    const n = `${this.serverUrl}/v1/tx/pending`, r = await fetch(n, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        intent: {
          proof: t.proof,
          message: vn.encodeMessage(t.message)
        }
      })
    });
    if (!r.ok) {
      const s = await r.text();
      cn(s, `Failed to get pending transactions: ${s}`);
    }
    return (await r.json()).pendingTxs;
  }
  parseSettlementEvent(t) {
    if (t.batchStarted)
      return {
        type: Ht.BatchStarted,
        id: t.batchStarted.id,
        intentIdHashes: t.batchStarted.intentIdHashes,
        batchExpiry: BigInt(t.batchStarted.batchExpiry)
      };
    if (t.batchFinalization)
      return {
        type: Ht.BatchFinalization,
        id: t.batchFinalization.id,
        commitmentTx: t.batchFinalization.commitmentTx
      };
    if (t.batchFinalized)
      return {
        type: Ht.BatchFinalized,
        id: t.batchFinalized.id,
        commitmentTxid: t.batchFinalized.commitmentTxid
      };
    if (t.batchFailed)
      return {
        type: Ht.BatchFailed,
        id: t.batchFailed.id,
        reason: t.batchFailed.reason
      };
    if (t.treeSigningStarted)
      return {
        type: Ht.TreeSigningStarted,
        id: t.treeSigningStarted.id,
        cosignersPublicKeys: t.treeSigningStarted.cosignersPubkeys,
        unsignedCommitmentTx: t.treeSigningStarted.unsignedCommitmentTx
      };
    if (t.treeNoncesAggregated)
      return null;
    if (t.treeNonces)
      return {
        type: Ht.TreeNonces,
        id: t.treeNonces.id,
        topic: t.treeNonces.topic,
        txid: t.treeNonces.txid,
        nonces: tS(t.treeNonces.nonces)
        // pubkey -> public nonce
      };
    if (t.treeTx) {
      const n = Object.fromEntries(Object.entries(t.treeTx.children).map(([r, i]) => [parseInt(r), i]));
      return {
        type: Ht.TreeTx,
        id: t.treeTx.id,
        topic: t.treeTx.topic,
        batchIndex: t.treeTx.batchIndex,
        chunk: {
          txid: t.treeTx.txid,
          tx: t.treeTx.tx,
          children: n
        }
      };
    }
    return t.treeSignature ? {
      type: Ht.TreeSignature,
      id: t.treeSignature.id,
      topic: t.treeSignature.topic,
      batchIndex: t.treeSignature.batchIndex,
      txid: t.treeSignature.txid,
      signature: t.treeSignature.signature
    } : (t.heartbeat || console.warn("Unknown event type:", t), null);
  }
  parseTransactionNotification(t) {
    return t.commitmentTx ? {
      commitmentTx: {
        txid: t.commitmentTx.txid,
        tx: t.commitmentTx.tx,
        spentVtxos: t.commitmentTx.spentVtxos.map(Lo),
        spendableVtxos: t.commitmentTx.spendableVtxos.map(Lo),
        checkpointTxs: t.commitmentTx.checkpointTxs
      }
    } : t.arkTx ? {
      arkTx: {
        txid: t.arkTx.txid,
        tx: t.arkTx.tx,
        spentVtxos: t.arkTx.spentVtxos.map(Lo),
        spendableVtxos: t.arkTx.spendableVtxos.map(Lo),
        checkpointTxs: t.arkTx.checkpointTxs
      }
    } : (t.heartbeat || console.warn("Unknown transaction notification type:", t), null);
  }
};
function QT(e) {
  const t = {};
  for (const [n, r] of e)
    t[n] = D.encode(r.pubNonce);
  return t;
}
function JT(e) {
  const t = {};
  for (const [n, r] of e)
    t[n] = D.encode(r.encode());
  return t;
}
function tS(e) {
  return new Map(Object.entries(e).map(([t, n]) => {
    if (typeof n != "string")
      throw new Error("invalid nonce");
    return [t, { pubNonce: D.decode(n) }];
  }));
}
function Ll(e) {
  const t = (n) => n instanceof Error ? n.name === "TypeError" && n.message === "Failed to fetch" || n.name === "HeadersTimeoutError" || n.name === "BodyTimeoutError" || n.code === "UND_ERR_HEADERS_TIMEOUT" || n.code === "UND_ERR_BODY_TIMEOUT" : !1;
  return t(e) || t(e.cause);
}
function Lo(e) {
  return {
    outpoint: {
      txid: e.outpoint.txid,
      vout: e.outpoint.vout
    },
    amount: e.amount,
    script: e.script,
    createdAt: e.createdAt,
    expiresAt: e.expiresAt,
    commitmentTxids: e.commitmentTxids,
    isPreconfirmed: e.isPreconfirmed,
    isSwept: e.isSwept,
    isUnrolled: e.isUnrolled,
    isSpent: e.isSpent,
    spentBy: e.spentBy,
    settledBy: e.settledBy,
    arkTxid: e.arkTxid
  };
}
function cn(e, t) {
  const n = new Error(e);
  throw VT(n) ?? new Error(t);
}
const eS = (e) => la[e], la = {
  bitcoin: $s(Ji, "ark"),
  testnet: $s(Po, "tark"),
  signet: $s(Po, "tark"),
  mutinynet: $s(Po, "tark"),
  regtest: $s({
    ...Po,
    bech32: "bcrt",
    pubKeyHash: 111,
    scriptHash: 196
  }, "tark")
};
function $s(e, t) {
  return {
    ...e,
    hrp: t
  };
}
const nS = {
  bitcoin: "https://mempool.space/api",
  testnet: "https://mempool.space/testnet/api",
  signet: "https://mempool.space/signet/api",
  mutinynet: "https://mutinynet.com/api",
  regtest: "http://localhost:3000"
};
let rS = class {
  constructor(t, n) {
    this.baseUrl = t, this.pollingInterval = n?.pollingInterval ?? 15e3, this.forcePolling = n?.forcePolling ?? !1;
  }
  async getCoins(t) {
    const n = await fetch(`${this.baseUrl}/address/${t}/utxo`);
    if (!n.ok)
      throw new Error(`Failed to fetch UTXOs: ${n.statusText}`);
    return n.json();
  }
  async getFeeRate() {
    const t = await fetch(`${this.baseUrl}/fee-estimates`);
    if (!t.ok)
      throw new Error(`Failed to fetch fee rate: ${t.statusText}`);
    return (await t.json())[1] ?? void 0;
  }
  async broadcastTransaction(...t) {
    switch (t.length) {
      case 1:
        return this.broadcastTx(t[0]);
      case 2:
        return this.broadcastPackage(t[0], t[1]);
      default:
        throw new Error("Only 1 or 1C1P package can be broadcast");
    }
  }
  async getTxOutspends(t) {
    const n = await fetch(`${this.baseUrl}/tx/${t}/outspends`);
    if (!n.ok) {
      const r = await n.text();
      throw new Error(`Failed to get transaction outspends: ${r}`);
    }
    return n.json();
  }
  async getTransactions(t) {
    const n = await fetch(`${this.baseUrl}/address/${t}/txs`);
    if (!n.ok) {
      const r = await n.text();
      throw new Error(`Failed to get transactions: ${r}`);
    }
    return n.json();
  }
  async getTxStatus(t) {
    const n = await fetch(`${this.baseUrl}/tx/${t}`);
    if (!n.ok)
      throw new Error(n.statusText);
    if (!(await n.json()).status.confirmed)
      return { confirmed: !1 };
    const i = await fetch(`${this.baseUrl}/tx/${t}/status`);
    if (!i.ok)
      throw new Error(`Failed to get transaction status: ${i.statusText}`);
    const s = await i.json();
    return s.confirmed ? {
      confirmed: s.confirmed,
      blockTime: s.block_time,
      blockHeight: s.block_height
    } : { confirmed: !1 };
  }
  async watchAddresses(t, n) {
    let r = null;
    const i = this.baseUrl.replace(/^http(s)?:/, "ws$1:") + "/v1/ws", s = async () => {
      const c = async () => (await Promise.all(t.map((g) => this.getTransactions(g)))).flat(), u = await c(), l = (h) => `${h.txid}_${h.status.block_time}`, f = new Set(u.map(l));
      r = setInterval(async () => {
        try {
          const g = (await c()).filter((d) => !f.has(l(d)));
          g.length > 0 && (g.forEach((d) => f.add(l(d))), n(g));
        } catch (h) {
          console.error("Error in polling mechanism:", h);
        }
      }, this.pollingInterval);
    };
    let o = null;
    const a = () => {
      o && o.close(), r && clearInterval(r);
    };
    if (this.forcePolling)
      return await s(), a;
    try {
      o = new WebSocket(i), o.addEventListener("open", () => {
        const c = {
          "track-addresses": t
        };
        o.send(JSON.stringify(c));
      }), o.addEventListener("message", (c) => {
        try {
          const u = [], l = JSON.parse(c.data.toString());
          if (!l["multi-address-transactions"])
            return;
          const f = l["multi-address-transactions"];
          for (const h in f)
            for (const g of [
              "mempool",
              "confirmed",
              "removed"
            ])
              f[h][g] && u.push(...f[h][g].filter(sS));
          u.length > 0 && n(u);
        } catch (u) {
          console.error("Failed to process WebSocket message:", u);
        }
      }), o.addEventListener("error", async () => {
        await s();
      });
    } catch {
      r && clearInterval(r), await s();
    }
    return a;
  }
  async getChainTip() {
    const t = await fetch(`${this.baseUrl}/blocks/tip`);
    if (!t.ok)
      throw new Error(`Failed to get chain tip: ${t.statusText}`);
    const n = await t.json();
    if (!iS(n))
      throw new Error(`Invalid chain tip: ${JSON.stringify(n)}`);
    if (n.length === 0)
      throw new Error("No chain tip found");
    const r = n[0].id;
    return {
      height: n[0].height,
      time: n[0].mediantime,
      hash: r
    };
  }
  async broadcastPackage(t, n) {
    const r = await fetch(`${this.baseUrl}/txs/package`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify([t, n])
    });
    if (!r.ok) {
      const i = await r.text();
      throw new Error(`Failed to broadcast package: ${i}`);
    }
    return r.json();
  }
  async broadcastTx(t) {
    const n = await fetch(`${this.baseUrl}/tx`, {
      method: "POST",
      headers: {
        "Content-Type": "text/plain"
      },
      body: t
    });
    if (!n.ok) {
      const r = await n.text();
      throw new Error(`Failed to broadcast transaction: ${r}`);
    }
    return n.text();
  }
};
function iS(e) {
  return Array.isArray(e) && e.every((t) => t && typeof t == "object" && typeof t.id == "string" && t.id.length > 0 && typeof t.height == "number" && t.height >= 0 && typeof t.mediantime == "number" && t.mediantime > 0);
}
const sS = (e) => typeof e.txid == "string" && Array.isArray(e.vout) && e.vout.every((t) => typeof t.scriptpubkey_address == "string" && typeof t.value == "number") && typeof e.status == "object" && typeof e.status.confirmed == "boolean", oS = 0n, aS = new Uint8Array([81, 2, 78, 115]), id = {
  script: aS,
  amount: oS
};
D.encode(id.script);
function Dw(e, t, n) {
  const r = new Re({
    version: 3,
    lockTime: n
  });
  let i = 0n;
  for (const s of e) {
    if (!s.witnessUtxo)
      throw new Error("input needs witness utxo");
    i += s.witnessUtxo.amount, r.addInput(s);
  }
  return r.addOutput({
    script: t,
    amount: i
  }), r.addOutput(id), r;
}
const cS = new Error("invalid settlement transaction outputs"), uS = new Error("empty tree"), lS = new Error("invalid number of inputs"), Ru = new Error("wrong settlement txid"), fS = new Error("invalid amount"), dS = new Error("no leaves"), hS = new Error("invalid taproot script"), Gh = new Error("invalid round transaction outputs"), pS = new Error("wrong commitment txid"), gS = new Error("missing cosigners public keys"), Pu = 0, Yh = 1;
function Vw(e, t) {
  if (t.validate(), t.root.inputsLength !== 1)
    throw lS;
  const n = t.root.getInput(0), r = ze.fromPSBT(qt.decode(e));
  if (r.outputsLength <= Yh)
    throw cS;
  const i = r.id;
  if (!n.txid || D.encode(n.txid) !== i || n.index !== Yh)
    throw Ru;
}
function Mw(e, t, n) {
  if (t.outputsLength < Pu + 1)
    throw Gh;
  const r = t.getOutput(Pu)?.amount;
  if (!r)
    throw Gh;
  if (!e.root)
    throw uS;
  const i = e.root.getInput(0), s = t.id;
  if (!i.txid || D.encode(i.txid) !== s || i.index !== Pu)
    throw pS;
  let o = 0n;
  for (let c = 0; c < e.root.outputsLength; c++) {
    const u = e.root.getOutput(c);
    u?.amount && (o += u.amount);
  }
  if (o !== r)
    throw fS;
  if (e.leaves().length === 0)
    throw dS;
  e.validate();
  for (const c of e.iterator())
    for (const [u, l] of c.children) {
      const f = c.root.getOutput(u);
      if (!f?.script)
        throw new Error(`parent output ${u} not found`);
      const h = f.script.slice(2);
      if (h.length !== 32)
        throw new Error(`parent output ${u} has invalid script`);
      const g = UT(l.root, 0, _T);
      if (g.length === 0)
        throw gS;
      const d = g.map((y) => y.key), { finalKey: p } = NT(d, !0, {
        taprootTweak: n
      });
      if (!p || D.encode(p.slice(1)) !== D.encode(h))
        throw hS;
    }
}
var Vn;
(function(e) {
  e.TxSent = "SENT", e.TxReceived = "RECEIVED";
})(Vn || (Vn = {}));
function fa(e) {
  return !e.isSpent;
}
function Ya(e) {
  return e.virtualStatus.state === "swept" && fa(e);
}
function yS(e) {
  if (e.virtualStatus.state === "swept")
    return !0;
  const t = e.virtualStatus.batchExpiry;
  return !t || new Date(t).getFullYear() < 2025 ? !1 : t <= Date.now();
}
function wS(e, t) {
  return e.value < t;
}
function Ul(e, t, n) {
  let r = !1;
  for (const [o, a] of t.entries()) {
    if (!a.script)
      throw new Error(`missing output script ${o}`);
    if (nt.decode(a.script)[0] === "RETURN") {
      if (r)
        throw new Error("multiple OP_RETURN outputs");
      r = !0;
    }
  }
  const i = e.map((o) => mS(o, n));
  return {
    arkTx: Fw(i.map((o) => o.input), t),
    checkpoints: i.map((o) => o.tx)
  };
}
function Fw(e, t) {
  let n = 0n;
  for (const i of e) {
    const s = Nw(Ks(i.tapLeafScript));
    if (ts.is(s)) {
      if (n !== 0n && Zh(n) !== Zh(s.params.absoluteTimelock))
        throw new Error("cannot mix seconds and blocks locktime");
      s.params.absoluteTimelock > n && (n = s.params.absoluteTimelock);
    }
  }
  const r = new Re({
    version: 3,
    lockTime: Number(n)
  });
  for (const [i, s] of e.entries())
    r.addInput({
      txid: s.txid,
      index: s.vout,
      sequence: n ? Jf - 1 : void 0,
      witnessUtxo: {
        script: Pe.decode(s.tapTree).pkScript,
        amount: BigInt(s.value)
      },
      tapLeafScript: [s.tapLeafScript]
    }), Cw(r, i, ed, s.tapTree);
  for (const i of t)
    r.addOutput(i);
  return r.addOutput(id), r;
}
function mS(e, t) {
  const n = Nw(Ks(e.tapLeafScript)), r = new Pe([
    t.script,
    n.script
  ]), i = Fw([e], [
    {
      amount: BigInt(e.value),
      script: r.pkScript
    }
  ]), s = r.findLeaf(D.encode(n.script)), o = {
    txid: i.id,
    vout: 0,
    value: e.value,
    tapLeafScript: s,
    tapTree: r.encode()
  };
  return {
    tx: i,
    input: o
  };
}
const bS = 500000000n;
function Zh(e) {
  return e >= bS;
}
function ES(e, t) {
  if (!e.status.block_time)
    return !1;
  if (t.value === 0n)
    return !0;
  if (t.type === "blocks")
    return !1;
  const n = BigInt(Math.floor(Date.now() / 1e3));
  return BigInt(Math.floor(e.status.block_time)) + t.value <= n;
}
function xS(e) {
  return `0x${e.toString(16).padStart(2, "0")}`;
}
function TS(e, t, n, r = [], i = [Rr.DEFAULT]) {
  const s = e.getInput(t), o = [], a = [];
  for (let f = 0; f < e.inputsLength; f++) {
    const h = e.getInput(f);
    if (!h.witnessUtxo)
      throw new Error(`Input ${f} is missing witnessUtxo`);
    o.push(h.witnessUtxo.script), a.push(h.witnessUtxo.amount);
  }
  if (!s.tapScriptSig || s.tapScriptSig.length === 0)
    throw new Error(`Input ${t} is missing tapScriptSig`);
  for (const [f, h] of s.tapScriptSig) {
    const g = f.pubKey, d = D.encode(g);
    if (r.includes(d))
      continue;
    const p = h.length === 65 ? h[64] : Rr.DEFAULT, y = h.subarray(0, 64);
    if (!i.includes(p)) {
      const w = xS(p);
      throw new Error(`Unallowed sighash type ${w} for input ${t}, pubkey ${d}.`);
    }
    if (!s.tapLeafScript || s.tapLeafScript.length === 0)
      throw new Error();
    const x = f.leafHash, S = D.encode(x);
    let A, R;
    for (const [w, K] of s.tapLeafScript) {
      const U = K.subarray(0, -1), W = K[K.length - 1], B = Mi(U, W);
      if (D.encode(B) === S) {
        A = U, R = W;
        break;
      }
    }
    if (!A || R === void 0)
      throw new Error(`Input ${t}: No tapLeafScript found matching leafHash ${D.encode(x)}`);
    const N = e.preimageWitnessV1(t, o, p, a, void 0, A, R);
    if (!rn.verify(y, N, g))
      throw new Error(`Invalid signature for input ${t}, pubkey ${d}`);
  }
  const c = s.tapScriptSig.map(([f]) => D.encode(f.pubKey)), l = n.filter((f) => !r.includes(f)).filter((f) => !c.includes(f));
  if (l.length > 0)
    throw new Error(`Missing signatures from: ${l.map((f) => f.slice(0, 16)).join(", ")}...`);
}
function Nu(e, t) {
  for (let n = 0; n < e.inputsLength; n++) {
    const r = t.getInput(n), i = e.getInput(n);
    if (!r.tapScriptSig)
      throw new Error("No tapScriptSig");
    t.updateInput(n, {
      tapScriptSig: r.tapScriptSig?.concat(i.tapScriptSig)
    });
  }
  return t;
}
const SS = 4320 * 60 * 1e3, vS = {
  thresholdMs: SS
  // 3 days
};
let vr = class Le {
  constructor(t, n, r = Le.DefaultHRP) {
    this.preimage = t, this.value = n, this.HRP = r, this.vout = 0;
    const i = ge(this.preimage);
    this.vtxoScript = new Pe([$S(i)]);
    const s = this.vtxoScript.leaves[0];
    this.txid = D.encode(new Uint8Array(i).reverse()), this.tapTree = this.vtxoScript.encode(), this.forfeitTapLeafScript = s, this.intentTapLeafScript = s, this.value = n, this.status = { confirmed: !0 }, this.extraWitness = [this.preimage];
  }
  encode() {
    const t = new Uint8Array(Le.Length);
    return t.set(this.preimage, 0), kS(t, this.value, this.preimage.length), t;
  }
  static decode(t, n = Le.DefaultHRP) {
    if (t.length !== Le.Length)
      throw new Error(`invalid data length: expected ${Le.Length} bytes, got ${t.length}`);
    const r = t.subarray(0, Le.PreimageLength), i = AS(t, Le.PreimageLength);
    return new Le(r, i, n);
  }
  static fromString(t, n = Le.DefaultHRP) {
    if (t = t.trim(), !t.startsWith(n))
      throw new Error(`invalid human-readable part: expected ${n} prefix (note '${t}')`);
    const r = t.slice(n.length), i = Tl.decode(r);
    if (i.length === 0)
      throw new Error("failed to decode base58 string");
    return Le.decode(i, n);
  }
  toString() {
    return this.HRP + Tl.encode(this.encode());
  }
};
vr.DefaultHRP = "arknote";
vr.PreimageLength = 32;
vr.ValueLength = 4;
vr.Length = vr.PreimageLength + vr.ValueLength;
vr.FakeOutpointIndex = 0;
function kS(e, t, n) {
  new DataView(e.buffer, e.byteOffset + n, 4).setUint32(0, t, !1);
}
function AS(e, t) {
  return new DataView(e.buffer, e.byteOffset + t, 4).getUint32(0, !1);
}
function $S(e) {
  return nt.encode(["SHA256", e, "EQUAL"]);
}
var _l;
(function(e) {
  e[e.INDEXER_TX_TYPE_UNSPECIFIED = 0] = "INDEXER_TX_TYPE_UNSPECIFIED", e[e.INDEXER_TX_TYPE_RECEIVED = 1] = "INDEXER_TX_TYPE_RECEIVED", e[e.INDEXER_TX_TYPE_SENT = 2] = "INDEXER_TX_TYPE_SENT";
})(_l || (_l = {}));
var Fi;
(function(e) {
  e.UNSPECIFIED = "INDEXER_CHAINED_TX_TYPE_UNSPECIFIED", e.COMMITMENT = "INDEXER_CHAINED_TX_TYPE_COMMITMENT", e.ARK = "INDEXER_CHAINED_TX_TYPE_ARK", e.TREE = "INDEXER_CHAINED_TX_TYPE_TREE", e.CHECKPOINT = "INDEXER_CHAINED_TX_TYPE_CHECKPOINT";
})(Fi || (Fi = {}));
let Hw = class {
  constructor(t) {
    this.serverUrl = t;
  }
  async getVtxoTree(t, n) {
    let r = `${this.serverUrl}/v1/indexer/batch/${t.txid}/${t.vout}/tree`;
    const i = new URLSearchParams();
    n && (n.pageIndex !== void 0 && i.append("page.index", n.pageIndex.toString()), n.pageSize !== void 0 && i.append("page.size", n.pageSize.toString())), i.toString() && (r += "?" + i.toString());
    const s = await fetch(r);
    if (!s.ok)
      throw new Error(`Failed to fetch vtxo tree: ${s.statusText}`);
    const o = await s.json();
    if (!Ue.isVtxoTreeResponse(o))
      throw new Error("Invalid vtxo tree data received");
    return o.vtxoTree.forEach((a) => {
      a.children = Object.fromEntries(Object.entries(a.children).map(([c, u]) => [
        Number(c),
        u
      ]));
    }), o;
  }
  async getVtxoTreeLeaves(t, n) {
    let r = `${this.serverUrl}/v1/indexer/batch/${t.txid}/${t.vout}/tree/leaves`;
    const i = new URLSearchParams();
    n && (n.pageIndex !== void 0 && i.append("page.index", n.pageIndex.toString()), n.pageSize !== void 0 && i.append("page.size", n.pageSize.toString())), i.toString() && (r += "?" + i.toString());
    const s = await fetch(r);
    if (!s.ok)
      throw new Error(`Failed to fetch vtxo tree leaves: ${s.statusText}`);
    const o = await s.json();
    if (!Ue.isVtxoTreeLeavesResponse(o))
      throw new Error("Invalid vtxos tree leaves data received");
    return o;
  }
  async getBatchSweepTransactions(t) {
    const n = `${this.serverUrl}/v1/indexer/batch/${t.txid}/${t.vout}/sweepTxs`, r = await fetch(n);
    if (!r.ok)
      throw new Error(`Failed to fetch batch sweep transactions: ${r.statusText}`);
    const i = await r.json();
    if (!Ue.isBatchSweepTransactionsResponse(i))
      throw new Error("Invalid batch sweep transactions data received");
    return i;
  }
  async getCommitmentTx(t) {
    const n = `${this.serverUrl}/v1/indexer/commitmentTx/${t}`, r = await fetch(n);
    if (!r.ok)
      throw new Error(`Failed to fetch commitment tx: ${r.statusText}`);
    const i = await r.json();
    if (!Ue.isCommitmentTx(i))
      throw new Error("Invalid commitment tx data received");
    return i;
  }
  async getCommitmentTxConnectors(t, n) {
    let r = `${this.serverUrl}/v1/indexer/commitmentTx/${t}/connectors`;
    const i = new URLSearchParams();
    n && (n.pageIndex !== void 0 && i.append("page.index", n.pageIndex.toString()), n.pageSize !== void 0 && i.append("page.size", n.pageSize.toString())), i.toString() && (r += "?" + i.toString());
    const s = await fetch(r);
    if (!s.ok)
      throw new Error(`Failed to fetch commitment tx connectors: ${s.statusText}`);
    const o = await s.json();
    if (!Ue.isConnectorsResponse(o))
      throw new Error("Invalid commitment tx connectors data received");
    return o.connectors.forEach((a) => {
      a.children = Object.fromEntries(Object.entries(a.children).map(([c, u]) => [
        Number(c),
        u
      ]));
    }), o;
  }
  async getCommitmentTxForfeitTxs(t, n) {
    let r = `${this.serverUrl}/v1/indexer/commitmentTx/${t}/forfeitTxs`;
    const i = new URLSearchParams();
    n && (n.pageIndex !== void 0 && i.append("page.index", n.pageIndex.toString()), n.pageSize !== void 0 && i.append("page.size", n.pageSize.toString())), i.toString() && (r += "?" + i.toString());
    const s = await fetch(r);
    if (!s.ok)
      throw new Error(`Failed to fetch commitment tx forfeitTxs: ${s.statusText}`);
    const o = await s.json();
    if (!Ue.isForfeitTxsResponse(o))
      throw new Error("Invalid commitment tx forfeitTxs data received");
    return o;
  }
  async *getSubscription(t, n) {
    const r = `${this.serverUrl}/v1/indexer/script/subscription/${t}`;
    for (; !n?.aborted; )
      try {
        const i = new EventSource(r), s = () => {
          i.close();
        };
        n?.addEventListener("abort", s);
        try {
          for await (const o of Nl(i)) {
            if (n?.aborted)
              break;
            try {
              const a = JSON.parse(o.data);
              a.event && (yield {
                txid: a.event.txid,
                scripts: a.event.scripts || [],
                newVtxos: (a.event.newVtxos || []).map(Uo),
                spentVtxos: (a.event.spentVtxos || []).map(Uo),
                sweptVtxos: (a.event.sweptVtxos || []).map(Uo),
                tx: a.event.tx,
                checkpointTxs: a.event.checkpointTxs
              });
            } catch (a) {
              throw console.error("Failed to parse subscription event:", a), a;
            }
          }
        } finally {
          n?.removeEventListener("abort", s), i.close();
        }
      } catch (i) {
        if (i instanceof Error && i.name === "AbortError")
          break;
        if (Ll(i)) {
          console.debug("Timeout error ignored");
          continue;
        }
        throw console.error("Subscription error:", i), i;
      }
  }
  async getVirtualTxs(t, n) {
    let r = `${this.serverUrl}/v1/indexer/virtualTx/${t.join(",")}`;
    const i = new URLSearchParams();
    n && (n.pageIndex !== void 0 && i.append("page.index", n.pageIndex.toString()), n.pageSize !== void 0 && i.append("page.size", n.pageSize.toString())), i.toString() && (r += "?" + i.toString());
    const s = await fetch(r);
    if (!s.ok)
      throw new Error(`Failed to fetch virtual txs: ${s.statusText}`);
    const o = await s.json();
    if (!Ue.isVirtualTxsResponse(o))
      throw new Error("Invalid virtual txs data received");
    return o;
  }
  async getVtxoChain(t, n) {
    let r = `${this.serverUrl}/v1/indexer/vtxo/${t.txid}/${t.vout}/chain`;
    const i = new URLSearchParams();
    n && (n.pageIndex !== void 0 && i.append("page.index", n.pageIndex.toString()), n.pageSize !== void 0 && i.append("page.size", n.pageSize.toString())), i.toString() && (r += "?" + i.toString());
    const s = await fetch(r);
    if (!s.ok)
      throw new Error(`Failed to fetch vtxo chain: ${s.statusText}`);
    const o = await s.json();
    if (!Ue.isVtxoChainResponse(o))
      throw new Error("Invalid vtxo chain data received");
    return o;
  }
  async getVtxos(t) {
    if (t?.scripts && t?.outpoints)
      throw new Error("scripts and outpoints are mutually exclusive options");
    if (!t?.scripts && !t?.outpoints)
      throw new Error("Either scripts or outpoints must be provided");
    let n = `${this.serverUrl}/v1/indexer/vtxos`;
    const r = new URLSearchParams();
    t?.scripts && t.scripts.length > 0 && t.scripts.forEach((o) => {
      r.append("scripts", o);
    }), t?.outpoints && t.outpoints.length > 0 && t.outpoints.forEach((o) => {
      r.append("outpoints", `${o.txid}:${o.vout}`);
    }), t && (t.spendableOnly !== void 0 && r.append("spendableOnly", t.spendableOnly.toString()), t.spentOnly !== void 0 && r.append("spentOnly", t.spentOnly.toString()), t.recoverableOnly !== void 0 && r.append("recoverableOnly", t.recoverableOnly.toString()), t.pageIndex !== void 0 && r.append("page.index", t.pageIndex.toString()), t.pageSize !== void 0 && r.append("page.size", t.pageSize.toString())), r.toString() && (n += "?" + r.toString());
    const i = await fetch(n);
    if (!i.ok)
      throw new Error(`Failed to fetch vtxos: ${i.statusText}`);
    const s = await i.json();
    if (!Ue.isVtxosResponse(s))
      throw new Error("Invalid vtxos data received");
    return {
      vtxos: s.vtxos.map(Uo),
      page: s.page
    };
  }
  async subscribeForScripts(t, n) {
    const r = `${this.serverUrl}/v1/indexer/script/subscribe`, i = await fetch(r, {
      headers: {
        "Content-Type": "application/json"
      },
      method: "POST",
      body: JSON.stringify({ scripts: t, subscriptionId: n })
    });
    if (!i.ok) {
      const o = await i.text();
      throw new Error(`Failed to subscribe to scripts: ${o}`);
    }
    const s = await i.json();
    if (!s.subscriptionId)
      throw new Error("Subscription ID not found");
    return s.subscriptionId;
  }
  async unsubscribeForScripts(t, n) {
    const r = `${this.serverUrl}/v1/indexer/script/unsubscribe`, i = await fetch(r, {
      headers: {
        "Content-Type": "application/json"
      },
      method: "POST",
      body: JSON.stringify({ subscriptionId: t, scripts: n })
    });
    if (!i.ok) {
      const s = await i.text();
      console.warn(`Failed to unsubscribe to scripts: ${s}`);
    }
  }
};
function Uo(e) {
  return {
    txid: e.outpoint.txid,
    vout: e.outpoint.vout,
    value: Number(e.amount),
    status: {
      confirmed: !e.isSwept && !e.isPreconfirmed,
      isLeaf: !e.isPreconfirmed
    },
    virtualStatus: {
      state: e.isSwept ? "swept" : e.isPreconfirmed ? "preconfirmed" : "settled",
      commitmentTxIds: e.commitmentTxids,
      batchExpiry: e.expiresAt ? Number(e.expiresAt) * 1e3 : void 0
    },
    spentBy: e.spentBy ?? "",
    settledBy: e.settledBy,
    arkTxId: e.arkTxid,
    createdAt: new Date(Number(e.createdAt) * 1e3),
    isUnrolled: e.isUnrolled,
    isSpent: e.isSpent
  };
}
var Ue;
(function(e) {
  function t(w) {
    return typeof w == "object" && typeof w.totalOutputAmount == "string" && typeof w.totalOutputVtxos == "number" && typeof w.expiresAt == "string" && typeof w.swept == "boolean";
  }
  function n(w) {
    return typeof w == "object" && typeof w.txid == "string" && typeof w.expiresAt == "string" && Object.values(Fi).includes(w.type) && Array.isArray(w.spends) && w.spends.every((K) => typeof K == "string");
  }
  function r(w) {
    return typeof w == "object" && typeof w.startedAt == "string" && typeof w.endedAt == "string" && typeof w.totalInputAmount == "string" && typeof w.totalInputVtxos == "number" && typeof w.totalOutputAmount == "string" && typeof w.totalOutputVtxos == "number" && typeof w.batches == "object" && Object.values(w.batches).every(t);
  }
  e.isCommitmentTx = r;
  function i(w) {
    return typeof w == "object" && typeof w.txid == "string" && typeof w.vout == "number";
  }
  e.isOutpoint = i;
  function s(w) {
    return Array.isArray(w) && w.every(i);
  }
  e.isOutpointArray = s;
  function o(w) {
    return typeof w == "object" && typeof w.txid == "string" && typeof w.children == "object" && Object.values(w.children).every(l) && Object.keys(w.children).every((K) => Number.isInteger(Number(K)));
  }
  function a(w) {
    return Array.isArray(w) && w.every(o);
  }
  e.isTxsArray = a;
  function c(w) {
    return typeof w == "object" && typeof w.amount == "string" && typeof w.createdAt == "string" && typeof w.isSettled == "boolean" && typeof w.settledBy == "string" && Object.values(_l).includes(w.type) && (!w.commitmentTxid && typeof w.virtualTxid == "string" || typeof w.commitmentTxid == "string" && !w.virtualTxid);
  }
  function u(w) {
    return Array.isArray(w) && w.every(c);
  }
  e.isTxHistoryRecordArray = u;
  function l(w) {
    return typeof w == "string" && w.length === 64;
  }
  function f(w) {
    return Array.isArray(w) && w.every(l);
  }
  e.isTxidArray = f;
  function h(w) {
    return typeof w == "object" && i(w.outpoint) && typeof w.createdAt == "string" && (w.expiresAt === null || typeof w.expiresAt == "string") && typeof w.amount == "string" && typeof w.script == "string" && typeof w.isPreconfirmed == "boolean" && typeof w.isSwept == "boolean" && typeof w.isUnrolled == "boolean" && typeof w.isSpent == "boolean" && (!w.spentBy || typeof w.spentBy == "string") && (!w.settledBy || typeof w.settledBy == "string") && (!w.arkTxid || typeof w.arkTxid == "string") && Array.isArray(w.commitmentTxids) && w.commitmentTxids.every(l);
  }
  function g(w) {
    return typeof w == "object" && typeof w.current == "number" && typeof w.next == "number" && typeof w.total == "number";
  }
  function d(w) {
    return typeof w == "object" && Array.isArray(w.vtxoTree) && w.vtxoTree.every(o) && (!w.page || g(w.page));
  }
  e.isVtxoTreeResponse = d;
  function p(w) {
    return typeof w == "object" && Array.isArray(w.leaves) && w.leaves.every(i) && (!w.page || g(w.page));
  }
  e.isVtxoTreeLeavesResponse = p;
  function y(w) {
    return typeof w == "object" && Array.isArray(w.connectors) && w.connectors.every(o) && (!w.page || g(w.page));
  }
  e.isConnectorsResponse = y;
  function x(w) {
    return typeof w == "object" && Array.isArray(w.txids) && w.txids.every(l) && (!w.page || g(w.page));
  }
  e.isForfeitTxsResponse = x;
  function S(w) {
    return typeof w == "object" && Array.isArray(w.sweptBy) && w.sweptBy.every(l);
  }
  e.isSweptCommitmentTxResponse = S;
  function A(w) {
    return typeof w == "object" && Array.isArray(w.sweptBy) && w.sweptBy.every(l);
  }
  e.isBatchSweepTransactionsResponse = A;
  function R(w) {
    return typeof w == "object" && Array.isArray(w.txs) && w.txs.every((K) => typeof K == "string") && (!w.page || g(w.page));
  }
  e.isVirtualTxsResponse = R;
  function N(w) {
    return typeof w == "object" && Array.isArray(w.chain) && w.chain.every(n) && (!w.page || g(w.page));
  }
  e.isVtxoChainResponse = N;
  function F(w) {
    return typeof w == "object" && Array.isArray(w.vtxos) && w.vtxos.every(h) && (!w.page || g(w.page));
  }
  e.isVtxosResponse = F;
})(Ue || (Ue = {}));
const IS = 546;
function Ri(e, t) {
  return {
    ...t,
    forfeitTapLeafScript: e.offchainTapscript.forfeit(),
    intentTapLeafScript: e.offchainTapscript.forfeit(),
    tapTree: e.offchainTapscript.encode()
  };
}
function OS(e, t) {
  return {
    ...t,
    forfeitTapLeafScript: e.boardingTapscript.forfeit(),
    intentTapLeafScript: e.boardingTapscript.forfeit(),
    tapTree: e.boardingTapscript.encode()
  };
}
let da = class {
  constructor(t, n = /* @__PURE__ */ new Map()) {
    this.root = t, this.children = n;
  }
  static create(t) {
    if (t.length === 0)
      throw new Error("empty chunks");
    const n = /* @__PURE__ */ new Map();
    for (const s of t) {
      const o = CS(s), a = o.tx.id;
      n.set(a, o);
    }
    const r = [];
    for (const [s] of n) {
      let o = !1;
      for (const [a, c] of n)
        if (a !== s && (o = BS(c, s), o))
          break;
      if (!o) {
        r.push(s);
        continue;
      }
    }
    if (r.length === 0)
      throw new Error("no root chunk found");
    if (r.length > 1)
      throw new Error(`multiple root chunks found: ${r.join(", ")}`);
    const i = Ww(r[0], n);
    if (!i)
      throw new Error(`chunk not found for root txid: ${r[0]}`);
    if (i.nbOfNodes() !== t.length)
      throw new Error(`number of chunks (${t.length}) is not equal to the number of nodes in the graph (${i.nbOfNodes()})`);
    return i;
  }
  nbOfNodes() {
    let t = 1;
    for (const n of this.children.values())
      t += n.nbOfNodes();
    return t;
  }
  validate() {
    if (!this.root)
      throw new Error("unexpected nil root");
    const t = this.root.outputsLength, n = this.root.inputsLength;
    if (n !== 1)
      throw new Error(`unexpected number of inputs: ${n}, expected 1`);
    if (this.children.size > t - 1)
      throw new Error(`unexpected number of children: ${this.children.size}, expected maximum ${t - 1}`);
    for (const [r, i] of this.children) {
      if (r >= t)
        throw new Error(`output index ${r} is out of bounds (nb of outputs: ${t})`);
      i.validate();
      const s = i.root.getInput(0), o = this.root.id;
      if (!s.txid || D.encode(s.txid) !== o || s.index !== r)
        throw new Error(`input of child ${r} is not the output of the parent`);
      let a = 0n;
      for (let u = 0; u < i.root.outputsLength; u++) {
        const l = i.root.getOutput(u);
        l?.amount && (a += l.amount);
      }
      const c = this.root.getOutput(r);
      if (!c?.amount)
        throw new Error(`parent output ${r} has no amount`);
      if (a !== c.amount)
        throw new Error(`sum of child's outputs is not equal to the output of the parent: ${a} != ${c.amount}`);
    }
  }
  leaves() {
    if (this.children.size === 0)
      return [this.root];
    const t = [];
    for (const n of this.children.values())
      t.push(...n.leaves());
    return t;
  }
  get txid() {
    return this.root.id;
  }
  find(t) {
    if (t === this.txid)
      return this;
    for (const n of this.children.values()) {
      const r = n.find(t);
      if (r)
        return r;
    }
    return null;
  }
  update(t, n) {
    if (t === this.txid) {
      n(this.root);
      return;
    }
    for (const r of this.children.values())
      try {
        r.update(t, n);
        return;
      } catch {
        continue;
      }
    throw new Error(`tx not found: ${t}`);
  }
  *iterator() {
    for (const t of this.children.values())
      yield* t.iterator();
    yield this;
  }
};
function BS(e, t) {
  return Object.values(e.children).includes(t);
}
function Ww(e, t) {
  const n = t.get(e);
  if (!n)
    return null;
  const r = n.tx, i = /* @__PURE__ */ new Map();
  for (const [s, o] of Object.entries(n.children)) {
    const a = parseInt(s), c = Ww(o, t);
    c && i.set(a, c);
  }
  return new da(r, i);
}
function CS(e) {
  return { tx: ze.fromPSBT(qt.decode(e.tx)), children: e.children };
}
var Za;
(function(e) {
  let t;
  (function(r) {
    r.Start = "start", r.BatchStarted = "batch_started", r.TreeSigningStarted = "tree_signing_started", r.TreeNoncesAggregated = "tree_nonces_aggregated", r.BatchFinalization = "batch_finalization";
  })(t || (t = {}));
  async function n(r, i, s = {}) {
    const { abortController: o, skipVtxoTreeSigning: a = !1, eventCallback: c } = s;
    let u = t.Start;
    const l = [], f = [];
    let h, g;
    for await (const d of r) {
      if (o?.signal.aborted)
        throw new Error("canceled");
      switch (c && c(d).catch(() => {
      }), d.type) {
        case Ht.BatchStarted: {
          const p = d, { skip: y } = await i.onBatchStarted(p);
          y || (u = t.BatchStarted, a && (u = t.TreeNoncesAggregated));
          continue;
        }
        case Ht.BatchFinalized: {
          if (u !== t.BatchFinalization)
            continue;
          return i.onBatchFinalized && await i.onBatchFinalized(d), d.commitmentTxid;
        }
        case Ht.BatchFailed: {
          if (i.onBatchFailed) {
            await i.onBatchFailed(d);
            continue;
          }
          throw new Error(d.reason);
        }
        case Ht.TreeTx: {
          if (u !== t.BatchStarted && u !== t.TreeNoncesAggregated)
            continue;
          d.batchIndex === 0 ? l.push(d.chunk) : f.push(d.chunk), i.onTreeTxEvent && await i.onTreeTxEvent(d);
          continue;
        }
        case Ht.TreeSignature: {
          if (u !== t.TreeNoncesAggregated)
            continue;
          if (!h)
            throw new Error("vtxo tree not initialized");
          const p = D.decode(d.signature);
          h.update(d.txid, (y) => {
            y.updateInput(0, {
              tapKeySig: p
            });
          }), i.onTreeSignatureEvent && await i.onTreeSignatureEvent(d);
          continue;
        }
        case Ht.TreeSigningStarted: {
          if (u !== t.BatchStarted)
            continue;
          h = da.create(l);
          const { skip: p } = await i.onTreeSigningStarted(d, h);
          p || (u = t.TreeSigningStarted);
          continue;
        }
        case Ht.TreeNonces: {
          if (u !== t.TreeSigningStarted)
            continue;
          const { fullySigned: p } = await i.onTreeNonces(d);
          p && (u = t.TreeNoncesAggregated);
          continue;
        }
        case Ht.BatchFinalization: {
          if (u !== t.TreeNoncesAggregated)
            continue;
          if (!h && l.length > 0 && (h = da.create(l)), !h && !a)
            throw new Error("vtxo tree not initialized");
          f.length > 0 && (g = da.create(f)), await i.onBatchFinalization(d, h, g), u = t.BatchFinalization;
          continue;
        }
        default:
          continue;
      }
    }
    throw new Error("event stream closed");
  }
  e.join = n;
})(Za || (Za = {}));
let mt = class extends Error {
  #t;
  constructor(t, n, r) {
    super(t, { cause: r }), this.name = "ParseError", this.#t = n, n?.input && (this.message = es(this.message, n));
  }
  get node() {
    return this.#t;
  }
  withAst(t) {
    return this.#t || !t?.input ? this : (this.#t = t, this.message = es(this.message, t), this);
  }
}, J = class extends Error {
  #t;
  constructor(t, n, r) {
    super(t, { cause: r }), this.name = "EvaluationError", this.#t = n, n?.input && (this.message = es(this.message, n));
  }
  get node() {
    return this.#t;
  }
  withAst(t) {
    return this.#t || !t?.input ? this : (this.#t = t, this.message = es(this.message, t), this);
  }
}, RS = class extends Error {
  #t;
  constructor(t, n, r) {
    super(t, { cause: r }), this.name = "TypeError", this.#t = n, n?.input && (this.message = es(this.message, n));
  }
  get node() {
    return this.#t;
  }
  withAst(t) {
    return this.#t || !t?.input ? this : (this.#t = t, this.message = es(this.message, t), this);
  }
};
function es(e, t) {
  if (t?.pos === void 0) return e;
  const n = t.pos, r = t.input;
  let i = 1, s = 0, o = 0;
  for (; s < n; )
    r[s] === `
` ? (i++, o = 0) : o++, s++;
  let a = n, c = n;
  for (; a > 0 && r[a - 1] !== `
`; ) a--;
  for (; c < r.length && r[c] !== `
`; ) c++;
  const u = r.slice(a, c), l = `> ${`${i}`.padStart(4, " ")} | ${u}
${" ".repeat(9 + o)}^`;
  return `${e}

${l}`;
}
let hi = class Dl {
  #t;
  constructor(t) {
    this.#t = t;
  }
  static of(t) {
    return t === void 0 ? Xa : new Dl(t);
  }
  static none() {
    return Xa;
  }
  hasValue() {
    return this.#t !== void 0;
  }
  value() {
    if (this.#t === void 0) throw new J("Optional value is not present");
    return this.#t;
  }
  or(t) {
    if (this.#t !== void 0) return this;
    if (t instanceof Dl) return t;
    throw new J("Optional.or must be called with an Optional argument");
  }
  orValue(t) {
    return this.#t === void 0 ? t : this.#t;
  }
  get [Symbol.toStringTag]() {
    return "optional";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.#t === void 0 ? "Optional { none }" : `Optional { value: ${JSON.stringify(this.#t)} }`;
  }
};
const Xa = Object.freeze(new hi());
let Kw = class {
};
const jw = new Kw();
function PS(e, t) {
  e.constants.set("optional", t ? jw : void 0);
}
function NS(e) {
  const t = (f, h) => e.registerFunctionOverload(f, h), n = e.enableOptionalTypes ? jw : void 0;
  e.registerType("OptionalNamespace", Kw), e.registerConstant("optional", "OptionalNamespace", n), t("optional.hasValue(): bool", (f) => f.hasValue()), t("optional<A>.value(): A", (f) => f.value()), e.registerFunctionOverload("OptionalNamespace.none(): optional<T>", () => hi.none()), t("OptionalNamespace.of(A): optional<A>", (f, h) => hi.of(h));
  function r(f, h, g) {
    if (f instanceof hi) return f;
    throw new J(`${g} must be optional`, h);
  }
  function i(f, h, g) {
    const d = f.eval(h.receiver, g);
    return d instanceof Promise ? d.then((p) => s(p, f, h, g)) : s(d, f, h, g);
  }
  function s(f, h, g, d) {
    const p = r(f, g.receiver, `${g.functionDesc} receiver`);
    return p.hasValue() ? g.onHasValue(p) : g.onEmpty(h, g, d);
  }
  function o(f, h, g, d) {
    const p = f.check(h, g);
    if (p.kind === "optional") return p;
    if (p.kind === "dyn") return f.getType("optional");
    throw new f.Error(`${d} must be optional, got '${p}'`, h);
  }
  function a({ functionDesc: f, evaluate: h, typeCheck: g, onHasValue: d, onEmpty: p }) {
    return ({ args: y, receiver: x }) => ({
      functionDesc: f,
      receiver: x,
      arg: y[0],
      evaluate: h,
      typeCheck: g,
      onHasValue: d,
      onEmpty: p
    });
  }
  const c = "optional.orValue() receiver", u = "optional.or(optional) receiver", l = "optional.or(optional) argument";
  e.registerFunctionOverload(
    "optional.or(ast): optional<dyn>",
    a({
      functionDesc: "optional.or(optional)",
      evaluate: i,
      typeCheck(f, h, g) {
        const d = o(f, h.receiver, g, u), p = o(f, h.arg, g, l), y = d.unify(f.registry, p);
        if (y) return y;
        throw new f.Error(
          `${h.functionDesc} argument must be compatible type, got '${d}' and '${p}'`,
          h.arg
        );
      },
      onHasValue: (f) => f,
      onEmpty(f, h, g) {
        const d = h.arg, p = f.eval(d, g);
        return p instanceof Promise ? p.then((y) => r(y, d, l)) : r(p, d, l);
      }
    })
  ), e.registerFunctionOverload(
    "optional.orValue(ast): dyn",
    a({
      functionDesc: "optional.orValue(value)",
      onHasValue: (f) => f.value(),
      onEmpty(f, h, g) {
        return f.eval(h.arg, g);
      },
      evaluate: i,
      typeCheck(f, h, g) {
        const d = o(f, h.receiver, g, c).valueType, p = f.check(h.arg, g), y = d.unify(f.registry, p);
        if (y) return y;
        throw new f.Error(
          `${h.functionDesc} argument must be compatible type, got '${d}' and '${p}'`,
          h.arg
        );
      }
    })
  );
}
const Vl = Object.hasOwn, kn = Object.keys, Hr = Object.freeze, LS = Object.entries, ha = Array.isArray, Xh = Array.from, Qa = /* @__PURE__ */ new Set([
  "as",
  "break",
  "const",
  "continue",
  "else",
  "for",
  "function",
  "if",
  "import",
  "let",
  "loop",
  "package",
  "namespace",
  "return",
  "var",
  "void",
  "while",
  "__proto__",
  "prototype"
]);
let Qr = class {
  #t;
  constructor(t) {
    this.verify(BigInt(t));
  }
  get value() {
    return this.#t;
  }
  valueOf() {
    return this.#t;
  }
  verify(t) {
    if (t < 0n || t > 18446744073709551615n) throw new J("Unsigned integer overflow");
    this.#t = t;
  }
  get [Symbol.toStringTag]() {
    return `value = ${this.#t}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `UnsignedInteger { value: ${this.#t} }`;
  }
};
const US = {
  h: 3600000000000n,
  m: 60000000000n,
  s: 1000000000n,
  ms: 1000000n,
  us: 1000n,
  ¬µs: 1000n,
  ns: 1n
};
let pa = class ga {
  #t;
  #e;
  constructor(t, n = 0) {
    this.#t = BigInt(t), this.#e = n;
  }
  get seconds() {
    return this.#t;
  }
  get nanos() {
    return this.#e;
  }
  valueOf() {
    return Number(this.#t) * 1e3 + this.#e / 1e6;
  }
  static fromMilliseconds(t) {
    const n = BigInt(Math.trunc(t * 1e6)), r = n / 1000000000n, i = Number(n % 1000000000n);
    return new ga(r, i);
  }
  addDuration(t) {
    const n = this.#e + t.nanos;
    return new ga(
      this.#t + t.seconds + BigInt(Math.floor(n / 1e9)),
      n % 1e9
    );
  }
  subtractDuration(t) {
    const n = this.#e - t.nanos;
    return new ga(
      this.#t - t.seconds + BigInt(Math.floor(n / 1e9)),
      (n + 1e9) % 1e9
    );
  }
  extendTimestamp(t) {
    return new Date(
      t.getTime() + Number(this.#t) * 1e3 + Math.floor(this.#e / 1e6)
    );
  }
  subtractTimestamp(t) {
    return new Date(
      t.getTime() - Number(this.#t) * 1e3 - Math.floor(this.#e / 1e6)
    );
  }
  toString() {
    const t = this.#e ? (this.#e / 1e9).toLocaleString("en-US", { useGrouping: !1, maximumFractionDigits: 9 }).slice(1) : "";
    return `${this.#t}${t}s`;
  }
  getHours() {
    return this.#t / 3600n;
  }
  getMinutes() {
    return this.#t / 60n;
  }
  getSeconds() {
    return this.#t;
  }
  getMilliseconds() {
    return this.#t * 1000n + BigInt(Math.floor(this.#e / 1e6));
  }
  get [Symbol.toStringTag]() {
    return "google.protobuf.Duration";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `google.protobuf.Duration { seconds: ${this.#t}, nanos: ${this.#e} }`;
  }
};
function _S(e) {
  const t = (d, p) => e.registerFunctionOverload(d, p), n = (d) => d;
  t("dyn(dyn): dyn", n);
  for (const d in $e) {
    const p = $e[d];
    p instanceof ne && t(`type(${p.name}): type`, () => p);
  }
  t("bool(bool): bool", n), t("bool(string): bool", (d) => {
    switch (d) {
      case "1":
      case "t":
      case "true":
      case "TRUE":
      case "True":
        return !0;
      case "0":
      case "f":
      case "false":
      case "FALSE":
      case "False":
        return !1;
      default:
        throw new J(`bool() conversion error: invalid string value "${d}"`);
    }
  }), t("size(string): int", (d) => BigInt(Qh(d))), t("size(bytes): int", (d) => BigInt(d.length)), t("size(list): int", (d) => BigInt(d.length ?? d.size)), t("size(map): int", (d) => BigInt(d instanceof Map ? d.size : kn(d).length)), t("string.size(): int", (d) => BigInt(Qh(d))), t("bytes.size(): int", (d) => BigInt(d.length)), t("list.size(): int", (d) => BigInt(d.length ?? d.size)), t("map.size(): int", (d) => BigInt(d instanceof Map ? d.size : kn(d).length)), t("bytes(string): bytes", (d) => s.fromString(d)), t("bytes(bytes): bytes", n), t("double(double): double", n), t("double(int): double", (d) => Number(d)), t("double(uint): double", (d) => Number(d)), t("double(string): double", (d) => {
    if (!d || d !== d.trim())
      throw new J("double() type error: cannot convert to double");
    switch (d.toLowerCase()) {
      case "inf":
      case "+inf":
      case "infinity":
      case "+infinity":
        return Number.POSITIVE_INFINITY;
      case "-inf":
      case "-infinity":
        return Number.NEGATIVE_INFINITY;
      case "nan":
        return Number.NaN;
      default: {
        const y = Number(d);
        if (!Number.isNaN(y)) return y;
        throw new J("double() type error: cannot convert to double");
      }
    }
  }), t("int(int): int", n), t("int(double): int", (d) => {
    if (Number.isFinite(d)) return BigInt(Math.trunc(d));
    throw new J("int() type error: integer overflow");
  }), t("int(string): int", (d) => {
    if (d !== d.trim() || d.length > 20 || d.includes("0x"))
      throw new J("int() type error: cannot convert to int");
    try {
      const p = BigInt(d);
      if (p <= 9223372036854775807n && p >= -9223372036854775808n) return p;
    } catch {
    }
    throw new J("int() type error: cannot convert to int");
  }), t("uint(uint): uint", n), t("uint(int): uint", (d) => {
    if (d >= 0n && d <= 18446744073709551615n) return d;
    throw new J("uint() type error: cannot convert to uint");
  }), t("uint(double): uint", (d) => {
    if (d >= 0 && Number.isFinite(d)) return BigInt(Math.trunc(d));
    throw new J("uint() type error: unsigned integer overflow");
  }), t("uint(string): uint", (d) => {
    if (d !== d.trim() || d.length > 20 || d.includes("0x"))
      throw new J("uint() type error: cannot convert to uint");
    try {
      const p = BigInt(d);
      if (p <= 18446744073709551615n && p >= 0n) return p;
    } catch {
    }
    throw new J("uint() type error: cannot convert to uint");
  }), t("string(string): string", n), t("string(bool): string", (d) => `${d}`), t("string(int): string", (d) => `${d}`), t("string(bytes): string", (d) => s.toUtf8(d)), t("string(double): string", (d) => d === 1 / 0 ? "+Inf" : d === -1 / 0 ? "-Inf" : `${d}`), t("string.startsWith(string): bool", (d, p) => d.startsWith(p)), t("string.endsWith(string): bool", (d, p) => d.endsWith(p)), t("string.contains(string): bool", (d, p) => d.includes(p)), t("string.lowerAscii(): string", (d) => d.toLowerCase()), t("string.upperAscii(): string", (d) => d.toUpperCase()), t("string.trim(): string", (d) => d.trim()), t(
    "string.indexOf(string): int",
    (d, p) => BigInt(d.indexOf(p))
  ), t("string.indexOf(string, int): int", (d, p, y) => {
    if (p === "") return y;
    if (y = Number(y), y < 0 || y >= d.length)
      throw new J("string.indexOf(search, fromIndex): fromIndex out of range");
    return BigInt(d.indexOf(p, y));
  }), t(
    "string.lastIndexOf(string): int",
    (d, p) => BigInt(d.lastIndexOf(p))
  ), t("string.lastIndexOf(string, int): int", (d, p, y) => {
    if (p === "") return y;
    if (y = Number(y), y < 0 || y >= d.length)
      throw new J("string.lastIndexOf(search, fromIndex): fromIndex out of range");
    return BigInt(d.lastIndexOf(p, y));
  }), t("string.substring(int): string", (d, p) => {
    if (p = Number(p), p < 0 || p > d.length)
      throw new J("string.substring(start, end): start index out of range");
    return d.substring(p);
  }), t("string.substring(int, int): string", (d, p, y) => {
    if (p = Number(p), p < 0 || p > d.length)
      throw new J("string.substring(start, end): start index out of range");
    if (y = Number(y), y < p || y > d.length)
      throw new J("string.substring(start, end): end index out of range");
    return d.substring(p, y);
  }), t("string.matches(string): bool", (d, p) => {
    try {
      return new RegExp(p).test(d);
    } catch {
      throw new J(`Invalid regular expression: ${p}`);
    }
  }), t("string.split(string): list<string>", (d, p) => d.split(p)), t("string.split(string, int): list<string>", (d, p, y) => {
    if (y = Number(y), y === 0) return [];
    const x = d.split(p);
    if (y < 0 || x.length <= y) return x;
    const S = x.slice(0, y - 1);
    return S.push(x.slice(y - 1).join(p)), S;
  }), t("list<string>.join(): string", (d) => {
    for (let p = 0; p < d.length; p++)
      if (typeof d[p] != "string")
        throw new J("string.join(): list must contain only strings");
    return d.join("");
  }), t("list<string>.join(string): string", (d, p) => {
    for (let y = 0; y < d.length; y++)
      if (typeof d[y] != "string")
        throw new J("string.join(separator): list must contain only strings");
    return d.join(p);
  });
  const r = new TextEncoder("utf8"), i = new TextDecoder("utf8"), s = typeof Buffer < "u" ? {
    byteLength: (d) => Buffer.byteLength(d),
    fromString: (d) => Buffer.from(d, "utf8"),
    toHex: (d) => Buffer.prototype.hexSlice.call(d, 0, d.length),
    toBase64: (d) => Buffer.prototype.base64Slice.call(d, 0, d.length),
    toUtf8: (d) => Buffer.prototype.utf8Slice.call(d, 0, d.length),
    jsonParse: (d) => JSON.parse(d)
  } : {
    textEncoder: new TextEncoder("utf8"),
    byteLength: (d) => r.encode(d).length,
    fromString: (d) => r.encode(d),
    toHex: Uint8Array.prototype.toHex ? (d) => d.toHex() : (d) => Xh(d, (p) => p.toString(16).padStart(2, "0")).join(""),
    toBase64: Uint8Array.prototype.toBase64 ? (d) => d.toBase64() : (d) => btoa(Xh(d, (p) => String.fromCodePoint(p)).join("")),
    toUtf8: (d) => i.decode(d),
    jsonParse: (d) => JSON.parse(r.decode(d))
  };
  t("bytes.json(): map", s.jsonParse), t("bytes.hex(): string", s.toHex), t("bytes.string(): string", s.toUtf8), t("bytes.base64(): string", s.toBase64), t("bytes.at(int): int", (d, p) => {
    if (p < 0 || p >= d.length) throw new J("Bytes index out of range");
    return BigInt(d[p]);
  });
  const o = "google.protobuf.Timestamp", a = "google.protobuf.Duration", c = e.registerType(o, Date).getObjectType(o).typeType, u = e.registerType(a, pa).getObjectType(a).typeType;
  e.registerConstant("google", "map<string, map<string, type>>", {
    protobuf: { Duration: u, Timestamp: c }
  });
  function l(d, p) {
    return new Date(d.toLocaleString("en-US", { timeZone: p }));
  }
  function f(d, p) {
    const y = p ? l(d, p) : new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()), x = new Date(y.getFullYear(), 0, 0);
    return BigInt(Math.floor((y - x) / 864e5) - 1);
  }
  t(`timestamp(string): ${o}`, (d) => {
    if (d.length < 20 || d.length > 30)
      throw new J("timestamp() requires a string in ISO 8601 format");
    const p = new Date(d);
    if (p <= 253402300799999 && p >= -621355968e5) return p;
    throw new J("timestamp() requires a string in ISO 8601 format");
  }), t(`timestamp(int): ${o}`, (d) => {
    if (d = Number(d) * 1e3, d <= 253402300799999 && d >= -621355968e5) return new Date(d);
    throw new J("timestamp() requires a valid integer unix timestamp");
  }), t(`${o}.getDate(): int`, (d) => BigInt(d.getUTCDate())), t(`${o}.getDate(string): int`, (d, p) => BigInt(l(d, p).getDate())), t(`${o}.getDayOfMonth(): int`, (d) => BigInt(d.getUTCDate() - 1)), t(
    `${o}.getDayOfMonth(string): int`,
    (d, p) => BigInt(l(d, p).getDate() - 1)
  ), t(`${o}.getDayOfWeek(): int`, (d) => BigInt(d.getUTCDay())), t(`${o}.getDayOfWeek(string): int`, (d, p) => BigInt(l(d, p).getDay())), t(`${o}.getDayOfYear(): int`, f), t(`${o}.getDayOfYear(string): int`, f), t(`${o}.getFullYear(): int`, (d) => BigInt(d.getUTCFullYear())), t(`${o}.getFullYear(string): int`, (d, p) => BigInt(l(d, p).getFullYear())), t(`${o}.getHours(): int`, (d) => BigInt(d.getUTCHours())), t(`${o}.getHours(string): int`, (d, p) => BigInt(l(d, p).getHours())), t(`${o}.getMilliseconds(): int`, (d) => BigInt(d.getUTCMilliseconds())), t(`${o}.getMilliseconds(string): int`, (d) => BigInt(d.getUTCMilliseconds())), t(`${o}.getMinutes(): int`, (d) => BigInt(d.getUTCMinutes())), t(`${o}.getMinutes(string): int`, (d, p) => BigInt(l(d, p).getMinutes())), t(`${o}.getMonth(): int`, (d) => BigInt(d.getUTCMonth())), t(`${o}.getMonth(string): int`, (d, p) => BigInt(l(d, p).getMonth())), t(`${o}.getSeconds(): int`, (d) => BigInt(d.getUTCSeconds())), t(`${o}.getSeconds(string): int`, (d, p) => BigInt(l(d, p).getSeconds()));
  const h = /(\d*\.?\d*)(ns|us|¬µs|ms|s|m|h)/;
  function g(d) {
    if (!d) throw new J("Invalid duration string: ''");
    const p = d[0] === "-";
    (d[0] === "-" || d[0] === "+") && (d = d.slice(1));
    let y = BigInt(0);
    for (; ; ) {
      const A = h.exec(d);
      if (!A) throw new J(`Invalid duration string: ${d}`);
      if (A.index !== 0) throw new J(`Invalid duration string: ${d}`);
      d = d.slice(A[0].length);
      const R = US[A[2]], [N = "0", F = ""] = A[1].split("."), w = BigInt(N) * R, K = F ? BigInt(F.slice(0, 13).padEnd(13, "0")) * R / 10000000000000n : 0n;
      if (y += w + K, d === "") break;
    }
    const x = y >= 1000000000n ? y / 1000000000n : 0n, S = Number(y % 1000000000n);
    return p ? new pa(-x, -S) : new pa(x, S);
  }
  t("duration(string): google.protobuf.Duration", (d) => g(d)), t("google.protobuf.Duration.getHours(): int", (d) => d.getHours()), t("google.protobuf.Duration.getMinutes(): int", (d) => d.getMinutes()), t("google.protobuf.Duration.getSeconds(): int", (d) => d.getSeconds()), t("google.protobuf.Duration.getMilliseconds(): int", (d) => d.getMilliseconds()), NS(e);
}
function Qh(e) {
  let t = 0;
  for (const n of e) t++;
  return t;
}
let ne = class {
  #t;
  constructor(t) {
    this.#t = t, Hr(this);
  }
  get name() {
    return this.#t;
  }
  get [Symbol.toStringTag]() {
    return `Type<${this.#t}>`;
  }
  toString() {
    return `Type<${this.#t}>`;
  }
};
const $e = {
  string: new ne("string"),
  bool: new ne("bool"),
  int: new ne("int"),
  uint: new ne("uint"),
  double: new ne("double"),
  map: new ne("map"),
  list: new ne("list"),
  bytes: new ne("bytes"),
  null_type: new ne("null"),
  type: new ne("type")
}, DS = new ne("optional");
let zw = class qw {
  #t = null;
  #e = null;
  constructor(t) {
    t instanceof qw ? (this.#t = t, this.#e = /* @__PURE__ */ new Map()) : this.#e = new Map(t);
  }
  fork(t = !0) {
    return t && (this.set = this.#n), new this.constructor(this);
  }
  #n() {
    throw new Error("Cannot modify frozen registry");
  }
  set(t, n) {
    return this.#e.set(t, n), this;
  }
  has(t) {
    return this.#e.has(t) || (this.#t ? this.#t.has(t) : !1);
  }
  get(t) {
    return this.#e.get(t) || this.#t?.get(t);
  }
  *#r() {
    this.#t && (yield* this.#t), yield* this.#e;
  }
  [Symbol.iterator]() {
    return this.#r();
  }
  get size() {
    return this.#e.size + (this.#t ? this.#t.size : 0);
  }
}, VS = class extends zw {
  get(t) {
    return super.get(t) ?? (Qa.has(t) ? void 0 : qe);
  }
};
function sr(e, t = zw, n = !0) {
  return e instanceof t ? e.fork(n) : new t(e);
}
let Wr = class {
  #t = /* @__PURE__ */ new WeakMap();
  #e = null;
  #n = null;
  constructor({ kind: t, type: n, name: r, keyType: i, valueType: s, values: o }) {
    this.kind = t, this.type = n, this.name = r, i && (this.keyType = i), s && (this.valueType = s), o && (this.values = o), this.unwrappedType = t === "dyn" && s ? s.unwrappedType : this, this.wrappedType = t === "dyn" ? this : Gw(this.unwrappedType), t === "list" ? this.fieldLazy = this.#a : t === "map" ? this.fieldLazy = this.#o : t === "message" ? this.fieldLazy = this.#i : t === "optional" && (this.fieldLazy = this.#r), this.#e = this.kind === "dyn" || this.valueType?.hasDyn() || this.keyType?.hasDyn() || !1, this.#n = this.kind === "param" || this.keyType?.hasPlaceholder() || this.valueType?.hasPlaceholder() || !1, Hr(this);
  }
  hasDyn() {
    return this.#e;
  }
  hasNoDynTypes() {
    return this.#e === !1;
  }
  isDynOrBool() {
    return this.type === "bool" || this.kind === "dyn";
  }
  isEmpty() {
    return this.valueType && this.valueType.kind === "param";
  }
  hasPlaceholder() {
    return this.#n;
  }
  unify(t, n) {
    const r = this;
    if (r === n || r.kind === "dyn" || n.kind === "param") return r;
    if (n.kind === "dyn" || r.kind === "param") return n;
    if (r.kind !== n.kind || !(r.hasPlaceholder() || n.hasPlaceholder() || r.hasDyn() || n.hasDyn())) return null;
    const i = r.valueType.unify(t, n.valueType);
    if (!i) return null;
    switch (r.kind) {
      case "optional":
        return t.getOptionalType(i);
      case "list":
        return t.getListType(i);
      case "map":
        const s = r.keyType.unify(t, n.keyType);
        return s ? t.getMapType(s, i) : null;
    }
  }
  templated(t, n) {
    if (!this.hasPlaceholder()) return this;
    switch (this.kind) {
      case "dyn":
        return this.valueType.templated(t, n);
      case "param":
        return n?.get(this.name) || this;
      case "map":
        return t.getMapType(this.keyType.templated(t, n), this.valueType.templated(t, n));
      case "list":
        return t.getListType(this.valueType.templated(t, n));
      case "optional":
        return t.getOptionalType(this.valueType.templated(t, n));
      default:
        return this;
    }
  }
  toString() {
    return this.name;
  }
  #r(t, n, r, i) {
    if (t = t instanceof hi ? t.orValue() : t, t === void 0) return Xa;
    const s = i.debugType(t);
    try {
      return hi.of(s.fieldLazy(t, n, r, i));
    } catch (o) {
      if (o instanceof J) return Xa;
      throw o;
    }
  }
  #i(t, n, r, i) {
    const s = i.objectTypesByConstructor.get(t.constructor);
    if (!s || !(t instanceof s.ctor)) return;
    if (!s.fields) return Vl(t, n) ? t[n] : void 0;
    const o = s.fields[n];
    if (!o) return;
    const a = t[n], c = i.debugType(a);
    switch (o) {
      case lt.dyn:
      case c:
        return a;
      default:
        if (o.matches(c)) return a;
    }
    throw new J(`Field '${n}' is not of type '${o}', got '${c}'`, r);
  }
  #o(t, n, r, i) {
    let s;
    if (t instanceof Map ? s = t.get(n) : s = Vl(t, n) ? t[n] : void 0, s === void 0) return;
    const o = this.valueType, a = i.debugType(s);
    if (o.matches(a)) return s;
    throw new J(`Field '${n}' is not of type '${o}', got '${a}'`, r);
  }
  #a(t, n, r, i) {
    if (!(typeof n == "number" || typeof n == "bigint")) return;
    const s = t[n];
    if (s === void 0)
      throw new J(
        `No such key: index out of bounds, index ${n} ${n < 0 ? "< 0" : `>= size ${t.length}`}`,
        r
      );
    const o = i.debugType(s);
    if (this.valueType.matches(o)) return s;
    throw new J(
      `List item with index '${n}' is not of type '${this.valueType}', got '${o}'`,
      r
    );
  }
  fieldLazy() {
  }
  field(t, n, r, i) {
    const s = this.fieldLazy(t, n, r, i);
    if (s !== void 0) return s;
    throw new J(`No such key: ${n}`, r);
  }
  matchesBoth(t) {
    return this.matches(t) && t.matches(this);
  }
  matches(t) {
    const n = this.unwrappedType;
    return t = t.unwrappedType, n === t || n.kind === "dyn" || t.kind === "dyn" || t.kind === "param" ? !0 : this.#t.get(t) ?? this.#t.set(t, this.#c(n, t)).get(t);
  }
  #c(t, n) {
    switch (t.kind) {
      case "dyn":
      case "param":
        return !0;
      case "list":
        return n.kind === "list" && t.valueType.matches(n.valueType);
      case "map":
        return n.kind === "map" && t.keyType.matches(n.keyType) && t.valueType.matches(n.valueType);
      case "optional":
        return n.kind === "optional" && t.valueType.matches(n.valueType);
      default:
        return t.name === n.name;
    }
  }
};
const MS = "have a .callAst property or .evaluate(checker, macro, ctx) method.", FS = "have a .callAst property or .typeCheck(checker, macro, ctx) method.";
function HS(e, t) {
  const n = `Macro '${e}' must`;
  return function(i) {
    const s = t(i);
    if (!s || typeof s != "object") throw new Error(`${n} return an object.`);
    if (s.callAst) return s;
    if (!s.evaluate) throw new Error(`${n} ${MS}`);
    if (!s.typeCheck) throw new Error(`${n} ${FS}`);
    return s;
  };
}
let WS = class {
  #t;
  constructor({ name: t, receiverType: n, argTypes: r, returnType: i, handler: s }) {
    this.name = t, this.receiverType = n || null, this.argTypes = r, this.returnType = i, this.macro = r.includes(ya);
    const o = n ? `${n}.` : "";
    this.signature = `${o}${t}(${r.join(", ")}): ${i}`, this.handler = this.macro ? HS(this.signature, s) : s, this.#t = this.returnType.hasPlaceholder() || this.receiverType?.hasPlaceholder() || this.argTypes.some((a) => a.hasPlaceholder()) || !1, Hr(this);
  }
  hasPlaceholder() {
    return this.#t;
  }
  matchesArgs(t) {
    return t.length === this.argTypes.length && this.argTypes.every((n, r) => n.matches(t[r])) ? this : null;
  }
}, Is = class {
  #t;
  constructor({ operator: t, leftType: n, rightType: r, handler: i, returnType: s }) {
    this.operator = t, this.leftType = n, this.rightType = r || null, this.handler = i, this.returnType = s, r ? this.signature = `${n} ${t} ${r}: ${s}` : this.signature = `${t}${n}: ${s}`, this.#t = this.leftType.hasPlaceholder() || this.rightType?.hasPlaceholder() || !1, Hr(this);
  }
  hasPlaceholder() {
    return this.#t;
  }
  equals(t) {
    return this.operator === t.operator && this.leftType === t.leftType && this.rightType === t.rightType;
  }
};
function sd(e) {
  return new Wr({
    kind: "list",
    name: `list<${e}>`,
    type: "list",
    valueType: e
  });
}
function _n(e) {
  return new Wr({ kind: "primitive", name: e, type: e });
}
function KS(e) {
  return new Wr({ kind: "message", name: e, type: e });
}
function Gw(e) {
  const t = e ? `dyn<${e}>` : "dyn";
  return new Wr({ kind: "dyn", name: t, type: t, valueType: e });
}
function Yw(e) {
  const t = `optional<${e}>`;
  return new Wr({ kind: "optional", name: t, type: "optional", valueType: e });
}
function od(e, t) {
  return new Wr({
    kind: "map",
    name: `map<${e}, ${t}>`,
    type: "map",
    keyType: e,
    valueType: t
  });
}
function jS(e) {
  return new Wr({ kind: "param", name: e, type: e });
}
const qe = Gw(), ya = _n("ast"), Jh = sd(qe), tp = od(qe, qe), lt = {
  string: _n("string"),
  bool: _n("bool"),
  int: _n("int"),
  uint: _n("uint"),
  double: _n("double"),
  bytes: _n("bytes"),
  dyn: qe,
  null: _n("null"),
  type: _n("type"),
  optional: Yw(qe),
  list: Jh,
  "list<dyn>": Jh,
  map: tp,
  "map<dyn, dyn>": tp
};
for (const e of [lt.string, lt.double, lt.int]) {
  const t = sd(e), n = od(lt.string, e);
  lt[t.name] = t, lt[n.name] = n;
}
Object.freeze(lt);
let zS = class {
  returnType = null;
  /** @type {Array<FunctionDeclaration>} */
  declarations = [];
  constructor(t) {
    this.registry = t;
  }
  add(t) {
    this.returnType = (this.returnType || t.returnType).unify(this.registry, t.returnType) || qe, t.macro && (this.macro = t), this.declarations.push(t);
  }
  findMatch(t, n = null) {
    for (let r = 0; r < this.declarations.length; r++) {
      const i = this.#t(this.declarations[r], t, n);
      if (i) return i;
    }
    return null;
  }
  #t(t, n, r) {
    if (t.hasPlaceholder()) return this.#e(t, n, r);
    if (!(r && t.receiverType && !r.matches(t.receiverType)))
      return t.matchesArgs(n);
  }
  #e(t, n, r) {
    const i = /* @__PURE__ */ new Map();
    if (r && t.receiverType && !this.registry.matchTypeWithPlaceholders(t.receiverType, r, i))
      return null;
    for (let s = 0; s < n.length; s++)
      if (!this.registry.matchTypeWithPlaceholders(t.argTypes[s], n[s], i))
        return null;
    return {
      handler: t.handler,
      signature: t.signature,
      returnType: t.returnType.templated(this.registry, i)
    };
  }
};
function ep(e) {
  const t = [];
  let n = "", r = 0;
  for (const i of e) {
    if (i === "<") r++;
    else if (i === ">") r--;
    else if (i === "," && r === 0) {
      t.push(n.trim()), n = "";
      continue;
    }
    n += i;
  }
  return n && t.push(n.trim()), t;
}
const Zw = [
  [void 0, "map", $e.map, lt.map],
  [Object, "map", $e.map, lt.map],
  [Map, "map", $e.map, lt.map],
  [Array, "list", $e.list, lt.list],
  [Qr, "uint", $e.uint, lt.uint],
  [ne, "type", $e.type, lt.type],
  [hi, "optional", DS, lt.optional],
  [Uint8Array, "bytes", $e.bytes, lt.bytes],
  ...typeof Buffer < "u" ? [[Buffer, "bytes", $e.bytes, lt.bytes]] : []
].map(([e, t, n, r]) => Object.freeze({ name: t, typeType: n, type: r, ctor: e })), qS = Zw.map((e) => [e.name, e]), GS = Zw.map((e) => [e.ctor, e]);
let YS = class Xw {
  #t = {};
  #e = {};
  #n;
  #r;
  #i;
  #o = /* @__PURE__ */ new Map();
  #a = /* @__PURE__ */ new Map();
  #c = /* @__PURE__ */ new Map();
  #f = /* @__PURE__ */ new Map();
  #h = /* @__PURE__ */ new Map();
  constructor(t = {}) {
    if (this.enableOptionalTypes = t.enableOptionalTypes ?? !1, this.objectTypes = sr(t.objectTypes || qS), this.objectTypesByConstructor = sr(t.objectTypesByConstructor || GS), this.#i = sr(t.functionDeclarations), this.#r = sr(t.operatorDeclarations), this.#n = sr(
      t.typeDeclarations || LS(lt),
      void 0,
      !1
    ), this.constants = sr(t.constants), this.variables = t.unlistedVariablesAreDyn ? sr(t.variables, VS) : sr(t.variables), this.variables.size)
      PS(this, this.enableOptionalTypes);
    else
      for (const n in $e) this.registerConstant(n, "type", $e[n]);
  }
  #p() {
    this.#t = {}, this.#e = {};
  }
  registerVariable(t, n) {
    if (Qa.has(t)) throw new Error(`Cannot register reserved variable name: ${t}`);
    if (this.variables.has(t)) throw new Error(`Variable already registered: ${t}`);
    return this.variables.set(t, n instanceof Wr ? n : this.getType(n)), this;
  }
  registerConstant(t, n, r) {
    return this.registerVariable(t, n), this.constants.set(t, r), this;
  }
  #g(t, n, r) {
    let i = t ? this.#a : this.#o;
    return i = i.get(n) || i.set(n, /* @__PURE__ */ new Map()).get(n), i.get(r) || i.set(r, new zS(this)).get(r);
  }
  getFunctionCandidates(t, n, r) {
    const i = (t ? this.#a : this.#o).get(n)?.get(r);
    if (i) return i;
    for (const [, s] of this.#i)
      this.#g(!!s.receiverType, s.name, s.argTypes.length).add(s);
    return this.#g(t, n, r);
  }
  getType(t) {
    return this.#s(t, !0);
  }
  getListType(t) {
    return this.#c.get(t) || this.#c.set(t, this.#s(`list<${t}>`, !0)).get(t);
  }
  getMapType(t, n) {
    return this.#f.get(t)?.get(n) || (this.#f.get(t) || this.#f.set(t, /* @__PURE__ */ new Map()).get(t)).set(n, this.#s(`map<${t}, ${n}>`, !0)).get(n);
  }
  getOptionalType(t) {
    return this.#h.get(t) || this.#h.set(t, this.#s(`optional<${t}>`, !0)).get(t);
  }
  assertType(t, n, r) {
    try {
      return this.#s(t, !0);
    } catch (i) {
      throw i.message = `Invalid ${n} '${i.unknownType || t}' in '${r}'`, i;
    }
  }
  getFunctionType(t) {
    return t === "ast" ? ya : this.#s(t, !0);
  }
  registerType(t, n) {
    if (typeof t == "object" && (n = t, t = n.fullName || n.name || n.ctor?.name), typeof t == "string" && t[0] === "." && (t = t.slice(1)), typeof t != "string" || t.length < 2 || Qa.has(t))
      throw new Error(`Message type name invalid: ${t}`);
    if (this.objectTypes.has(t)) throw new Error(`Message type already registered: ${t}`);
    const r = this.#s(t, !1);
    if (r.kind !== "message") throw new Error(`Message type invalid: ${t}`);
    const i = typeof n == "function" ? n : n?.ctor;
    if (typeof i != "function") throw new Error(`Message type constructor invalid: '${t}'`);
    const s = Object.freeze({
      name: t,
      typeType: new ne(t),
      type: r,
      ctor: i,
      fields: this.#v(t, n?.fields)
    });
    return this.objectTypes.set(t, s), this.objectTypesByConstructor.set(i, s), this.registerFunctionOverload(`type(${t}): type`, () => s.typeType), this;
  }
  getObjectType(t) {
    return this.objectTypes.get(t);
  }
  /** @returns {TypeDeclaration} */
  #s(t, n = !0) {
    let r = this.#n.get(t);
    if (r) return r;
    if (r = t.match(/^[A-Z]$/), r) return this.#u(jS, t, t);
    if (r = t.match(/^(dyn|list|map|optional)<(.+)>$/), !r) {
      if (n) {
        const o = new Error(`Unknown type: ${t}`);
        throw o.unknownType = t, o;
      }
      return this.#u(KS, t, t);
    }
    const i = r[1], s = r[2].trim();
    switch (i) {
      case "dyn": {
        const o = this.#s(s, n).wrappedType;
        return this.#n.set(o.name, o), o;
      }
      case "list": {
        const o = this.#s(s, n);
        return this.#u(sd, `list<${o}>`, o);
      }
      case "map": {
        const o = ep(s);
        if (o.length !== 2) throw new Error(`Invalid map type: ${t}`);
        const a = this.#s(o[0], n), c = this.#s(o[1], n);
        return this.#u(od, `map<${a}, ${c}>`, a, c);
      }
      case "optional": {
        const o = this.#s(s, n);
        return this.#u(Yw, `optional<${o}>`, o);
      }
    }
  }
  #u(t, n, ...r) {
    return this.#n.get(n) || this.#n.set(n, t(...r)).get(n);
  }
  findMacro(t, n, r) {
    return this.getFunctionCandidates(n, t, r).macro || !1;
  }
  #y(t, n, r) {
    const i = [], s = n.unwrappedType, o = r.unwrappedType;
    for (const [, a] of this.#r) {
      if (a.operator !== t) continue;
      if (a.leftType === s && a.rightType === o) return [a];
      if (a.leftType === n && a.rightType === r) return [a];
      const c = this.#E(a, n, r);
      c && i.push(c);
    }
    return i.length === 0 && (t === "==" || t === "!=") && (n.kind === "dyn" || r.kind === "dyn") ? [{ handler: t === "==" ? (c, u) => c === u : (c, u) => c !== u, returnType: this.getType("bool") }] : i;
  }
  findUnaryOverload(t, n) {
    const r = this.#t[t]?.get(n);
    if (r !== void 0) return r;
    let i = !1;
    for (const [, s] of this.#r)
      if (!(s.operator !== t || s.leftType !== n)) {
        i = s;
        break;
      }
    return (this.#t[t] ??= /* @__PURE__ */ new Map()).set(n, i).get(n);
  }
  findBinaryOverload(t, n, r) {
    return this.#t[t]?.get(n)?.get(r) ?? this.#w(
      this.#t,
      t,
      n,
      r,
      this.#m(t, n, r)
    );
  }
  checkBinaryOverload(t, n, r) {
    return this.#e[t]?.get(n)?.get(r) ?? this.#w(
      this.#e,
      t,
      n,
      r,
      this.#b(t, n, r)
    );
  }
  #m(t, n, r) {
    const i = this.#y(t, n, r);
    if (i.length === 0) return !1;
    if (i.length === 1) return i[0];
    throw new Error(`Operator overload '${i[0].signature}' overlaps with '${i[1].signature}'.`);
  }
  #b(t, n, r) {
    const i = this.#y(t, n, r);
    if (i.length === 0) return !1;
    const s = i[0].returnType;
    return i.every((o) => o.returnType === s) ? s : (s.kind === "list" || s.kind === "map") && i.every((o) => o.returnType.kind === s.kind) ? s.kind === "list" ? lt.list : lt.map : lt.dyn;
  }
  #w(t, n, r, i, s) {
    const o = t[n] ??= /* @__PURE__ */ new Map();
    return (o.get(r) || o.set(r, /* @__PURE__ */ new Map()).get(r)).set(i, s), s;
  }
  #E(t, n, r) {
    const i = t.hasPlaceholder() ? /* @__PURE__ */ new Map() : null, s = this.matchTypeWithPlaceholders(t.leftType, n, i);
    if (!s) return;
    const o = this.matchTypeWithPlaceholders(t.rightType, r, i);
    if (o)
      return (t.operator === "==" || t.operator === "!=") && !s.matchesBoth(o) ? !1 : t.hasPlaceholder() ? {
        handler: t.handler,
        leftType: s,
        rightType: o,
        returnType: t.returnType.templated(this, i)
      } : t;
  }
  matchTypeWithPlaceholders(t, n, r) {
    if (!t.hasPlaceholder()) return n.matches(t) ? n : null;
    const i = n.kind === "dyn";
    return this.#l(t, n, r, i) && (i || n.matches(t.templated(this, r))) ? n : null;
  }
  #x(t, n, r) {
    const i = r.get(t);
    return i ? i.kind === "dyn" || n.kind === "dyn" ? !0 : i.matchesBoth(n) : r.set(t, n) && !0;
  }
  #l(t, n, r, i = !1) {
    if (!t.hasPlaceholder()) return !0;
    if (!n) return !1;
    const s = i || n.kind === "dyn";
    switch (n = n.unwrappedType, t.kind) {
      case "param": {
        const o = s ? lt.dyn : n;
        return this.#x(t.name, o, r);
      }
      case "list":
        return n.name === "dyn" && (n = t), n.kind !== "list" ? !1 : this.#l(
          t.valueType,
          n.valueType,
          r,
          s
        );
      case "map":
        return n.name === "dyn" && (n = t), n.kind !== "map" ? !1 : this.#l(
          t.keyType,
          n.keyType,
          r,
          s
        ) && this.#l(
          t.valueType,
          n.valueType,
          r,
          s
        );
      case "optional":
        return n.name === "dyn" && (n = t), n.kind !== "optional" ? !1 : this.#l(
          t.valueType,
          n.valueType,
          r,
          s
        );
    }
    return !0;
  }
  #T(t) {
    return typeof t == "string" ? { type: t } : t.id ? QS(t) : t;
  }
  #S(t, n, r, i = !1) {
    try {
      const s = this.#T(n[r]);
      if (typeof s?.type != "string") throw new Error("unsupported declaration");
      return this.#s(s.type, i);
    } catch (s) {
      throw s.message = `Field '${r}' in type '${t}' has unsupported declaration: ${JSON.stringify(n[r])}`, s;
    }
  }
  #v(t, n) {
    if (!n) return;
    const r = /* @__PURE__ */ Object.create(null);
    for (const i of kn(n)) r[i] = this.#S(t, n, i);
    return r;
  }
  clone(t) {
    return new Xw({
      objectTypes: this.objectTypes,
      objectTypesByConstructor: this.objectTypesByConstructor,
      typeDeclarations: this.#n,
      operatorDeclarations: this.#r,
      functionDeclarations: this.#i,
      variables: this.variables,
      constants: this.constants,
      unlistedVariablesAreDyn: t.unlistedVariablesAreDyn,
      enableOptionalTypes: t.enableOptionalTypes
    });
  }
  /** @param {string} signature */
  #k(t, n) {
    const r = t.match(/^(?:([a-zA-Z0-9.<>]+)\.)?(\w+)\((.*?)\):\s*(.+)$/);
    if (!r) throw new Error(`Invalid signature: ${t}`);
    const [, i, s, o, a] = r;
    try {
      return new WS({
        name: s,
        receiverType: i ? this.getType(i) : null,
        returnType: this.getType(a.trim()),
        argTypes: ep(o).map((c) => this.getFunctionType(c)),
        handler: n
      });
    } catch (c) {
      throw new Error(`Invalid function declaration: ${t}: ${c.message}`);
    }
  }
  /**
   * @param {FunctionDeclaration} a
   * @param {FunctionDeclaration} b
   */
  #A(t, n) {
    return t.name !== n.name || t.argTypes.length !== n.argTypes.length || (t.receiverType || n.receiverType) && (!t.receiverType || !n.receiverType) ? !1 : !(t.receiverType !== n.receiverType && t.receiverType !== qe && n.receiverType !== qe) && (n.macro || t.macro || n.argTypes.every((i, s) => {
      const o = t.argTypes[s];
      return i === o || i === ya || o === ya || i === qe || o === qe;
    }));
  }
  /** @param {FunctionDeclaration} newDec */
  #$(t) {
    for (const [, n] of this.#i)
      if (this.#A(n, t))
        throw new Error(
          `Function signature '${t.signature}' overlaps with existing overload '${n.signature}'.`
        );
  }
  registerFunctionOverload(t, n) {
    const r = typeof n == "function" ? n : n?.handler, i = this.#k(t, r);
    this.#$(i), this.#i.set(i.signature, i), this.#a.clear(), this.#o.clear();
  }
  registerOperatorOverload(t, n) {
    const r = t.match(/^([-!])([\w.<>]+)(?::\s*([\w.<>]+))?$/);
    if (r) {
      const [, u, l, f] = r;
      return this.unaryOverload(u, l, n, f);
    }
    const i = t.match(
      /^([\w.<>]+) ([-+*%/]|==|!=|<|<=|>|>=|in) ([\w.<>]+)(?::\s*([\w.<>]+))?$/
    );
    if (!i) throw new Error(`Operator overload invalid: ${t}`);
    const [, s, o, a, c] = i;
    return this.binaryOverload(s, o, a, n, c);
  }
  unaryOverload(t, n, r, i) {
    const s = this.assertType(n, "type", `${t}${n}`), o = this.assertType(
      i || n,
      "return type",
      `${t}${n}: ${i || n}`
    ), a = new Is({ operator: `${t}_`, leftType: s, returnType: o, handler: r });
    if (this.#d(a))
      throw new Error(`Operator overload already registered: ${t}${n}`);
    this.#r.set(a.signature, a), this.#p();
  }
  #d(t) {
    for (const [, n] of this.#r) if (t.equals(n)) return !0;
    return !1;
  }
  binaryOverload(t, n, r, i, s) {
    s ??= np(n) ? "bool" : t;
    const o = `${t} ${n} ${r}: ${s}`, a = this.assertType(t, "left type", o), c = this.assertType(r, "right type", o), u = this.assertType(s, "return type", o);
    if (np(n) && u.type !== "bool")
      throw new Error(`Comparison operator '${n}' must return 'bool', got '${u.type}'`);
    const l = new Is({ operator: n, leftType: a, rightType: c, returnType: u, handler: i });
    if (l.hasPlaceholder() && !(c.hasPlaceholder() && a.hasPlaceholder()))
      throw new Error(
        `Operator overload with placeholders must use them in both left and right types: ${o}`
      );
    if (this.#d(l))
      throw new Error(`Operator overload already registered: ${l.signature}`);
    if (n === "==") {
      const f = [
        new Is({
          operator: "!=",
          leftType: a,
          rightType: c,
          handler(h, g, d, p) {
            return !i(h, g, d, p);
          },
          returnType: u
        })
      ];
      a !== c && f.push(
        new Is({
          operator: "==",
          leftType: c,
          rightType: a,
          handler(h, g, d, p) {
            return i(g, h, d, p);
          },
          returnType: u
        }),
        new Is({
          operator: "!=",
          leftType: c,
          rightType: a,
          handler(h, g, d, p) {
            return !i(g, h, d, p);
          },
          returnType: u
        })
      );
      for (const h of f)
        if (this.#d(h))
          throw new Error(`Operator overload already registered: ${h.signature}`);
      for (const h of f) this.#r.set(h.signature, h);
    }
    this.#r.set(l.signature, l), this.#p();
  }
};
function np(e) {
  return e === "<" || e === "<=" || e === ">" || e === ">=" || e === "==" || e === "!=" || e === "in";
}
function ZS(e) {
  return new YS(e);
}
let rp = class {
  #t;
  #e;
  #n;
  constructor(t, n) {
    if (this.#t = t.variables, this.#e = t.constants, n != null) {
      if (typeof n != "object") throw new J("Context must be an object");
      this.#n = n, n instanceof Map ? this.getValue = this.#i : this.getValue = this.#r;
    }
  }
  #r(t) {
    const n = this.#n[t];
    return n !== void 0 ? n : this.#e.get(t);
  }
  #i(t) {
    const n = this.#n.get(t);
    return n !== void 0 ? n : this.#t.get(t);
  }
  getType(t) {
    return this.#t.get(t);
  }
  getValue(t) {
    return this.#e.get(t);
  }
  forkWithVariable(t, n) {
    return new XS(this, t, n);
  }
}, XS = class Ml {
  #t;
  accuType;
  accuValue;
  iterValue;
  constructor(t, n, r) {
    this.#t = t, this.iterVar = n, this.iterType = r;
  }
  forkWithVariable(t, n) {
    return new Ml(this, t, n);
  }
  reuse(t) {
    if (!this.async) return (this.#t = t) && this;
    const n = new Ml(t, this.iterVar, this.iterType);
    return n.accuType = this.accuType, n;
  }
  setIterValue(t) {
    return this.iterValue = t, this;
  }
  setAccuType(t) {
    return this.accuType = t, this;
  }
  setAccuValue(t) {
    return this.accuValue = t, this;
  }
  getValue(t) {
    return this.iterVar === t ? this.iterValue : this.#t.getValue(t);
  }
  getType(t) {
    return this.iterVar === t ? this.iterType : this.#t.getType(t);
  }
};
function QS(e) {
  let t;
  if (e.map) {
    const n = Lu(e.keyType, e.resolvedKeyType), r = Lu(e.type, e.resolvedType);
    t = `map<${n}, ${r}>`;
  } else
    t = Lu(e.type, e.resolvedType);
  return { type: e.repeated ? `list<${t}>` : t };
}
function Lu(e, t) {
  switch (e) {
    case "string":
      return "string";
    case "bytes":
      return "bytes";
    case "bool":
      return "bool";
    // protobufjs uses JavaScript numbers for all numeric types
    case "double":
    case "float":
    case "int32":
    case "int64":
    case "sint32":
    case "sint64":
    case "sfixed32":
    case "sfixed64":
    case "uint32":
    case "uint64":
    case "fixed32":
    case "fixed64":
      return "double";
    default:
      switch (t?.constructor.name) {
        case "Type":
          return t.fullName.slice(1);
        case "Enum":
          return "int";
      }
      return e?.includes(".") ? e : "dyn";
  }
}
let Qw = class {
  dynType = lt.dyn;
  optionalType = lt.optional;
  stringType = lt.string;
  intType = lt.int;
  doubleType = lt.double;
  boolType = lt.bool;
  nullType = lt.null;
  listType = lt.list;
  mapType = lt.map;
  constructor(t) {
    this.opts = t.opts, this.objectTypes = t.objectTypes, this.objectTypesByConstructor = t.objectTypesByConstructor, this.registry = t.registry;
  }
  /**
   * Get a TypeDeclaration instance for a type name
   * @param {string} typeName - The type name (e.g., 'string', 'int', 'dyn')
   * @returns {TypeDeclaration} The type declaration instance
   */
  getType(t) {
    return this.registry.getType(t);
  }
  debugType(t) {
    switch (typeof t) {
      case "string":
        return this.stringType;
      case "bigint":
        return this.intType;
      case "number":
        return this.doubleType;
      case "boolean":
        return this.boolType;
      case "object":
        if (t === null) return this.nullType;
        switch (t.constructor) {
          case void 0:
          case Object:
          case Map:
            return this.mapType;
          case Array:
          case Set:
            return this.listType;
          default:
            return this.objectTypesByConstructor.get(t.constructor)?.type || ip(this, t.constructor?.name || typeof t);
        }
      default:
        ip(this, typeof t);
    }
  }
};
function ip(e, t) {
  throw new e.Error(`Unsupported type: ${t}`);
}
function wa(e, t, n, r, i) {
  return n instanceof Promise ? r instanceof Promise ? Promise.all([n, r]).then((s) => i(e, t, s[0], s[1])) : n.then((s) => i(e, t, s, r)) : r.then((s) => i(e, t, n, s));
}
function sp(e, t, n) {
  const r = e.check(t.args[0], n);
  return t.op === "[]" && e.check(t.args[1], n), r.kind !== "optional" ? e.checkAccessOnType(t, n, r) : e.registry.getOptionalType(e.checkAccessOnType(t, n, r.valueType, !0));
}
function op(e, t, n) {
  const r = e.check(t.args[0], n);
  t.op === "[?]" && e.check(t.args[1], n);
  const i = r.kind === "optional" ? r.valueType : r;
  return e.registry.getOptionalType(e.checkAccessOnType(t, n, i, !0));
}
function ap(e, t, n, r, i) {
  const s = e.check(r, t);
  if (s === n || n.isEmpty()) return s;
  if (s.isEmpty()) return n;
  let o;
  throw i === 0 ? o = "List elements must have the same type," : i === 1 ? o = "Map key uses wrong type," : i === 2 && (o = "Map value uses wrong type,"), new e.Error(
    `${o} expected type '${e.formatType(n)}' but found '${e.formatType(s)}'`,
    r
  );
}
function cp(e, t, n, r) {
  return n.unify(e.registry, e.check(r, t)) || e.dynType;
}
function JS(e, t, n) {
  const r = e.debugRuntimeType(t, n.checkedType);
  return new e.Error(`${n.meta.label || "Ternary condition must be bool"}, got '${r}'`, n);
}
function up(e, t, n, r) {
  if (r === !0) return e.eval(t.args[1], n);
  if (r === !1) return e.eval(t.args[2], n);
  throw JS(e, r, t.args[0]);
}
function lp(e, t, n) {
  if (t.staticHandler) return t.staticHandler.handler(n, t, e);
  const r = e.debugRuntimeType(n, t.args.checkedType), i = e.registry.findUnaryOverload(t.op, r);
  if (i) return i.handler(n);
  throw new e.Error(`no such overload: ${t.op[0]}${r}`, t);
}
function fp(e, t, n) {
  const r = e.eval(t.args, n);
  return r instanceof Promise ? r.then((i) => lp(e, t, i)) : lp(e, t, r);
}
function dp(e, t, n, r) {
  if (t.staticHandler) return t.staticHandler.handler(n, r, t, e);
  const i = e.debugOperandType(n, t.args[0].checkedType), s = e.debugOperandType(r, t.args[1].checkedType), o = e.registry.findBinaryOverload(t.op, i, s);
  if (o) return o.handler(n, r, t, e);
  throw new e.Error(`no such overload: ${i} ${t.op} ${s}`, t);
}
function ad(e, t, n) {
  const r = e.debugRuntimeType(t, n.checkedType);
  return new e.Error(`Logical operator requires bool operands, got '${r}'`, n);
}
function Jw(e, t, n) {
  return t instanceof Error ? t : ad(e, t, n);
}
function Ai(e, t, n, r, i) {
  if (i === e) return e;
  if (i === !e) {
    if (r === i) return i;
    throw Jw(t, r, n.args[0]);
  }
  if (i instanceof Promise) return i.then((s) => tv(e, t, n, r, s));
  throw ad(t, i, n.args[1]);
}
function tv(e, t, n, r, i) {
  if (i === e) return e;
  if (typeof i != "boolean") throw ad(t, i, n.args[1]);
  if (typeof r != "boolean") throw Jw(t, r, n.args[0]);
  return !e;
}
function hp(e, t, n) {
  const r = e.check(t.args[0], n), i = e.check(t.args[1], n);
  if (!r.isDynOrBool())
    throw new e.Error(
      `Logical operator requires bool operands, got '${e.formatType(r)}'`,
      t
    );
  if (!i.isDynOrBool())
    throw new e.Error(
      `Logical operator requires bool operands, got '${e.formatType(i)}'`,
      t
    );
  return e.boolType;
}
function pp(e, t, n) {
  const r = t.op, i = e.check(t.args, n);
  if (i.kind === "dyn") return r === "!_" ? e.boolType : i;
  const s = e.registry.findUnaryOverload(r, i);
  if (!s) throw new e.Error(`no such overload: ${r[0]}${e.formatType(i)}`, t);
  return (t.staticHandler = s).returnType;
}
function ev(e, t, n) {
  const r = t.op, i = e.check(t.args[0], n), s = e.check(t.args[1], n);
  i.hasDyn() || s.hasDyn() || (t.staticHandler = e.registry.findBinaryOverload(r, i, s));
  const o = t.staticHandler?.returnType || e.registry.checkBinaryOverload(r, i, s);
  if (o) return o;
  throw new e.Error(
    `no such overload: ${e.formatType(i)} ${r} ${e.formatType(s)}`,
    t
  );
}
function nv(e, t, n) {
  const r = t.args, i = e.eval(r[0], n), s = e.eval(r[1], n);
  return i instanceof Promise || s instanceof Promise ? wa(e, t, i, s, dp) : dp(e, t, i, s);
}
function gp(e, t, n) {
  if (t.staticHandler) return t.staticHandler.handler.apply(e, n);
  const [r, i] = t.args, s = i.length, o = t.functionCandidates ??= e.registry.getFunctionCandidates(
    !1,
    r,
    s
  ), a = t.argTypes ??= new Array(s);
  let c = s;
  for (; c--; ) a[c] = e.debugOperandType(n[c], i[c].checkedType);
  const u = o.findMatch(a);
  if (u) return u.handler.apply(e, n);
  throw new e.Error(
    `found no matching overload for '${r}(${a.map((l) => l.unwrappedType).join(", ")})'`,
    t
  );
}
function yp(e, t, n, r) {
  if (t.staticHandler) return t.staticHandler.handler.call(e, n, ...r);
  const [i, s, o] = t.args, a = t.functionCandidates ??= e.registry.getFunctionCandidates(
    !0,
    i,
    o.length
  );
  let c = r.length;
  const u = t.argTypes ??= new Array(c);
  for (; c--; ) u[c] = e.debugOperandType(r[c], o[c].checkedType);
  const l = e.debugRuntimeType(n, s.checkedType || e.dynType), f = a.findMatch(u, l);
  if (f) return f.handler.call(e, n, ...r);
  throw new e.Error(
    `found no matching overload for '${l.type}.${i}(${u.map((h) => h.unwrappedType).join(", ")})'`,
    t
  );
}
function Uu(e, t, n, r = t.length) {
  if (r === 0) return [];
  let i;
  const s = new Array(r);
  for (; r--; ) (s[r] = e.eval(t[r], n)) instanceof Promise && (i ??= !0);
  return i ? Promise.all(s) : s;
}
function wp(e) {
  const t = {};
  for (let n = 0; n < e.length; n++) {
    const [r, i] = e[n];
    r === "__proto__" || r === "constructor" || r === "prototype" || (t[r] = i);
  }
  return t;
}
function rv(e, t, n) {
  const r = e.check(t, n);
  if (r.kind === "dyn") return r;
  if (r.kind === "list") return r.valueType;
  if (r.kind === "map") return r.keyType;
  throw new e.Error(
    `Expression of type '${e.formatType(
      r
    )}' cannot be range of a comprehension (must be list, map, or dynamic).`,
    t
  );
}
function iv(e, t, n) {
  if (n instanceof Set) return [...n];
  if (n instanceof Map) return [...n.keys()];
  if (n && typeof n == "object") return kn(n);
  throw new e.Error(
    `Expression of type '${e.debugType(
      n
    )}' cannot be range of a comprehension (must be list, map, or dynamic).`,
    t.iterable
  );
}
function mp(e, t, n, r) {
  ha(r) || (r = iv(e, t, r));
  const i = e.eval(t.init, n = t.iterCtx.reuse(n)), s = t.errorsAreFatal ? tm : nm;
  return (n === t.iterCtx ? s : s.async)(e, n, t, r, n.accuValue = i, 0);
}
function tm(e, t, n, r, i, s) {
  const o = n.condition, a = n.step, c = r.length;
  for (; s < c && !(o && !o(i)); )
    if (i = e.eval(a, t.setIterValue(r[s++])), i instanceof Promise) return em(e, t, n, r, i, s);
  return n.result(i);
}
async function em(e, t, n, r, i, s) {
  t === n.iterCtx && (t.async = !0);
  const o = n.condition, a = n.step, c = r.length;
  for (i = await i; s < c; ) {
    if (o && !o(i)) return n.result(i);
    i = e.eval(a, t.setIterValue(r[s++])), i instanceof Promise && (i = await i);
  }
  return n.result(i);
}
function nm(e, t, n, r, i, s, o, a) {
  const c = n.condition, u = n.step, l = r.length;
  for (; s < l; ) {
    if (!c(i)) return n.result(i);
    if (a = e.tryEval(u, t.setIterValue(r[s++])), a instanceof Promise) return rm(e, t, n, r, i, s, o, a);
    a instanceof Error && (o ??= a) || (i = a);
  }
  if (o && c(i)) throw o;
  return n.result(i);
}
async function rm(e, t, n, r, i, s, o, a) {
  t === n.iterCtx && (t.async = !0);
  const c = n.condition, u = n.step, l = r.length;
  for (a = await a, a instanceof Error ? o ??= a : i = a; s < l; ) {
    if (!c(i)) return n.result(i);
    a = e.tryEval(u, t.setIterValue(r[s++])), a instanceof Promise && (a = await a), !(a instanceof Error && (o ??= a)) && (i = a);
  }
  if (o && c(i)) throw o;
  return n.result(i);
}
tm.async = em;
nm.async = rm;
function _o(e, t, n, r) {
  return e.optionalType.field(n, r, t, e);
}
function Do(e, t, n, r) {
  return e.debugType(n).field(n, r, t, e);
}
const Z = {
  value: {
    check(e, t) {
      return e.debugType(t.args);
    },
    evaluate(e, t) {
      return t.args;
    }
  },
  id: {
    check(e, t, n) {
      const r = n.getType(t.args);
      if (r !== void 0) return r;
      throw new e.Error(`Unknown variable: ${t.args}`, t);
    },
    evaluate(e, t, n) {
      const r = t.checkedType || n.getType(t.args), i = r && n.getValue(t.args);
      if (i === void 0) throw new e.Error(`Unknown variable: ${t.args}`, t);
      const s = e.debugType(i);
      switch (r) {
        case s:
        case lt.dyn:
          return i;
        default:
          if (r.matches(s)) return i;
      }
      throw new e.Error(`Variable '${t.args}' is not of type '${r}', got '${s}'`, t);
    }
  },
  ".": {
    alias: "fieldAccess",
    check: sp,
    evaluate(e, t, n) {
      const r = t.args, i = e.eval(r[0], n);
      return i instanceof Promise ? i.then((s) => Do(e, t, s, r[1])) : Do(e, t, i, r[1]);
    }
  },
  ".?": {
    alias: "optionalFieldAccess",
    check: op,
    evaluate(e, t, n) {
      const r = t.args, i = e.eval(r[0], n);
      return i instanceof Promise ? i.then((s) => _o(e, t, s, r[1])) : _o(e, t, i, r[1]);
    }
  },
  "[]": {
    alias: "bracketAccess",
    check: sp,
    evaluate(e, t, n) {
      const r = t.args, i = e.eval(r[0], n), s = e.eval(r[1], n);
      return i instanceof Promise || s instanceof Promise ? wa(e, t, i, s, Do) : Do(e, t, i, s);
    }
  },
  "[?]": {
    alias: "optionalBracketAccess",
    check: op,
    evaluate(e, t, n) {
      const r = t.args, i = e.eval(r[0], n), s = e.eval(r[1], n);
      return i instanceof Promise || s instanceof Promise ? wa(e, t, i, s, _o) : _o(e, t, i, s);
    }
  },
  call: {
    check(e, t, n) {
      const [r, i] = t.args, s = t.functionCandidates ??= e.registry.getFunctionCandidates(
        !1,
        r,
        i.length
      ), o = i.map((c) => e.check(c, n)), a = s.findMatch(o);
      if (!a)
        throw new e.Error(
          `found no matching overload for '${r}(${e.formatTypeList(o)})'`,
          t
        );
      return o.some((c) => c.hasDyn()) || (t.staticHandler = a), a.returnType;
    },
    evaluate(e, t, n) {
      const r = Uu(e, t.args[1], n);
      return r instanceof Promise ? r.then((i) => gp(e, t, i)) : gp(e, t, r);
    }
  },
  rcall: {
    check(e, t, n) {
      const [r, i, s] = t.args, o = e.check(i, n), a = t.functionCandidates ??= e.registry.getFunctionCandidates(
        !0,
        r,
        s.length
      ), c = s.map((l) => e.check(l, n));
      if (o.kind === "dyn" && a.returnType) return a.returnType;
      const u = a.findMatch(c, o);
      if (!u)
        throw new e.Error(
          `found no matching overload for '${o.type}.${r}(${e.formatTypeList(
            c
          )})'`,
          t
        );
      return !o.hasPlaceholder() && !c.some((l) => l.hasDyn()) && (t.staticHandler = u), u.returnType;
    },
    evaluate(e, t, n) {
      const r = e.eval(t.args[1], n), i = Uu(e, t.args[2], n);
      return r instanceof Promise || i instanceof Promise ? wa(e, t, r, i, yp) : yp(e, t, r, i);
    }
  },
  list: {
    check(e, t, n) {
      const r = t.args, i = r.length;
      if (i === 0) return e.getType("list<T>");
      let s = e.check(r[0], n);
      const o = e.opts.homogeneousAggregateLiterals ? ap : cp;
      for (let a = 1; a < i; a++) s = o(e, n, s, r[a], 0);
      return e.registry.getListType(s);
    },
    evaluate(e, t, n) {
      return Uu(e, t.args, n);
    }
  },
  map: {
    check(e, t, n) {
      const r = t.args, i = r.length;
      if (i === 0) return e.getType("map<K, V>");
      const s = e.opts.homogeneousAggregateLiterals ? ap : cp;
      let o = e.check(r[0][0], n), a = e.check(r[0][1], n);
      for (let c = 1; c < i; c++) {
        const u = r[c];
        o = s(e, n, o, u[0], 1), a = s(e, n, a, u[1], 2);
      }
      return e.registry.getMapType(o, a);
    },
    evaluate(e, t, n) {
      const r = t.args, i = r.length, s = new Array(i);
      let o;
      for (let a = 0; a < i; a++) {
        const c = r[a], u = e.eval(c[0], n), l = e.eval(c[1], n);
        u instanceof Promise || l instanceof Promise ? (s[a] = Promise.all([u, l]), o ??= !0) : s[a] = [u, l];
      }
      return o ? Promise.all(s).then(wp) : wp(s);
    }
  },
  comprehension: {
    check(e, t, n) {
      const r = t.args;
      r.iterCtx = n.forkWithVariable(r.iterVarName, rv(e, r.iterable, n)).setAccuType(e.check(r.init, n));
      const i = e.check(r.step, r.iterCtx);
      return r.kind === "quantifier" ? e.boolType : i;
    },
    evaluate(e, t, n) {
      const r = t.args, i = e.eval(r.iterable, n);
      return i instanceof Promise ? i.then((s) => mp(e, r, n, s)) : mp(e, r, n, i);
    }
  },
  accuValue: {
    check(e, t, n) {
      return n.accuType;
    },
    evaluate(e, t, n) {
      return n.accuValue;
    }
  },
  accuInc: {
    check(e, t, n) {
      return n.accuType;
    },
    evaluate(e, t, n) {
      return n.accuValue += 1;
    }
  },
  accuPush: {
    check(e, t, n) {
      const r = n.accuType, i = e.check(t.args, n);
      return r.kind === "list" && r.valueType.kind !== "param" ? r : e.registry.getListType(i);
    },
    evaluate(e, t, n) {
      const r = n.accuValue, i = e.eval(t.args, n);
      return i instanceof Promise ? i.then((s) => r.push(s) && r) : (r.push(i), r);
    }
  },
  "?:": {
    alias: "ternary",
    check(e, t, n) {
      const [r, i, s] = t.args, o = e.check(r, n);
      if (!o.isDynOrBool())
        throw new e.Error(
          `${r.meta.label || "Ternary condition must be bool"}, got '${e.formatType(o)}'`,
          r
        );
      const a = e.check(i, n), c = e.check(s, n), u = a.unify(e.registry, c);
      if (u) return u;
      throw new e.Error(
        `Ternary branches must have the same type, got '${e.formatType(
          a
        )}' and '${e.formatType(c)}'`,
        t
      );
    },
    evaluate(e, t, n) {
      const r = e.eval(t.args[0], n);
      return r instanceof Promise ? r.then((i) => up(e, t, n, i)) : up(e, t, n, r);
    }
  },
  "||": {
    check: hp,
    evaluate(e, t, n) {
      const r = t.args, i = e.tryEval(r[0], n);
      if (i === !0) return !0;
      if (i === !1) {
        const s = e.eval(r[1], n);
        return typeof s == "boolean" ? s : Ai(!0, e, t, i, s);
      }
      return i instanceof Promise ? i.then(
        (s) => s === !0 ? s : Ai(!0, e, t, s, e.eval(r[1], n))
      ) : Ai(!0, e, t, i, e.eval(r[1], n));
    }
  },
  "&&": {
    check: hp,
    evaluate(e, t, n) {
      const r = t.args, i = e.tryEval(r[0], n);
      if (i === !1) return !1;
      if (i === !0) {
        const s = e.eval(r[1], n);
        return typeof s == "boolean" ? s : Ai(!1, e, t, i, s);
      }
      return i instanceof Promise ? i.then(
        (s) => s === !1 ? s : Ai(!1, e, t, s, e.eval(r[1], n))
      ) : Ai(!1, e, t, i, e.eval(r[1], n));
    }
  },
  "!_": { alias: "unaryNot", check: pp, evaluate: fp },
  "-_": { alias: "unaryMinus", check: pp, evaluate: fp }
}, sv = ["!=", "==", "in", "+", "-", "*", "/", "%", "<", "<=", ">", ">="];
for (const e of sv) Z[e] = { check: ev, evaluate: nv };
for (const e of kn(Z)) {
  const t = Z[e];
  t.name = e, t.alias && (Z[t.alias] = t);
}
const V = {
  EOF: 0,
  NUMBER: 1,
  STRING: 2,
  BOOLEAN: 3,
  NULL: 4,
  IDENTIFIER: 5,
  PLUS: 6,
  MINUS: 7,
  MULTIPLY: 8,
  DIVIDE: 9,
  MODULO: 10,
  EQ: 11,
  NE: 12,
  LT: 13,
  LE: 14,
  GT: 15,
  GE: 16,
  AND: 17,
  OR: 18,
  NOT: 19,
  IN: 20,
  LPAREN: 21,
  RPAREN: 22,
  LBRACKET: 23,
  RBRACKET: 24,
  LBRACE: 25,
  RBRACE: 26,
  DOT: 27,
  COMMA: 28,
  COLON: 29,
  QUESTION: 30,
  BYTES: 31
}, Vo = {
  [V.EQ]: Z["=="],
  [V.PLUS]: Z["+"],
  [V.MINUS]: Z["-"],
  [V.MULTIPLY]: Z["*"],
  [V.DIVIDE]: Z["/"],
  [V.MODULO]: Z["%"],
  [V.LE]: Z["<="],
  [V.LT]: Z["<"],
  [V.GE]: Z[">="],
  [V.GT]: Z[">"],
  [V.NE]: Z["!="],
  [V.IN]: Z.in
}, ma = {};
for (const e in V) ma[V[e]] = e;
const im = new Uint8Array(128);
for (const e of "0123456789abcdefABCDEF") im[e.charCodeAt(0)] = 1;
const bp = {
  "\\": "\\",
  "?": "?",
  '"': '"',
  "'": "'",
  "`": "`",
  a: "\x07",
  b: "\b",
  f: "\f",
  n: `
`,
  r: "\r",
  t: "	",
  v: "\v"
};
let sm = class om {
  #t;
  constructor(t, n, r, i) {
    this.#t = { input: t, pos: n, evaluate: r.evaluate, check: r.check }, this.op = r.name, this.args = i;
  }
  get meta() {
    return this.#t;
  }
  check(t, n, r) {
    const i = this.#t;
    return i.alternate ? t.check(i.alternate, r) : i.macro ? i.macro.typeCheck(t, i.macro, r) : i.check(t, n, r);
  }
  evaluate(t, n, r) {
    const i = this.#t;
    return i.alternate ? this.evaluate = this.#e : i.macro ? this.evaluate = this.#n : this.evaluate = i.evaluate, this.evaluate(t, n, r);
  }
  #e(t, n, r) {
    return (n = this.#t.alternate).evaluate(t, n, r);
  }
  #n(t, n, r) {
    return (n = this.#t.macro).evaluate(t, n, r);
  }
  setMeta(t, n) {
    return this.#t[t] = n, this;
  }
  get input() {
    return this.#t.input;
  }
  get pos() {
    return this.#t.pos;
  }
  toOldStructure() {
    const t = Array.isArray(this.args) ? this.args : [this.args];
    return [this.op, ...t.map((n) => n instanceof om ? n.toOldStructure() : n)];
  }
}, ov = class {
  input;
  pos;
  length;
  tokenPos;
  tokenType;
  tokenValue;
  reset(t) {
    return this.pos = 0, this.input = t, this.length = t.length, t;
  }
  token(t, n, r) {
    return this.tokenPos = t, this.tokenType = n, this.tokenValue = r, this;
  }
  // Read next token
  nextToken() {
    for (; ; ) {
      const { pos: t, input: n, length: r } = this;
      if (t >= r) return this.token(t, V.EOF);
      const i = n[t];
      switch (i) {
        // Whitespaces
        case " ":
        case "	":
        case `
`:
        case "\r":
          this.pos++;
          continue;
        // Operators
        case "=":
          if (n[t + 1] !== "=") break;
          return this.token((this.pos += 2) - 2, V.EQ);
        case "&":
          if (n[t + 1] !== "&") break;
          return this.token((this.pos += 2) - 2, V.AND);
        case "|":
          if (n[t + 1] !== "|") break;
          return this.token((this.pos += 2) - 2, V.OR);
        case "+":
          return this.token(this.pos++, V.PLUS);
        case "-":
          return this.token(this.pos++, V.MINUS);
        case "*":
          return this.token(this.pos++, V.MULTIPLY);
        case "/":
          if (n[t + 1] === "/") {
            for (; this.pos < r && this.input[this.pos] !== `
`; ) this.pos++;
            continue;
          }
          return this.token(this.pos++, V.DIVIDE);
        case "%":
          return this.token(this.pos++, V.MODULO);
        case "<":
          return n[t + 1] === "=" ? this.token((this.pos += 2) - 2, V.LE) : this.token(this.pos++, V.LT);
        case ">":
          return n[t + 1] === "=" ? this.token((this.pos += 2) - 2, V.GE) : this.token(this.pos++, V.GT);
        case "!":
          return n[t + 1] === "=" ? this.token((this.pos += 2) - 2, V.NE) : this.token(this.pos++, V.NOT);
        case "(":
          return this.token(this.pos++, V.LPAREN);
        case ")":
          return this.token(this.pos++, V.RPAREN);
        case "[":
          return this.token(this.pos++, V.LBRACKET);
        case "]":
          return this.token(this.pos++, V.RBRACKET);
        case "{":
          return this.token(this.pos++, V.LBRACE);
        case "}":
          return this.token(this.pos++, V.RBRACE);
        case ".":
          return this.token(this.pos++, V.DOT);
        case ",":
          return this.token(this.pos++, V.COMMA);
        case ":":
          return this.token(this.pos++, V.COLON);
        case "?":
          return this.token(this.pos++, V.QUESTION);
        case '"':
        case "'":
          return this.readString(i);
        // Check for string prefixes (b, B, r, R followed by quote)
        case "b":
        case "B":
        case "r":
        case "R": {
          const s = n[t + 1];
          return s === '"' || s === "'" ? ++this.pos && this.readString(s, i) : this.readIdentifier();
        }
        default: {
          const s = i.charCodeAt(0);
          if (s <= 57 && s >= 48) return this.readNumber();
          if (this._isIdentifierCharCode(s)) return this.readIdentifier();
        }
      }
      throw new mt(`Unexpected character: ${i}`, { pos: t, input: n });
    }
  }
  // Characters: 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_
  _isIdentifierCharCode(t) {
    return t < 48 || t > 122 ? !1 : t >= 97 || t >= 65 && t <= 90 || t <= 57 || t === 95;
  }
  _parseAsDouble(t, n) {
    const r = Number(this.input.substring(t, n));
    if (Number.isFinite(r)) return this.token(t, V.NUMBER, r);
    throw new mt(`Invalid number: ${r}`, { pos: t, input: this.input });
  }
  _parseAsBigInt(t, n, r, i) {
    const s = this.input.substring(t, n);
    if (i === "u" || i === "U") {
      this.pos++;
      try {
        return this.token(t, V.NUMBER, new Qr(s));
      } catch {
      }
    } else
      try {
        return this.token(t, V.NUMBER, BigInt(s));
      } catch {
      }
    throw new mt(r ? `Invalid hex integer: ${s}` : `Invalid integer: ${s}`, {
      pos: t,
      input: this.input
    });
  }
  _readDigits(t, n, r, i) {
    for (; r < n && (i = t.charCodeAt(r)) && !(i > 57 || i < 48); ) r++;
    return r;
  }
  _readExponent(t, n, r) {
    let i = r < n && t[r];
    if (i === "e" || i === "E") {
      i = ++r < n && t[r], (i === "-" || i === "+") && r++;
      const s = r;
      if (r = this._readDigits(t, n, r), s === r) throw new mt("Invalid exponent", { pos: r, input: t });
    }
    return r;
  }
  readNumber() {
    const { input: t, length: n, pos: r } = this;
    let i = r;
    if (t[i] === "0" && (t[i + 1] === "x" || t[i + 1] === "X")) {
      for (i += 2; i < n && im[t[i].charCodeAt(0)]; ) i++;
      return this._parseAsBigInt(r, this.pos = i, !0, t[i]);
    }
    if (i = this._readDigits(t, n, i), i + 1 < n) {
      let s = !1, o = t[i] === "." ? this._readDigits(t, n, i + 1) : i + 1;
      if (o !== i + 1 && (s = !0) && (i = o), o = this._readExponent(t, n, i), o !== i && (s = !0) && (i = o), s) return this._parseAsDouble(r, this.pos = i);
    }
    return this._parseAsBigInt(r, this.pos = i, !1, t[i]);
  }
  readString(t, n) {
    const { input: r, pos: i } = this;
    return r[i + 1] === t && r[i + 2] === t ? this.readTripleQuotedString(t, n) : this.readSingleQuotedString(t, n);
  }
  _closeQuotedString(t, n, r) {
    switch (n) {
      case "b":
      case "B": {
        const i = this.processEscapes(t, !0), s = new Uint8Array(i.length);
        for (let o = 0; o < i.length; o++) s[o] = i.charCodeAt(o) & 255;
        return this.token(r - 1, V.BYTES, s);
      }
      case "r":
      case "R":
        return this.token(r - 1, V.STRING, t);
      default: {
        const i = this.processEscapes(t, !1);
        return this.token(r, V.STRING, i);
      }
    }
  }
  readSingleQuotedString(t, n) {
    const { input: r, length: i, pos: s } = this;
    let o, a = this.pos + 1;
    for (; a < i && (o = r[a]); ) {
      switch (o) {
        case t:
          const c = r.slice(s + 1, a);
          return this.pos = ++a, this._closeQuotedString(c, n, s);
        case `
`:
        case "\r":
          throw new mt("Newlines not allowed in single-quoted strings", { pos: s, input: r });
        case "\\":
          a++;
      }
      a++;
    }
    throw new mt("Unterminated string", { pos: s, input: r });
  }
  readTripleQuotedString(t, n) {
    const { input: r, length: i, pos: s } = this;
    let o, a = this.pos + 3;
    for (; a < i && (o = r[a]); ) {
      switch (o) {
        case t:
          if (r[a + 1] === t && r[a + 2] === t) {
            const c = r.slice(s + 3, a);
            return this.pos = a + 3, this._closeQuotedString(c, n, s);
          }
          break;
        case "\\":
          a++;
      }
      a++;
    }
    throw new mt("Unterminated triple-quoted string", { pos: s, input: r });
  }
  processEscapes(t, n) {
    if (!t.includes("\\")) return t;
    let r = "", i = 0;
    for (; i < t.length; ) {
      if (t[i] !== "\\" || i + 1 >= t.length) {
        r += t[i++];
        continue;
      }
      const s = t[i + 1];
      if (bp[s])
        r += bp[s], i += 2;
      else if (s === "u") {
        if (n) throw new mt("\\u not allowed in bytes literals");
        const o = t.substring(i + 2, i += 6);
        if (!/^[0-9a-fA-F]{4}$/.test(o)) throw new mt(`Invalid Unicode escape: \\u${o}`);
        const a = Number.parseInt(o, 16);
        if (a >= 55296 && a <= 57343) throw new mt(`Invalid Unicode surrogate: \\u${o}`);
        r += String.fromCharCode(a);
      } else if (s === "U") {
        if (n) throw new mt("\\U not allowed in bytes literals");
        const o = t.substring(i + 2, i += 10);
        if (!/^[0-9a-fA-F]{8}$/.test(o)) throw new mt(`Invalid Unicode escape: \\U${o}`);
        const a = Number.parseInt(o, 16);
        if (a > 1114111) throw new mt(`Invalid Unicode escape: \\U${o}`);
        if (a >= 55296 && a <= 57343) throw new mt(`Invalid Unicode surrogate: \\U${o}`);
        r += String.fromCodePoint(a);
      } else if (s === "x" || s === "X") {
        const o = t.substring(i + 2, i += 4);
        if (!/^[0-9a-fA-F]{2}$/.test(o)) throw new mt(`Invalid hex escape: \\${s}${o}`);
        r += String.fromCharCode(Number.parseInt(o, 16));
      } else if (s >= "0" && s <= "7") {
        const o = t.substring(i + 1, i += 4);
        if (!/^[0-7]{3}$/.test(o)) throw new mt("Octal escape must be 3 digits");
        const a = Number.parseInt(o, 8);
        if (a > 255) throw new mt(`Octal escape out of range: \\${o}`);
        r += String.fromCharCode(a);
      } else
        throw new mt(`Invalid escape sequence: \\${s}`);
    }
    return r;
  }
  readIdentifier() {
    const { pos: t, input: n, length: r } = this;
    let i = t;
    for (; i < r && this._isIdentifierCharCode(n[i].charCodeAt(0)); ) i++;
    const s = n.substring(t, this.pos = i);
    switch (s) {
      case "true":
        return this.token(t, V.BOOLEAN, !0);
      case "false":
        return this.token(t, V.BOOLEAN, !1);
      case "null":
        return this.token(t, V.NULL, null);
      case "in":
        return this.token(t, V.IN);
      default:
        return this.token(t, V.IDENTIFIER, s);
    }
  }
}, av = class {
  lexer = null;
  input = null;
  maxDepthRemaining = null;
  astNodesRemaining = null;
  type = null;
  pos = null;
  constructor(t, n) {
    this.limits = t, this.registry = n, this.lexer = new ov();
  }
  #t(t, n = this.pos) {
    throw new mt(`Exceeded ${t} (${this.limits[t]})`, {
      pos: n,
      input: this.input
    });
  }
  #e(t, n, r) {
    const i = new sm(this.input, t, n, r);
    return this.astNodesRemaining-- || this.#t("maxAstNodes", t), i;
  }
  #n(t = this.pos) {
    const n = this.lexer.nextToken();
    return this.pos = n.tokenPos, this.type = n.tokenType, t;
  }
  // The value of the current token is accessed less regularly,
  // so we use a getter to reduce assignment overhead
  get value() {
    return this.lexer.tokenValue;
  }
  consume(t) {
    if (this.type === t) return this.#n();
    throw new mt(
      `Expected ${ma[t]}, got ${ma[this.type]}`,
      { pos: this.pos, input: this.input }
    );
  }
  match(t) {
    return this.type === t;
  }
  // Parse entry point
  parse(t) {
    if (typeof t != "string") throw new mt("Expression must be a string");
    this.input = this.lexer.reset(t), this.#n(), this.maxDepthRemaining = this.limits.maxDepth, this.astNodesRemaining = this.limits.maxAstNodes;
    const n = this.parseExpression();
    if (this.match(V.EOF)) return n;
    throw new mt(`Unexpected character: '${this.input[this.lexer.pos - 1]}'`, {
      pos: this.pos,
      input: this.input
    });
  }
  #r(t, n, r) {
    const [i, s, o] = n === Z.rcall ? r : [r[0], null, r[1]], a = this.registry.findMacro(i, !!s, o.length), c = this.#e(t, n, r);
    if (!a) return c;
    const u = a.handler({ ast: c, args: o, receiver: s, methodName: i, parser: this });
    return u.callAst ? c.setMeta("alternate", u.callAst) : c.setMeta("macro", u), c;
  }
  // Expression ::= LogicalOr ('?' Expression ':' Expression)?
  parseExpression() {
    this.maxDepthRemaining-- || this.#t("maxDepth");
    const t = this.parseLogicalOr();
    if (!this.match(V.QUESTION)) return ++this.maxDepthRemaining && t;
    const n = this.#n(), r = this.parseExpression();
    this.consume(V.COLON);
    const i = this.parseExpression();
    return this.maxDepthRemaining++, this.#e(n, Z.ternary, [t, r, i]);
  }
  // LogicalOr ::= LogicalAnd ('||' LogicalAnd)*
  parseLogicalOr() {
    let t = this.parseLogicalAnd();
    for (; this.match(V.OR); )
      t = this.#e(this.#n(), Z["||"], [t, this.parseLogicalAnd()]);
    return t;
  }
  // LogicalAnd ::= Equality ('&&' Equality)*
  parseLogicalAnd() {
    let t = this.parseEquality();
    for (; this.match(V.AND); )
      t = this.#e(this.#n(), Z["&&"], [t, this.parseEquality()]);
    return t;
  }
  // Equality ::= Relational (('==' | '!=') Relational)*
  parseEquality() {
    let t = this.parseRelational();
    for (; this.match(V.EQ) || this.match(V.NE); ) {
      const n = Vo[this.type];
      t = this.#e(this.#n(), n, [t, this.parseRelational()]);
    }
    return t;
  }
  // Relational ::= Additive (('<' | '<=' | '>' | '>=' | 'in') Additive)*
  parseRelational() {
    let t = this.parseAdditive();
    for (; this.match(V.LT) || this.match(V.LE) || this.match(V.GT) || this.match(V.GE) || this.match(V.IN); ) {
      const n = Vo[this.type];
      t = this.#e(this.#n(), n, [t, this.parseAdditive()]);
    }
    return t;
  }
  // Additive ::= Multiplicative (('+' | '-') Multiplicative)*
  parseAdditive() {
    let t = this.parseMultiplicative();
    for (; this.match(V.PLUS) || this.match(V.MINUS); ) {
      const n = Vo[this.type];
      t = this.#e(this.#n(), n, [t, this.parseMultiplicative()]);
    }
    return t;
  }
  // Multiplicative ::= Unary (('*' | '/' | '%') Unary)*
  parseMultiplicative() {
    let t = this.parseUnary();
    for (; this.match(V.MULTIPLY) || this.match(V.DIVIDE) || this.match(V.MODULO); ) {
      const n = Vo[this.type];
      t = this.#e(this.#n(), n, [t, this.parseUnary()]);
    }
    return t;
  }
  // Unary ::= ('!' | '-')* Postfix
  parseUnary() {
    return this.type === V.NOT ? this.#e(this.#n(), Z.unaryNot, this.parseUnary()) : this.type === V.MINUS ? this.#e(this.#n(), Z.unaryMinus, this.parseUnary()) : this.parsePostfix();
  }
  // Postfix ::= Primary (('.' IDENTIFIER ('(' ArgumentList ')')? | '[' Expression ']'))*
  parsePostfix() {
    let t = this.parsePrimary();
    const n = this.maxDepthRemaining;
    for (; ; ) {
      if (this.match(V.DOT)) {
        const r = this.#n();
        this.maxDepthRemaining-- || this.#t("maxDepth", r);
        const i = this.match(V.QUESTION) && this.registry.enableOptionalTypes && this.#n() ? Z.optionalFieldAccess : Z.fieldAccess, s = this.value, o = this.consume(V.IDENTIFIER);
        if (i === Z.fieldAccess && this.match(V.LPAREN) && this.#n()) {
          const a = this.parseArgumentList();
          this.consume(V.RPAREN), t = this.#r(o, Z.rcall, [s, t, a]);
        } else
          t = this.#e(o, i, [t, s]);
        continue;
      }
      if (this.match(V.LBRACKET)) {
        const r = this.#n();
        this.maxDepthRemaining-- || this.#t("maxDepth", r);
        const i = this.match(V.QUESTION) && this.registry.enableOptionalTypes && this.#n() ? Z.optionalBracketAccess : Z.bracketAccess, s = this.parseExpression();
        this.consume(V.RBRACKET), t = this.#e(r, i, [t, s]);
        continue;
      }
      break;
    }
    return this.maxDepthRemaining = n, t;
  }
  // Primary ::= NUMBER | STRING | BOOLEAN | NULL | IDENTIFIER | '(' Expression ')' | Array | Object
  parsePrimary() {
    switch (this.type) {
      case V.NUMBER:
      case V.STRING:
      case V.BYTES:
      case V.BOOLEAN:
      case V.NULL:
        return this.#i();
      case V.IDENTIFIER:
        return this.#o();
      case V.LPAREN:
        return this.#a();
      case V.LBRACKET:
        return this.parseList();
      case V.LBRACE:
        return this.parseMap();
    }
    throw new mt(`Unexpected token: ${ma[this.type]}`, {
      pos: this.pos,
      input: this.input
    });
  }
  #i() {
    return this.#n(this.#e(this.pos, Z.value, this.value));
  }
  #o() {
    const t = this.value, n = this.consume(V.IDENTIFIER);
    if (Qa.has(t))
      throw new mt(`Reserved identifier: ${t}`, {
        pos: n,
        input: this.input
      });
    if (!this.match(V.LPAREN)) return this.#e(n, Z.id, t);
    this.#n();
    const r = this.parseArgumentList();
    return this.consume(V.RPAREN), this.#r(n, Z.call, [t, r]);
  }
  #a() {
    this.consume(V.LPAREN);
    const t = this.parseExpression();
    return this.consume(V.RPAREN), t;
  }
  parseList() {
    const t = this.consume(V.LBRACKET), n = [];
    let r = this.limits.maxListElements;
    if (!this.match(V.RBRACKET))
      for (n.push(this.parseExpression()), r-- || this.#t("maxListElements", n.at(-1).pos); this.match(V.COMMA) && (this.#n(), !this.match(V.RBRACKET)); )
        n.push(this.parseExpression()), r-- || this.#t("maxListElements", n.at(-1).pos);
    return this.consume(V.RBRACKET), this.#e(t, Z.list, n);
  }
  parseMap() {
    const t = this.consume(V.LBRACE), n = [];
    let r = this.limits.maxMapEntries;
    if (!this.match(V.RBRACE))
      for (n.push(this.parseProperty()), r-- || this.#t("maxMapEntries", n.at(-1)[0].pos); this.match(V.COMMA) && (this.#n(), !this.match(V.RBRACE)); )
        n.push(this.parseProperty()), r-- || this.#t("maxMapEntries", n.at(-1)[0].pos);
    return this.consume(V.RBRACE), this.#e(t, Z.map, n);
  }
  parseProperty() {
    return [this.parseExpression(), (this.consume(V.COLON), this.parseExpression())];
  }
  parseArgumentList() {
    const t = [];
    let n = this.limits.maxCallArguments;
    if (!this.match(V.RPAREN))
      for (t.push(this.parseExpression()), n-- || this.#t("maxCallArguments", t.at(-1).pos); this.match(V.COMMA) && (this.#n(), !this.match(V.RPAREN)); )
        t.push(this.parseExpression()), n-- || this.#t("maxCallArguments", t.at(-1).pos);
    return t;
  }
};
const zc = (e) => e;
function qc(e, t) {
  if (e.op === "id") return e.args;
  throw new mt(t, e);
}
function Tt(e, t, n) {
  return new sm(e.input, e.pos, t, n);
}
function Ep(e) {
  const t = e ? "map(var, filter, transform)" : "map(var, transform)", n = `${t} invalid predicate iteration variable`, r = `${t} filter predicate must return bool`;
  return ({ args: i, receiver: s, ast: o }) => {
    const [a, c, u] = e ? i : [i[0], null, i[1]];
    let l = Tt(u, Z.accuPush, u);
    if (c) {
      const f = Tt(c, Z.accuValue);
      l = Tt(c, Z.ternary, [c.setMeta("label", r), l, f]);
    }
    return {
      callAst: Tt(o, Z.comprehension, {
        errorsAreFatal: !0,
        iterable: s,
        iterVarName: qc(a, n),
        init: Tt(o, Z.list, []),
        step: l,
        result: zc
      })
    };
  };
}
function cv() {
  const e = "filter(var, predicate)", t = `${e} invalid predicate iteration variable`, n = `${e} predicate must return bool`;
  return ({ args: r, receiver: i, ast: s }) => {
    const o = qc(r[0], t), a = Tt(s, Z.accuValue), c = r[1].setMeta("label", n), u = Tt(s, Z.accuPush, Tt(s, Z.id, o)), l = Tt(c, Z.ternary, [c, u, a]);
    return {
      callAst: Tt(s, Z.comprehension, {
        errorsAreFatal: !0,
        iterable: i,
        iterVarName: o,
        init: Tt(s, Z.list, []),
        step: l,
        result: zc
      })
    };
  };
}
function _u(e) {
  const t = `${e.name}(var, predicate) invalid predicate iteration variable`, n = `${e.name}(var, predicate) predicate must return bool`;
  return ({ args: r, receiver: i, ast: s }) => {
    const o = r[1].setMeta("label", n), a = e.transform({ args: r, ast: s, predicate: o, opts: e });
    return {
      callAst: Tt(s, Z.comprehension, {
        kind: "quantifier",
        errorsAreFatal: e.errorsAreFatal || !1,
        iterable: i,
        iterVarName: qc(r[0], t),
        init: a.init,
        condition: a.condition,
        step: a.step,
        result: a.result || zc
      })
    };
  };
}
function uv() {
  const e = "has() invalid argument";
  function t(r, i, s) {
    const o = i.macroHasProps;
    let a = o.length, c = r.eval(o[--a], s), u;
    for (; a--; ) {
      const l = o[a];
      if (l.op === ".?" && (u ??= !0), c = r.debugType(c).fieldLazy(c, l.args[1], l, r), c === void 0) {
        if (!(!u && a && l.op === ".")) break;
        throw new J(`No such key: ${l.args[1]}`, l);
      }
    }
    return c !== void 0;
  }
  function n(r, i, s) {
    let o = i.args[0];
    if (o.op !== ".") throw new r.Error(e, o);
    if (!i.macroHasProps) {
      const a = [];
      for (; o.op === "." || o.op === ".?"; ) o = a.push(o) && o.args[0];
      if (o.op !== "id") throw new r.Error(e, o);
      r.check(o, s), a.push(o), i.macroHasProps = a;
    }
    return r.getType("bool");
  }
  return function({ args: r }) {
    return { args: r, evaluate: t, typeCheck: n };
  };
}
function lv(e) {
  e.registerFunctionOverload("has(ast): bool", uv()), e.registerFunctionOverload(
    "list.all(ast, ast): bool",
    _u({
      name: "all",
      transform({ ast: o, predicate: a, opts: c }) {
        return {
          init: Tt(o, Z.value, !0),
          condition: zc,
          step: Tt(a, Z.ternary, [
            a,
            Tt(a, Z.value, !0),
            Tt(a, Z.value, !1)
          ])
        };
      }
    })
  ), e.registerFunctionOverload(
    "list.exists(ast, ast): bool",
    _u({
      name: "exists",
      condition(o) {
        return !o;
      },
      transform({ ast: o, predicate: a, opts: c }) {
        return {
          init: Tt(o, Z.value, !1),
          condition: c.condition,
          step: Tt(a, Z.ternary, [
            a,
            Tt(a, Z.value, !0),
            Tt(a, Z.value, !1)
          ])
        };
      }
    })
  ), e.registerFunctionOverload(
    "list.exists_one(ast, ast): bool",
    _u({
      name: "exists_one",
      errorsAreFatal: !0,
      result(o) {
        return o === 1;
      },
      transform({ ast: o, predicate: a, opts: c }) {
        const u = Tt(o, Z.accuValue);
        return {
          init: Tt(o, Z.value, 0),
          step: Tt(a, Z.ternary, [a, Tt(o, Z.accuInc), u]),
          result: c.result
        };
      }
    })
  ), e.registerFunctionOverload("list.map(ast, ast): list<dyn>", Ep(!1)), e.registerFunctionOverload("list.map(ast, ast, ast): list<dyn>", Ep(!0)), e.registerFunctionOverload("list.filter(ast, ast): list<dyn>", cv());
  function t(o, a, c, u) {
    const l = o.eval(a.exp, c = a.bindCtx.reuse(c).setIterValue(u));
    return l instanceof Promise && c === a.bindCtx && (c.async = !0), l;
  }
  class n {
  }
  const r = new n();
  e.registerType("CelNamespace", n), e.registerConstant("cel", "CelNamespace", r);
  function i(o, a, c) {
    return a.bindCtx = c.forkWithVariable(a.var, o.check(a.val, c)), o.check(a.exp, a.bindCtx);
  }
  function s(o, a, c) {
    const u = o.eval(a.val, c);
    return u instanceof Promise ? u.then((l) => t(o, a, c, l)) : t(o, a, c, u);
  }
  e.registerFunctionOverload("CelNamespace.bind(ast, dyn, ast): dyn", ({ args: o }) => ({
    var: qc(o[0], "invalid variable argument"),
    val: o[1],
    exp: o[2],
    bindCtx: void 0,
    typeCheck: i,
    evaluate: s
  }));
}
function fv(e) {
  const t = e.unaryOverload.bind(e), n = e.binaryOverload.bind(e);
  function r(u, l) {
    if (u <= 9223372036854775807n && u >= -9223372036854775808n) return u;
    throw new J(`integer overflow: ${u}`, l);
  }
  t("!", "bool", (u) => !u), t("-", "int", (u) => -u), n("dyn<int>", "==", "double", (u, l) => u == l), n("dyn<int>", "==", "uint", (u, l) => u == l.valueOf()), n("int", "*", "int", (u, l, f) => r(u * l, f)), n("int", "+", "int", (u, l, f) => r(u + l, f)), n("int", "-", "int", (u, l, f) => r(u - l, f)), n("int", "/", "int", (u, l, f) => {
    if (l === 0n) throw new J("division by zero", f);
    return u / l;
  }), n("int", "%", "int", (u, l, f) => {
    if (l === 0n) throw new J("modulo by zero", f);
    return u % l;
  }), t("-", "double", (u) => -u), n("dyn<double>", "==", "int", (u, l) => u == l), n("dyn<double>", "==", "uint", (u, l) => u == l.valueOf()), n("double", "*", "double", (u, l) => u * l), n("double", "+", "double", (u, l) => u + l), n("double", "-", "double", (u, l) => u - l), n("double", "/", "double", (u, l) => u / l), n("string", "+", "string", (u, l) => u + l), n("list<V>", "+", "list<V>", (u, l) => [...u, ...l]), n("bytes", "+", "bytes", (u, l) => {
    if (!u.length) return l;
    if (!l.length) return u;
    const f = new Uint8Array(u.length + l.length);
    return f.set(u, 0), f.set(l, u.length), f;
  });
  const i = "google.protobuf.Duration";
  n(i, "+", i, (u, l) => u.addDuration(l)), n(i, "-", i, (u, l) => u.subtractDuration(l)), n(i, "==", i, (u, l) => u.seconds === l.seconds && u.nanos === l.nanos);
  const s = "google.protobuf.Timestamp";
  n(s, "==", s, (u, l) => u.getTime() === l.getTime()), n(s, "-", s, (u, l) => pa.fromMilliseconds(u.getTime() - l.getTime()), i), n(s, "-", i, (u, l) => l.subtractTimestamp(u)), n(s, "+", i, (u, l) => l.extendTimestamp(u)), n(i, "+", s, (u, l) => u.extendTimestamp(l));
  function o(u, l, f, h) {
    if (l instanceof Set && l.has(u)) return !0;
    for (const g of l) if (Os(u, g, f, h)) return !0;
    return !1;
  }
  function a(u, l) {
    return l instanceof Map ? l.get(u) !== void 0 : Vl(l, u) ? l[u] !== void 0 : !1;
  }
  function c(u, l, f, h) {
    return o(u, l, f, h);
  }
  n("V", "in", "list<V>", c), n("K", "in", "map<K, V>", a);
  for (const u of ["type", "null", "bool", "string", "int", "double"])
    n(u, "==", u, (l, f) => l === f);
  n("bytes", "==", "bytes", (u, l) => {
    if (u === l) return !0;
    let f = u.length;
    if (f !== l.length) return !1;
    for (; f--; ) if (u[f] !== l[f]) return !1;
    return !0;
  }), n("list<V>", "==", "list<V>", (u, l, f, h) => {
    if (u === l) return !0;
    if (ha(u) && ha(l)) {
      const p = u.length;
      if (p !== l.length) return !1;
      for (let y = 0; y < p; y++)
        if (!Os(u[y], l[y], f, h)) return !1;
      return !0;
    }
    if (u instanceof Set && l instanceof Set) {
      if (u.size !== l.size) return !1;
      for (const p of u) if (!l.has(p)) return !1;
      return !0;
    }
    const g = u instanceof Set ? l : u, d = u instanceof Set ? u : l;
    if (!ha(g) || g.length !== d?.size) return !1;
    for (let p = 0; p < g.length; p++) if (!d.has(g[p])) return !1;
    return !0;
  }), n("map<K, V>", "==", "map<K, V>", (u, l, f, h) => {
    if (u === l) return !0;
    if (u instanceof Map && l instanceof Map) {
      if (u.size !== l.size) return !1;
      for (const [p, y] of u)
        if (!(l.has(p) && Os(y, l.get(p), f, h))) return !1;
      return !0;
    }
    if (u instanceof Map || l instanceof Map) {
      const p = u instanceof Map ? l : u, y = u instanceof Map ? u : l, x = kn(p);
      if (y.size !== x.length) return !1;
      for (const [S, A] of y)
        if (!(S in p && Os(A, p[S], f, h))) return !1;
      return !0;
    }
    const g = kn(u), d = kn(l);
    if (g.length !== d.length) return !1;
    for (let p = 0; p < g.length; p++) {
      const y = g[p];
      if (!(y in l && Os(u[y], l[y], f, h))) return !1;
    }
    return !0;
  }), n("uint", "==", "uint", (u, l) => u.valueOf() === l.valueOf()), n("dyn<uint>", "==", "double", (u, l) => u.valueOf() == l), n("dyn<uint>", "==", "int", (u, l) => u.valueOf() == l), n("uint", "+", "uint", (u, l) => new Qr(u.valueOf() + l.valueOf())), n("uint", "-", "uint", (u, l) => new Qr(u.valueOf() - l.valueOf())), n("uint", "*", "uint", (u, l) => new Qr(u.valueOf() * l.valueOf())), n("uint", "/", "uint", (u, l, f) => {
    if (l.valueOf() === 0n) throw new J("division by zero", f);
    return new Qr(u.valueOf() / l.valueOf());
  }), n("uint", "%", "uint", (u, l, f) => {
    if (l.valueOf() === 0n) throw new J("modulo by zero", f);
    return new Qr(u.valueOf() % l.valueOf());
  });
  for (const [u, l] of [
    ["bool", "bool"],
    ["int", "int"],
    ["uint", "uint"],
    ["double", "double"],
    ["string", "string"],
    ["google.protobuf.Timestamp", "google.protobuf.Timestamp"],
    ["google.protobuf.Duration", "google.protobuf.Duration"],
    ["int", "uint"],
    ["int", "double"],
    ["double", "int"],
    ["double", "uint"],
    ["uint", "int"],
    ["uint", "double"]
  ])
    n(u, "<", l, (f, h) => f < h), n(u, "<=", l, (f, h) => f <= h), n(u, ">", l, (f, h) => f > h), n(u, ">=", l, (f, h) => f >= h);
}
function Os(e, t, n, r) {
  if (e === t) return !0;
  switch (typeof e) {
    case "string":
      return !1;
    case "bigint":
      return typeof t == "number" ? e == t : !1;
    case "number":
      return typeof t == "bigint" ? e == t : !1;
    case "boolean":
      return !1;
    case "object":
      if (typeof t != "object" || e === null || t === null) return !1;
      const i = r.objectTypesByConstructor.get(e.constructor)?.type, s = r.objectTypesByConstructor.get(t.constructor)?.type;
      if (!i || i !== s) return !1;
      const o = r.registry.findBinaryOverload("==", i, s);
      return o ? o.handler(e, t, n, r) : !1;
  }
  throw new J(`Cannot compare values of type ${typeof e}`, n);
}
const dv = (/* @__PURE__ */ new Map()).set("A", "dyn").set("T", "dyn").set("K", "dyn").set("V", "dyn");
let xp = class extends Qw {
  constructor(t, n) {
    super(t), this.isEvaluating = n, this.Error = n ? J : RS;
  }
  /**
   * Check an expression and return its inferred type
   * @param {Array|any} ast - The AST node to check
   * @returns {Object} The inferred type declaration
   * @throws {TypeError} If type checking fails
   */
  check(t, n) {
    return t.checkedType ??= t.check(this, t, n);
  }
  checkAccessOnType(t, n, r, i = !1) {
    if (r.kind === "dyn") return r;
    const s = (t.op === "[]" || t.op === "[?]" ? this.check(t.args[1], n) : this.stringType).type;
    if (r.kind === "list") {
      if (s !== "int" && s !== "dyn")
        throw new this.Error(`List index must be int, got '${s}'`, t);
      return r.valueType;
    }
    if (r.kind === "map") return r.valueType;
    const o = this.objectTypes.get(r.name);
    if (o) {
      if (!(s === "string" || s === "dyn"))
        throw new this.Error(
          `Cannot index type '${r.name}' with type '${s}'`,
          t
        );
      if (o.fields) {
        const a = t.op === "." || t.op === ".?" ? t.args[1] : void 0;
        if (a) {
          const c = o.fields[a];
          if (c) return c;
          if (i) return this.dynType;
          throw new this.Error(`No such key: ${a}`, t);
        }
      }
      return this.dynType;
    }
    throw new this.Error(`Cannot index type '${this.formatType(r)}'`, t);
  }
  formatType(t) {
    return t.hasPlaceholder() ? t.templated(this.registry, dv).name : t.name;
  }
  formatTypeList(t) {
    return t.map((n) => this.formatType(n)).join(", ");
  }
};
const cd = Hr({
  maxAstNodes: 1e5,
  maxDepth: 250,
  maxListElements: 1e3,
  maxMapEntries: 1e3,
  maxCallArguments: 32
}), hv = new Set(kn(cd));
function pv(e, t = cd) {
  const n = e ? kn(e) : void 0;
  if (!n?.length) return t;
  const r = { ...t };
  for (const i of n) {
    if (!hv.has(i)) throw new TypeError(`Unknown limits option: ${i}`);
    const s = e[i];
    typeof s == "number" && (r[i] = s);
  }
  return Hr(r);
}
const gv = Hr({
  unlistedVariablesAreDyn: !1,
  homogeneousAggregateLiterals: !0,
  enableOptionalTypes: !1,
  limits: cd
});
function Du(e, t, n) {
  const r = e?.[n] ?? t?.[n];
  if (typeof r != "boolean") throw new TypeError(`Invalid option: ${n}`);
  return r;
}
function yv(e, t = gv) {
  return e ? Hr({
    unlistedVariablesAreDyn: Du(e, t, "unlistedVariablesAreDyn"),
    homogeneousAggregateLiterals: Du(e, t, "homogeneousAggregateLiterals"),
    enableOptionalTypes: Du(e, t, "enableOptionalTypes"),
    limits: pv(e.limits, t.limits)
  }) : t;
}
const Gc = ZS({ enableOptionalTypes: !1 });
_S(Gc);
fv(Gc);
lv(Gc);
const Tp = /* @__PURE__ */ new WeakMap();
let Yc = class Fl {
  #t;
  #e;
  #n;
  #r;
  #i;
  constructor(t, n) {
    this.opts = yv(t, n?.opts), this.#t = (n instanceof Fl ? Tp.get(n) : Gc).clone(this.opts);
    const r = {
      objectTypes: this.#t.objectTypes,
      objectTypesByConstructor: this.#t.objectTypesByConstructor,
      registry: this.#t,
      opts: this.opts
    };
    this.#n = new xp(r), this.#r = new xp(r, !0), this.#e = new wv(r), this.#i = new av(this.opts.limits, this.#t), Tp.set(this, this.#t), Object.freeze(this);
  }
  clone(t) {
    return new Fl(t, this);
  }
  registerFunction(t, n) {
    return this.#t.registerFunctionOverload(t, n), this;
  }
  registerOperator(t, n) {
    return this.#t.registerOperatorOverload(t, n), this;
  }
  registerType(t, n) {
    return this.#t.registerType(t, n), this;
  }
  registerVariable(t, n) {
    return this.#t.registerVariable(t, n), this;
  }
  registerConstant(t, n, r) {
    return this.#t.registerConstant(t, n, r), this;
  }
  hasVariable(t) {
    return this.#t.variables.has(t);
  }
  check(t) {
    try {
      return this.#o(this.#i.parse(t));
    } catch (n) {
      return { valid: !1, error: n };
    }
  }
  #o(t) {
    try {
      const n = this.#n.check(t, new rp(this.#t));
      return { valid: !0, type: this.#a(n) };
    } catch (n) {
      return { valid: !1, error: n };
    }
  }
  #a(t) {
    return t.name === "list<dyn>" ? "list" : t.name === "map<dyn, dyn>" ? "map" : t.name;
  }
  parse(t) {
    const n = this.#i.parse(t), r = this.#c.bind(this, n);
    return r.check = this.#o.bind(this, n), r.ast = n, r;
  }
  evaluate(t, n) {
    return this.#c(this.#i.parse(t), n);
  }
  #c(t, n) {
    return n = new rp(this.#t, n), t.checkedType || this.#r.check(t, n), this.#e.eval(t, n);
  }
}, wv = class extends Qw {
  constructor(t) {
    super(t), this.Error = J;
  }
  #t(t, n) {
    const r = t instanceof Array ? t[0] : t.values().next().value;
    return r === void 0 ? n : this.registry.getListType(this.debugRuntimeType(r, n.valueType));
  }
  #e(t) {
    if (t instanceof Map) return t.entries().next().value;
    for (const n in t) return [n, t[n]];
  }
  #n(t, n) {
    const r = this.#e(t);
    return r ? this.registry.getMapType(
      this.debugRuntimeType(r[0], n.keyType),
      this.debugRuntimeType(r[1], n.valueType)
    ) : n;
  }
  debugOperandType(t, n) {
    return n?.hasNoDynTypes() ? n : this.debugRuntimeType(t, n).wrappedType;
  }
  debugRuntimeType(t, n) {
    if (n?.hasNoDynTypes()) return n;
    const r = this.debugType(t);
    switch (r.kind) {
      case "list":
        return this.#t(t, r);
      case "map":
        return this.#n(t, r);
      default:
        return r;
    }
  }
  tryEval(t, n) {
    try {
      const r = this.eval(t, n);
      return r instanceof Promise ? r.catch((i) => i) : r;
    } catch (r) {
      return r;
    }
  }
  eval(t, n) {
    return t.evaluate(this, t, n);
  }
};
new Yc({
  unlistedVariablesAreDyn: !0
});
const ud = "amount", mv = "expiry", bv = "birth", Ev = "weight", xv = "inputType", Tv = "script", ns = {
  signature: "now(): double",
  implementation: () => Math.floor(Date.now() / 1e3)
}, Sp = new Yc().registerVariable(ud, "double").registerVariable(Tv, "string").registerFunction(ns.signature, ns.implementation), Sv = new Yc().registerVariable(ud, "double").registerVariable(mv, "double").registerVariable(bv, "double").registerVariable(Ev, "double").registerVariable(xv, "string").registerFunction(ns.signature, ns.implementation), vv = new Yc().registerVariable(ud, "double").registerFunction(ns.signature, ns.implementation);
let _e = class am {
  constructor(t) {
    this.value = t;
  }
  get satoshis() {
    return this.value ? Math.ceil(this.value) : 0;
  }
  add(t) {
    return new am(this.value + t.value);
  }
};
_e.ZERO = new _e(0);
let kv = class {
  /**
   * Creates a new Estimator with the given config
   * @param config - Configuration containing CEL programs for fee calculation
   */
  constructor(t) {
    this.config = t, this.intentOffchainInput = t.offchainInput ? Mo(t.offchainInput, Sv) : void 0, this.intentOnchainInput = t.onchainInput ? Mo(t.onchainInput, vv) : void 0, this.intentOffchainOutput = t.offchainOutput ? Mo(t.offchainOutput, Sp) : void 0, this.intentOnchainOutput = t.onchainOutput ? Mo(t.onchainOutput, Sp) : void 0;
  }
  /**
   * Evaluates the fee for a given vtxo input
   * @param input - The offchain input to evaluate
   * @returns The fee amount for this input
   */
  evalOffchainInput(t) {
    if (!this.intentOffchainInput)
      return _e.ZERO;
    const n = Av(t);
    return new _e(this.intentOffchainInput.program(n));
  }
  /**
   * Evaluates the fee for a given boarding input
   * @param input - The onchain input to evaluate
   * @returns The fee amount for this input
   */
  evalOnchainInput(t) {
    if (!this.intentOnchainInput)
      return _e.ZERO;
    const n = {
      amount: Number(t.amount)
    };
    return new _e(this.intentOnchainInput.program(n));
  }
  /**
   * Evaluates the fee for a given vtxo output
   * @param output - The output to evaluate
   * @returns The fee amount for this output
   */
  evalOffchainOutput(t) {
    if (!this.intentOffchainOutput)
      return _e.ZERO;
    const n = vp(t);
    return new _e(this.intentOffchainOutput.program(n));
  }
  /**
   * Evaluates the fee for a given collaborative exit output
   * @param output - The output to evaluate
   * @returns The fee amount for this output
   */
  evalOnchainOutput(t) {
    if (!this.intentOnchainOutput)
      return _e.ZERO;
    const n = vp(t);
    return new _e(this.intentOnchainOutput.program(n));
  }
  /**
   * Evaluates the fee for a given set of inputs and outputs
   * @param offchainInputs - Array of offchain inputs to evaluate
   * @param onchainInputs - Array of onchain inputs to evaluate
   * @param offchainOutputs - Array of offchain outputs to evaluate
   * @param onchainOutputs - Array of onchain outputs to evaluate
   * @returns The total fee amount
   */
  eval(t, n, r, i) {
    let s = _e.ZERO;
    for (const o of t)
      s = s.add(this.evalOffchainInput(o));
    for (const o of n)
      s = s.add(this.evalOnchainInput(o));
    for (const o of r)
      s = s.add(this.evalOffchainOutput(o));
    for (const o of i)
      s = s.add(this.evalOnchainOutput(o));
    return s;
  }
};
function Av(e) {
  const t = {
    amount: Number(e.amount),
    inputType: e.type,
    weight: e.weight
  };
  return e.expiry && (t.expiry = Math.floor(e.expiry.getTime() / 1e3)), e.birth && (t.birth = Math.floor(e.birth.getTime() / 1e3)), t;
}
function vp(e) {
  return {
    amount: Number(e.amount),
    script: e.script
  };
}
function Mo(e, t) {
  const n = t.parse(e), r = n.check();
  if (!r.valid)
    throw new Error(`type check failed: ${r.error?.message ?? "unknown error"}`);
  if (r.type !== "double")
    throw new Error(`expected return type double, got ${r.type}`);
  return { program: n, text: e };
}
const Bs = {
  commitmentTxid: "",
  boardingTxid: "",
  arkTxid: ""
};
async function $v(e, t, n, r) {
  const i = [...e].sort((u, l) => u.createdAt.getTime() - l.createdAt.getTime()), s = [];
  let o = [];
  for (const u of i)
    if (u.status.isLeaf ? !n.has(u.virtualStatus.commitmentTxIds[0]) && i.filter((l) => l.settledBy === u.virtualStatus.commitmentTxIds[0]).length === 0 && o.push({
      key: {
        ...Bs,
        commitmentTxid: u.virtualStatus.commitmentTxIds[0]
      },
      tag: "batch",
      type: Vn.TxReceived,
      amount: u.value,
      settled: u.status.isLeaf || u.isSpent,
      createdAt: u.createdAt.getTime()
    }) : i.filter((l) => l.arkTxId === u.txid).length === 0 && o.push({
      key: { ...Bs, arkTxid: u.txid },
      tag: "offchain",
      type: Vn.TxReceived,
      amount: u.value,
      settled: u.status.isLeaf || u.isSpent,
      createdAt: u.createdAt.getTime()
    }), u.isSpent) {
      if (u.arkTxId && !s.some((l) => l.key.arkTxid === u.arkTxId)) {
        const l = i.filter((p) => p.txid === u.arkTxId), h = i.filter((p) => p.arkTxId === u.arkTxId).reduce((p, y) => p + y.value, 0);
        let g = 0, d = 0;
        if (l.length > 0) {
          const p = l.reduce((y, x) => y + x.value, 0);
          g = h - p, d = l[0].createdAt.getTime();
        } else
          g = h, d = r ? await r(u.arkTxId) : u.createdAt.getTime() + 1;
        s.push({
          key: { ...Bs, arkTxid: u.arkTxId },
          tag: "offchain",
          type: Vn.TxSent,
          amount: g,
          settled: !0,
          createdAt: d
        });
      }
      if (u.settledBy && !n.has(u.settledBy) && !s.some((l) => l.key.commitmentTxid === u.settledBy)) {
        const l = i.filter((g) => g.status.isLeaf && g.virtualStatus.commitmentTxIds?.every((d) => u.settledBy === d)), h = i.filter((g) => g.settledBy === u.settledBy).reduce((g, d) => g + d.value, 0);
        if (l.length > 0) {
          const g = l.reduce((d, p) => d + p.value, 0);
          h > g && s.push({
            key: { ...Bs, commitmentTxid: u.settledBy },
            tag: "exit",
            type: Vn.TxSent,
            amount: h - g,
            settled: !0,
            createdAt: l[0].createdAt.getTime()
          });
        } else
          s.push({
            key: { ...Bs, commitmentTxid: u.settledBy },
            tag: "exit",
            type: Vn.TxSent,
            amount: h,
            settled: !0,
            // TODO: fetch commitment tx with /v1/indexer/commitmentTx/<commitmentTxid> to know when the tx was made
            createdAt: u.createdAt.getTime() + 1
          });
      }
    }
  return [...t.map((u) => ({ ...u, tag: "boarding" })), ...s, ...o].sort((u, l) => l.createdAt - u.createdAt);
}
const hn = "vtxos", pn = "utxos", gn = "transactions", pr = "walletState", De = "contracts", kp = "contractsCollections", cm = 2;
function um(e) {
  if (!e.objectStoreNames.contains(hn)) {
    const t = e.createObjectStore(hn, {
      keyPath: ["address", "txid", "vout"]
    });
    t.indexNames.contains("address") || t.createIndex("address", "address", {
      unique: !1
    }), t.indexNames.contains("txid") || t.createIndex("txid", "txid", { unique: !1 }), t.indexNames.contains("value") || t.createIndex("value", "value", { unique: !1 }), t.indexNames.contains("status") || t.createIndex("status", "status", {
      unique: !1
    }), t.indexNames.contains("virtualStatus") || t.createIndex("virtualStatus", "virtualStatus", {
      unique: !1
    }), t.indexNames.contains("createdAt") || t.createIndex("createdAt", "createdAt", {
      unique: !1
    }), t.indexNames.contains("isSpent") || t.createIndex("isSpent", "isSpent", {
      unique: !1
    }), t.indexNames.contains("isUnrolled") || t.createIndex("isUnrolled", "isUnrolled", {
      unique: !1
    }), t.indexNames.contains("spentBy") || t.createIndex("spentBy", "spentBy", {
      unique: !1
    }), t.indexNames.contains("settledBy") || t.createIndex("settledBy", "settledBy", {
      unique: !1
    }), t.indexNames.contains("arkTxId") || t.createIndex("arkTxId", "arkTxId", {
      unique: !1
    });
  }
  if (!e.objectStoreNames.contains(pn)) {
    const t = e.createObjectStore(pn, {
      keyPath: ["address", "txid", "vout"]
    });
    t.indexNames.contains("address") || t.createIndex("address", "address", {
      unique: !1
    }), t.indexNames.contains("txid") || t.createIndex("txid", "txid", { unique: !1 }), t.indexNames.contains("value") || t.createIndex("value", "value", { unique: !1 }), t.indexNames.contains("status") || t.createIndex("status", "status", {
      unique: !1
    });
  }
  if (!e.objectStoreNames.contains(gn)) {
    const t = e.createObjectStore(gn, {
      keyPath: [
        "address",
        "keyBoardingTxid",
        "keyCommitmentTxid",
        "keyArkTxid"
      ]
    });
    t.indexNames.contains("address") || t.createIndex("address", "address", {
      unique: !1
    }), t.indexNames.contains("type") || t.createIndex("type", "type", {
      unique: !1
    }), t.indexNames.contains("amount") || t.createIndex("amount", "amount", {
      unique: !1
    }), t.indexNames.contains("settled") || t.createIndex("settled", "settled", {
      unique: !1
    }), t.indexNames.contains("createdAt") || t.createIndex("createdAt", "createdAt", {
      unique: !1
    }), t.indexNames.contains("arkTxid") || t.createIndex("arkTxid", "key.arkTxid", {
      unique: !1
    });
  }
  if (e.objectStoreNames.contains(pr) || e.createObjectStore(pr, {
    keyPath: "key"
  }), !e.objectStoreNames.contains(De)) {
    const t = e.createObjectStore(De, {
      keyPath: "script"
    });
    t.indexNames.contains("type") || t.createIndex("type", "type", {
      unique: !1
    }), t.indexNames.contains("state") || t.createIndex("state", "state", {
      unique: !1
    });
  }
  e.objectStoreNames.contains(kp) || e.createObjectStore(kp, {
    keyPath: "key"
  });
}
const Ja = ([e, t]) => ({
  cb: D.encode(xn.encode(e)),
  s: D.encode(t)
}), Iv = (e) => ({
  ...e,
  tapTree: D.encode(e.tapTree),
  forfeitTapLeafScript: Ja(e.forfeitTapLeafScript),
  intentTapLeafScript: Ja(e.intentTapLeafScript),
  extraWitness: e.extraWitness?.map(D.encode)
}), Ov = (e) => ({
  ...e,
  tapTree: D.encode(e.tapTree),
  forfeitTapLeafScript: Ja(e.forfeitTapLeafScript),
  intentTapLeafScript: Ja(e.intentTapLeafScript),
  extraWitness: e.extraWitness?.map(D.encode)
}), tc = (e) => {
  const t = xn.decode(D.decode(e.cb)), n = D.decode(e.s);
  return [t, n];
}, Bv = (e) => ({
  ...e,
  createdAt: new Date(e.createdAt),
  tapTree: D.decode(e.tapTree),
  forfeitTapLeafScript: tc(e.forfeitTapLeafScript),
  intentTapLeafScript: tc(e.intentTapLeafScript),
  extraWitness: e.extraWitness?.map(D.decode)
}), Cv = (e) => ({
  ...e,
  tapTree: D.decode(e.tapTree),
  forfeitTapLeafScript: tc(e.forfeitTapLeafScript),
  intentTapLeafScript: tc(e.intentTapLeafScript),
  extraWitness: e.extraWitness?.map(D.decode)
});
function Rv() {
  if (typeof globalThis < "u")
    return typeof globalThis.self == "object" && globalThis.self !== null ? { globalObject: globalThis.self } : typeof globalThis.window == "object" && globalThis.window !== null ? { globalObject: globalThis.window } : { globalObject: globalThis };
  throw new Error("Global object not found");
}
const js = /* @__PURE__ */ new Map(), ii = /* @__PURE__ */ new Map();
async function ld(e, t, n) {
  const { globalObject: r } = Rv();
  if (!r.indexedDB)
    throw new Error("IndexedDB is not available in this environment");
  const i = js.get(e);
  if (i) {
    if (i.version !== t)
      throw new Error(`Database "${e}" already opened with version ${i.version}; requested ${t}`);
    return ii.set(e, (ii.get(e) ?? 0) + 1), i.promise;
  }
  const s = new Promise((o, a) => {
    const c = r.indexedDB.open(e, t);
    c.onerror = () => {
      js.delete(e), ii.delete(e), a(c.error);
    }, c.onsuccess = () => {
      o(c.result);
    }, c.onupgradeneeded = () => {
      const u = c.result;
      n(u);
    }, c.onblocked = () => {
      console.warn("Database upgrade blocked - close other tabs/connections");
    };
  });
  return js.set(e, { version: t, promise: s }), ii.set(e, 1), s;
}
async function fd(e) {
  const t = js.get(e);
  if (!t)
    return !1;
  const n = (ii.get(e) ?? 1) - 1;
  if (n > 0)
    return ii.set(e, n), !1;
  ii.delete(e), js.delete(e);
  try {
    (await t.promise).close();
  } catch {
  }
  return !0;
}
const lm = "arkade-service-worker";
let Pv = class {
  constructor(t = lm) {
    this.dbName = t, this.db = null;
  }
  async clear() {
    try {
      const t = await this.getDB();
      return new Promise((n, r) => {
        const i = t.transaction([De], "readwrite"), s = i.objectStore(De), o = i.objectStore(De), a = s.clear(), c = o.clear();
        let u = 0;
        const l = () => {
          u++, u === 2 && n();
        };
        a.onsuccess = l, c.onsuccess = l, a.onerror = () => r(a.error), c.onerror = () => r(c.error);
      });
    } catch (t) {
      throw console.error("Failed to clear contract data:", t), t;
    }
  }
  async getContracts(t) {
    try {
      const r = (await this.getDB()).transaction([De], "readonly").objectStore(De);
      if (!t || Object.keys(t).length === 0)
        return new Promise((o, a) => {
          const c = r.getAll();
          c.onerror = () => a(c.error), c.onsuccess = () => o(c.result ?? []);
        });
      const i = Lv(t);
      if (i.has("script")) {
        const o = i.get("script"), a = await Promise.all(o.map((c) => new Promise((u, l) => {
          const f = r.get(c);
          f.onerror = () => l(f.error), f.onsuccess = () => u(f.result);
        })));
        return this.applyContractFilter(a, i);
      }
      if (i.has("state")) {
        const o = await this.getContractsByIndexValues(r, "state", i.get("state"));
        return this.applyContractFilter(o, i);
      }
      if (i.has("type")) {
        const o = await this.getContractsByIndexValues(r, "type", i.get("type"));
        return this.applyContractFilter(o, i);
      }
      const s = await new Promise((o, a) => {
        const c = r.getAll();
        c.onerror = () => a(c.error), c.onsuccess = () => o(c.result ?? []);
      });
      return this.applyContractFilter(s, i);
    } catch (n) {
      return console.error("Failed to get contracts:", n), [];
    }
  }
  async saveContract(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const a = n.transaction([De], "readwrite").objectStore(De).put(t);
        a.onerror = () => i(a.error), a.onsuccess = () => r();
      });
    } catch (n) {
      throw console.error("Failed to save contract:", n), n;
    }
  }
  async deleteContract(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const o = n.transaction([De], "readwrite").objectStore(De), a = o.get(t);
        a.onerror = () => i(a.error), a.onsuccess = () => {
          const c = o.delete(t);
          c.onerror = () => i(c.error), c.onsuccess = () => r();
        };
      });
    } catch (n) {
      throw console.error(`Failed to delete contract ${t}:`, n), n;
    }
  }
  getContractsByIndexValues(t, n, r) {
    if (r.length === 0)
      return Promise.resolve([]);
    const i = t.index(n), s = r.map((o) => new Promise((a, c) => {
      const u = i.getAll(o);
      u.onerror = () => c(u.error), u.onsuccess = () => a(u.result ?? []);
    }));
    return Promise.all(s).then((o) => o.flatMap((a) => a));
  }
  applyContractFilter(t, n) {
    return t.filter((r) => !(r === void 0 || n.has("script") && !n.get("script")?.includes(r.script) || n.has("state") && !n.get("state")?.includes(r.state) || n.has("type") && !n.get("type")?.includes(r.type)));
  }
  async getDB() {
    return this.db ? this.db : (this.db = await ld(this.dbName, cm, um), this.db);
  }
  async [Symbol.asyncDispose]() {
    this.db && (await fd(this.dbName), this.db = null);
  }
};
const Nv = ["script", "state", "type"];
function Lv(e) {
  const t = /* @__PURE__ */ new Map();
  return Nv.forEach((n) => {
    e?.[n] && (Array.isArray(e[n]) ? t.set(n, e[n]) : t.set(n, [e[n]]));
  }), t;
}
let Uv = class {
  constructor(t = lm) {
    this.dbName = t, this.db = null;
  }
  async clear() {
    try {
      const t = await this.getDB();
      return new Promise((n, r) => {
        const i = t.transaction([
          hn,
          pn,
          gn,
          pr
        ], "readwrite"), s = i.objectStore(hn), o = i.objectStore(pn), a = i.objectStore(gn), c = i.objectStore(pr), u = [
          s.clear(),
          o.clear(),
          a.clear(),
          c.clear()
        ];
        let l = 0;
        const f = () => {
          l++, l === u.length && n();
        };
        u.forEach((h) => {
          h.onsuccess = f, h.onerror = () => r(h.error);
        });
      });
    } catch (t) {
      throw console.error("Failed to clear wallet data:", t), t;
    }
  }
  async [Symbol.asyncDispose]() {
    this.db && (await fd(this.dbName), this.db = null);
  }
  async getVtxos(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const c = n.transaction([hn], "readonly").objectStore(hn).index("address").getAll(t);
        c.onerror = () => i(c.error), c.onsuccess = () => {
          const l = (c.result || []).map(Bv);
          r(l);
        };
      });
    } catch (n) {
      return console.error(`Failed to get VTXOs for address ${t}:`, n), [];
    }
  }
  async saveVtxos(t, n) {
    try {
      const r = await this.getDB();
      return new Promise((i, s) => {
        const o = r.transaction([hn], "readwrite"), a = o.objectStore(hn), c = n.map((u) => new Promise((l, f) => {
          const h = Iv(u), g = {
            address: t,
            ...h
          }, d = a.put(g);
          d.onerror = () => f(d.error), d.onsuccess = () => l();
        }));
        Promise.all(c).then(() => i()).catch(s), o.onerror = () => s(o.error);
      });
    } catch (r) {
      throw console.error(`Failed to save VTXOs for address ${t}:`, r), r;
    }
  }
  async deleteVtxos(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const c = n.transaction([hn], "readwrite").objectStore(hn).index("address").openCursor(IDBKeyRange.only(t));
        c.onerror = () => i(c.error), c.onsuccess = () => {
          const u = c.result;
          u ? (u.delete(), u.continue()) : r();
        };
      });
    } catch (n) {
      throw console.error(`Failed to clear VTXOs for address ${t}:`, n), n;
    }
  }
  async getUtxos(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const c = n.transaction([pn], "readonly").objectStore(pn).index("address").getAll(t);
        c.onerror = () => i(c.error), c.onsuccess = () => {
          const l = (c.result || []).map(Cv);
          r(l);
        };
      });
    } catch (n) {
      return console.error(`Failed to get UTXOs for address ${t}:`, n), [];
    }
  }
  async saveUtxos(t, n) {
    try {
      const r = await this.getDB();
      return new Promise((i, s) => {
        const o = r.transaction([pn], "readwrite"), a = o.objectStore(pn), c = n.map((u) => new Promise((l, f) => {
          const h = Ov(u), g = {
            address: t,
            ...h
          }, d = a.put(g);
          d.onerror = () => f(d.error), d.onsuccess = () => l();
        }));
        Promise.all(c).then(() => i()).catch(s), o.onerror = () => s(o.error);
      });
    } catch (r) {
      throw console.error(`Failed to save UTXOs for address ${t}:`, r), r;
    }
  }
  async deleteUtxos(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const c = n.transaction([pn], "readwrite").objectStore(pn).index("address").openCursor(IDBKeyRange.only(t));
        c.onerror = () => i(c.error), c.onsuccess = () => {
          const u = c.result;
          u ? (u.delete(), u.continue()) : r();
        };
      });
    } catch (n) {
      throw console.error(`Failed to clear UTXOs for address ${t}:`, n), n;
    }
  }
  async getTransactionHistory(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const c = n.transaction([gn], "readonly").objectStore(gn).index("address").getAll(t);
        c.onerror = () => i(c.error), c.onsuccess = () => {
          const u = c.result || [];
          r(u.sort((l, f) => l.createdAt - f.createdAt));
        };
      });
    } catch (n) {
      return console.error(`Failed to get transaction history for address ${t}:`, n), [];
    }
  }
  async saveTransactions(t, n) {
    try {
      const r = await this.getDB();
      return new Promise((i, s) => {
        const o = r.transaction([gn], "readwrite"), a = o.objectStore(gn);
        n.forEach((c) => {
          const u = {
            address: t,
            ...c,
            keyBoardingTxid: c.key.boardingTxid,
            keyCommitmentTxid: c.key.commitmentTxid,
            keyArkTxid: c.key.arkTxid
          };
          a.put(u);
        }), o.oncomplete = () => i(), o.onerror = () => s(o.error), o.onabort = () => s(new Error("Transaction aborted"));
      });
    } catch (r) {
      throw console.error(`Failed to save transactions for address ${t}:`, r), r;
    }
  }
  async deleteTransactions(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const c = n.transaction([gn], "readwrite").objectStore(gn).index("address").openCursor(IDBKeyRange.only(t));
        c.onerror = () => i(c.error), c.onsuccess = () => {
          const u = c.result;
          u ? (u.delete(), u.continue()) : r();
        };
      });
    } catch (n) {
      throw console.error(`Failed to clear transactions for address ${t}:`, n), n;
    }
  }
  async getWalletState() {
    try {
      const t = await this.getDB();
      return new Promise((n, r) => {
        const o = t.transaction([pr], "readonly").objectStore(pr).get("state");
        o.onerror = () => r(o.error), o.onsuccess = () => {
          const a = o.result;
          a && a.data ? n(a.data) : n(null);
        };
      });
    } catch (t) {
      return console.error("Failed to get wallet state:", t), null;
    }
  }
  async saveWalletState(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const o = n.transaction([pr], "readwrite").objectStore(pr), a = {
          key: "state",
          data: t
        }, c = o.put(a);
        c.onerror = () => i(c.error), c.onsuccess = () => r();
      });
    } catch (n) {
      throw console.error("Failed to save wallet state:", n), n;
    }
  }
  async getDB() {
    return this.db ? this.db : (this.db = await ld(this.dbName, cm, um), this.db);
  }
}, _v = class {
  constructor(t) {
    this.contracts = /* @__PURE__ */ new Map(), this.isWatching = !1, this.connectionState = "disconnected", this.reconnectAttempts = 0, this.config = {
      failsafePollIntervalMs: 6e4,
      // 1 minute
      reconnectDelayMs: 1e3,
      // 1 second
      maxReconnectDelayMs: 3e4,
      // 30 seconds
      maxReconnectAttempts: 0,
      // unlimited
      ...t
    };
  }
  /**
   * Add a contract to be watched.
   *
   * Active contracts are immediately subscribed. All contracts are polled
   * to discover any existing VTXOs (which may cause them to be watched
   * even if inactive).
   */
  async addContract(t) {
    const n = {
      contract: t,
      lastKnownVtxos: /* @__PURE__ */ new Map()
    };
    this.contracts.set(t.script, n), this.isWatching && (await this.pollContracts([t.script]), await this.tryUpdateSubscription());
  }
  /**
   * Update an existing contract.
   */
  async updateContract(t) {
    const n = this.contracts.get(t.script);
    if (!n)
      throw new Error(`Contract ${t.script} not found`);
    n.contract = t, this.isWatching && await this.tryUpdateSubscription();
  }
  /**
   * Remove a contract from watching.
   */
  async removeContract(t) {
    this.contracts.get(t) && (this.contracts.delete(t), this.isWatching && await this.tryUpdateSubscription());
  }
  /**
   * Get all in-memory contracts.
   */
  getAllContracts() {
    return Array.from(this.contracts.values()).map((t) => t.contract);
  }
  /**
   * Get all active in-memory contracts.
   */
  getActiveContracts() {
    return this.getAllContracts().filter((t) => t.state === "active");
  }
  /**
   * Get scripts that should be watched.
   *
   * Returns scripts for:
   * - All active contracts
   * - All contracts with known VTXOs (regardless of state)
   *
   * This ensures we continue monitoring contracts even after they're
   * deactivated, as long as they have unspent VTXOs.
   */
  getScriptsToWatch() {
    const t = /* @__PURE__ */ new Set();
    for (const [, n] of this.contracts) {
      if (n.contract.state === "active") {
        t.add(n.contract.script);
        continue;
      }
      n.lastKnownVtxos.size > 0 && t.add(n.contract.script);
    }
    return Array.from(t);
  }
  /**
   * Get VTXOs for contracts, grouped by contract script.
   * Uses Repository.
   */
  async getContractVtxos(t) {
    const { contractScripts: n, includeSpent: r } = t, i = this.config.walletRepository, o = Array.from(this.contracts.values()).filter((c) => !(n && !n.includes(c.contract.script))).map(async (c) => {
      const u = await i.getVtxos(c.contract.address);
      if (u.length > 0) {
        const l = u.map((h) => ({
          ...h,
          contractScript: c.contract.script
        })), f = r ? l : l.filter((h) => !h.isSpent);
        return [[c.contract.script, f]];
      }
      return [];
    }), a = await Promise.all(o);
    return new Map(a.flat(1));
  }
  /**
   * Start watching for VTXO events across all active contracts.
   */
  async startWatching(t) {
    if (this.isWatching)
      throw new Error("Already watching");
    return this.eventCallback = t, this.isWatching = !0, this.abortController = new AbortController(), this.reconnectAttempts = 0, await this.connect(), this.startFailsafePolling(), () => this.stopWatching();
  }
  /**
   * Stop watching for events.
   */
  async stopWatching() {
    if (this.isWatching = !1, this.connectionState = "disconnected", this.abortController?.abort(), this.reconnectTimeoutId && (clearTimeout(this.reconnectTimeoutId), this.reconnectTimeoutId = void 0), this.failsafePollIntervalId && (clearInterval(this.failsafePollIntervalId), this.failsafePollIntervalId = void 0), this.subscriptionId) {
      try {
        await this.config.indexerProvider.unsubscribeForScripts(this.subscriptionId);
      } catch {
      }
      this.subscriptionId = void 0;
    }
    this.eventCallback = void 0;
  }
  /**
   * Check if currently watching.
   */
  isCurrentlyWatching() {
    return this.isWatching;
  }
  /**
   * Get current connection state.
   */
  getConnectionState() {
    return this.connectionState;
  }
  /**
   * Force a poll of all active contracts.
   * Useful for manual refresh or after app resume.
   */
  async forcePoll() {
    this.isWatching && await this.pollAllContracts();
  }
  /**
   * Check for expired contracts, update their state, and emit events.
   */
  checkExpiredContracts() {
    const t = Date.now();
    for (const n of this.contracts.values()) {
      const r = n.contract;
      r.state === "active" && r.expiresAt && r.expiresAt <= t && (r.state = "inactive", this.eventCallback?.({
        type: "contract_expired",
        contractScript: r.script,
        contract: r,
        timestamp: t
      }));
    }
  }
  /**
   * Connect to the subscription.
   */
  async connect() {
    if (this.isWatching) {
      this.connectionState = "connecting";
      try {
        await this.updateSubscription(), await this.pollAllContracts(), this.connectionState = "connected", this.reconnectAttempts = 0, this.listenLoop().catch((t) => {
          console.error(t), this.connectionState = "disconnected", this.eventCallback?.({
            type: "connection_reset",
            timestamp: Date.now()
          }), this.scheduleReconnect();
        });
      } catch (t) {
        console.error("ContractWatcher connection failed:", t), this.connectionState = "disconnected", this.eventCallback?.({
          type: "connection_reset",
          timestamp: Date.now()
        }), this.scheduleReconnect();
      }
    }
  }
  /**
   * Schedule a reconnection attempt.
   */
  scheduleReconnect() {
    if (!this.isWatching)
      return;
    if (this.config.maxReconnectAttempts > 0 && this.reconnectAttempts >= this.config.maxReconnectAttempts) {
      console.error(`ContractWatcher: Max reconnection attempts (${this.config.maxReconnectAttempts}) reached`);
      return;
    }
    this.connectionState = "reconnecting", this.reconnectAttempts++;
    const t = Math.min(this.config.reconnectDelayMs * Math.pow(2, this.reconnectAttempts - 1), this.config.maxReconnectDelayMs);
    this.reconnectTimeoutId = setTimeout(() => {
      this.reconnectTimeoutId = void 0, this.connect();
    }, t);
  }
  /**
   * Start the failsafe polling interval.
   */
  startFailsafePolling() {
    this.failsafePollIntervalId && clearInterval(this.failsafePollIntervalId), this.failsafePollIntervalId = setInterval(() => {
      this.isWatching && this.pollAllContracts().catch((t) => {
        console.error("ContractWatcher failsafe poll failed:", t);
      });
    }, this.config.failsafePollIntervalMs);
  }
  /**
   * Poll all active contracts for current state.
   */
  async pollAllContracts() {
    const t = this.getActiveContracts().map((n) => n.script);
    t.length !== 0 && await this.pollContracts(t);
  }
  /**
   * Poll specific contracts and emit events for changes.
   */
  async pollContracts(t) {
    if (!this.eventCallback)
      return;
    const n = Date.now();
    try {
      const r = await this.getContractVtxos({
        contractScripts: t,
        includeSpent: !1
        // only spendable ones!
      });
      for (const i of t) {
        const s = this.contracts.get(i);
        if (!s)
          continue;
        const o = r.get(i) || [], a = new Set(o.map((l) => `${l.txid}:${l.vout}`)), c = [];
        for (const l of o) {
          const f = `${l.txid}:${l.vout}`;
          s.lastKnownVtxos.has(f) || (c.push(l), s.lastKnownVtxos.set(f, l));
        }
        const u = [];
        for (const [l, f] of s.lastKnownVtxos)
          a.has(l) || (u.push(f), s.lastKnownVtxos.delete(l));
        c.length > 0 && this.emitVtxoEvent(i, c, "vtxo_received", n), u.length > 0 && this.emitVtxoEvent(i, u, "vtxo_spent", n);
      }
    } catch (r) {
      console.error("ContractWatcher poll failed:", r);
    }
  }
  async tryUpdateSubscription() {
    try {
      await this.updateSubscription();
    } catch {
    }
  }
  /**
   * Update the subscription with scripts that should be watched.
   *
   * Watches both active contracts and contracts with VTXOs.
   */
  async updateSubscription() {
    const t = this.getScriptsToWatch();
    if (t.length === 0) {
      if (this.subscriptionId) {
        try {
          await this.config.indexerProvider.unsubscribeForScripts(this.subscriptionId);
        } catch {
        }
        this.subscriptionId = void 0;
      }
      return;
    }
    this.subscriptionId = await this.config.indexerProvider.subscribeForScripts(t, this.subscriptionId);
  }
  /**
   * Main listening loop for subscription events.
   */
  async listenLoop() {
    if (!this.subscriptionId || !this.abortController || !this.isWatching) {
      this.isWatching && (this.connectionState = "disconnected", this.scheduleReconnect());
      return;
    }
    const t = this.config.indexerProvider.getSubscription(this.subscriptionId, this.abortController.signal);
    for await (const n of t) {
      if (!this.isWatching)
        break;
      this.handleSubscriptionUpdate(n);
    }
    this.isWatching && (this.connectionState = "disconnected", this.scheduleReconnect());
  }
  /**
   * Handle a subscription update.
   */
  handleSubscriptionUpdate(t) {
    if (!this.eventCallback)
      return;
    const n = Date.now(), r = t.scripts || [];
    t.newVtxos?.length && this.processSubscriptionVtxos(t.newVtxos, r, "vtxo_received", n), t.spentVtxos?.length && this.processSubscriptionVtxos(t.spentVtxos, r, "vtxo_spent", n);
  }
  /**
   * Process VTXOs from subscription and route to correct contracts.
   * Uses the scripts from the subscription response to determine contract ownership.
   */
  processSubscriptionVtxos(t, n, r, i) {
    if (n.length === 1) {
      const s = n[0];
      if (s) {
        const o = this.contracts.get(s);
        if (o)
          for (const a of t) {
            const c = `${a.txid}:${a.vout}`;
            r === "vtxo_received" ? o.lastKnownVtxos.set(c, a) : r === "vtxo_spent" && o.lastKnownVtxos.delete(c);
          }
        this.emitVtxoEvent(s, t, r, i);
      }
      return;
    }
    for (const s of n) {
      const o = s;
      if (o) {
        const a = this.contracts.get(o);
        if (a)
          for (const c of t) {
            const u = `${c.txid}:${c.vout}`;
            r === "vtxo_received" ? a.lastKnownVtxos.set(u, c) : a.lastKnownVtxos.delete(u);
          }
        this.emitVtxoEvent(o, t, r, i);
      }
    }
  }
  /**
   * Emit a VTXO event for a contract.
   */
  emitVtxoEvent(t, n, r, i) {
    if (!this.eventCallback)
      return;
    const s = this.contracts.get(t);
    switch (this.checkExpiredContracts(), r) {
      case "vtxo_received":
        if (!s)
          return;
        this.eventCallback({
          type: "vtxo_received",
          vtxos: n.map((o) => ({
            ...o,
            contractScript: t,
            // These fields may not be available from basic VirtualCoin
            forfeitTapLeafScript: void 0,
            intentTapLeafScript: void 0,
            tapTree: void 0
          })),
          contractScript: t,
          contract: s.contract,
          timestamp: i
        });
        return;
      case "vtxo_spent":
        if (!s)
          return;
        this.eventCallback({
          type: "vtxo_spent",
          vtxos: n.map((o) => ({
            ...o,
            contractScript: t,
            // These fields may not be available from basic VirtualCoin
            forfeitTapLeafScript: void 0,
            intentTapLeafScript: void 0,
            tapTree: void 0
          })),
          contractScript: t,
          contract: s.contract,
          timestamp: i
        });
        return;
      case "contract_expired":
        if (!s)
          return;
        this.eventCallback({
          type: "contract_expired",
          contractScript: t,
          contract: s.contract,
          timestamp: i
        });
        return;
      default:
        return;
    }
  }
}, Dv = class {
  constructor() {
    this.handlers = /* @__PURE__ */ new Map();
  }
  /**
   * Register a contract handler.
   *
   * @param handler - The handler to register
   * @throws If a handler for this type is already registered
   */
  register(t) {
    if (this.handlers.has(t.type))
      throw new Error(`Contract handler for type '${t.type}' is already registered`);
    this.handlers.set(t.type, t);
  }
  /**
   * Get a handler by type.
   *
   * @param type - The contract type
   * @returns The handler, or undefined if not found
   */
  get(t) {
    return this.handlers.get(t);
  }
  /**
   * Get a handler by type, throwing if not found.
   *
   * @param type - The contract type
   * @returns The handler
   * @throws If no handler is registered for this type
   */
  getOrThrow(t) {
    const n = this.get(t);
    if (!n)
      throw new Error(`No contract handler registered for type '${t}'`);
    return n;
  }
  /**
   * Check if a handler is registered.
   *
   * @param type - The contract type
   */
  has(t) {
    return this.handlers.has(t);
  }
  /**
   * Get all registered types.
   */
  getRegisteredTypes() {
    return Array.from(this.handlers.keys());
  }
  /**
   * Unregister a handler (mainly for testing).
   */
  unregister(t) {
    return this.handlers.delete(t);
  }
  /**
   * Clear all handlers (mainly for testing).
   */
  clear() {
    this.handlers.clear();
  }
};
const zs = new Dv();
function qs(e) {
  return lo.encode(e.type === "blocks" ? { blocks: Number(e.value) } : { seconds: Number(e.value) });
}
function Gs(e) {
  const t = lo.decode(e);
  if ("blocks" in t && t.blocks !== void 0)
    return { type: "blocks", value: BigInt(t.blocks) };
  if ("seconds" in t && t.seconds !== void 0)
    return { type: "seconds", value: BigInt(t.seconds) };
  throw new Error(`Invalid BIP68 sequence: ${e}`);
}
function Vu(e, t) {
  if (t.role === "sender" || t.role === "receiver")
    return t.role;
  if (t.walletPubKey) {
    if (t.walletPubKey === e.params.sender)
      return "sender";
    if (t.walletPubKey === e.params.receiver)
      return "receiver";
  }
}
function Pi(e, t) {
  if (t === void 0)
    return !0;
  if (!e.vtxo)
    return !1;
  const n = Gs(t);
  if (n.type === "blocks")
    return e.blockHeight === void 0 || e.vtxo.status.block_height === void 0 ? !1 : e.blockHeight - e.vtxo.status.block_height >= Number(n.value);
  if (n.type === "seconds") {
    const r = e.vtxo.status.block_time;
    return r === void 0 ? !1 : e.currentTime / 1e3 - r >= Number(n.value);
  }
  return !1;
}
const Vv = {
  type: "default",
  createScript(e) {
    const t = this.deserializeParams(e);
    return new di.Script(t);
  },
  serializeParams(e) {
    return {
      pubKey: D.encode(e.pubKey),
      serverPubKey: D.encode(e.serverPubKey),
      csvTimelock: qs(e.csvTimelock).toString()
    };
  },
  deserializeParams(e) {
    const t = e.csvTimelock ? Gs(Number(e.csvTimelock)) : di.Script.DEFAULT_TIMELOCK;
    return {
      pubKey: D.decode(e.pubKey),
      serverPubKey: D.decode(e.serverPubKey),
      csvTimelock: t
    };
  },
  selectPath(e, t, n) {
    if (n.collaborative)
      return { leaf: e.forfeit() };
    const r = t.params.csvTimelock ? Number(t.params.csvTimelock) : void 0;
    return Pi(n, r) ? {
      leaf: e.exit(),
      sequence: r
    } : null;
  },
  getAllSpendingPaths(e, t, n) {
    const r = [];
    n.collaborative && r.push({ leaf: e.forfeit() });
    const i = { leaf: e.exit() };
    return t.params.csvTimelock && (i.sequence = Number(t.params.csvTimelock)), r.push(i), r;
  },
  getSpendablePaths(e, t, n) {
    const r = [];
    n.collaborative && r.push({ leaf: e.forfeit() });
    const i = t.params.csvTimelock ? Number(t.params.csvTimelock) : void 0;
    if (Pi(n, i)) {
      const s = { leaf: e.exit() };
      i !== void 0 && (s.sequence = i), r.push(s);
    }
    return r;
  }
}, Mv = {
  type: "vhtlc",
  createScript(e) {
    const t = this.deserializeParams(e);
    return new Ga.Script(t);
  },
  serializeParams(e) {
    return {
      sender: D.encode(e.sender),
      receiver: D.encode(e.receiver),
      server: D.encode(e.server),
      hash: D.encode(e.preimageHash),
      refundLocktime: e.refundLocktime.toString(),
      claimDelay: qs(e.unilateralClaimDelay).toString(),
      refundDelay: qs(e.unilateralRefundDelay).toString(),
      refundNoReceiverDelay: qs(e.unilateralRefundWithoutReceiverDelay).toString()
    };
  },
  deserializeParams(e) {
    return {
      sender: D.decode(e.sender),
      receiver: D.decode(e.receiver),
      server: D.decode(e.server),
      preimageHash: D.decode(e.hash),
      refundLocktime: BigInt(e.refundLocktime),
      unilateralClaimDelay: Gs(Number(e.claimDelay)),
      unilateralRefundDelay: Gs(Number(e.refundDelay)),
      unilateralRefundWithoutReceiverDelay: Gs(Number(e.refundNoReceiverDelay))
    };
  },
  /**
   * Select spending path based on context.
   *
   * Role is determined from `context.role` or by matching `context.walletPubKey`
   * against sender/receiver in contract params.
   */
  selectPath(e, t, n) {
    const r = Vu(t, n), i = t.params?.preimage, s = BigInt(t.params.refundLocktime), o = Math.floor(n.currentTime / 1e3);
    if (!r)
      return null;
    if (n.collaborative)
      return r === "receiver" && i ? {
        leaf: e.claim(),
        extraWitness: [D.decode(i)]
      } : r === "sender" && BigInt(o) >= s ? {
        leaf: e.refundWithoutReceiver()
      } : null;
    if (r === "receiver" && i) {
      const a = Number(t.params.claimDelay);
      return Pi(n, a) ? {
        leaf: e.unilateralClaim(),
        extraWitness: [D.decode(i)],
        sequence: a
      } : null;
    }
    if (r === "sender") {
      const a = Number(t.params.refundNoReceiverDelay);
      return Pi(n, a) ? {
        leaf: e.unilateralRefundWithoutReceiver(),
        sequence: a
      } : null;
    }
    return null;
  },
  /**
   * Get all possible spending paths (no timelock checks).
   *
   * Role is determined from `context.role` or by matching `context.walletPubKey`
   * against sender/receiver in contract params.
   */
  getAllSpendingPaths(e, t, n) {
    const r = Vu(t, n), i = [];
    if (!r)
      return i;
    const s = t.params?.preimage;
    if (n.collaborative)
      r === "receiver" && s && i.push({
        leaf: e.claim(),
        extraWitness: [D.decode(s)]
      }), r === "sender" && i.push({
        leaf: e.refundWithoutReceiver()
      });
    else {
      if (r === "receiver" && s) {
        const o = Number(t.params.claimDelay);
        i.push({
          leaf: e.unilateralClaim(),
          extraWitness: [D.decode(s)],
          sequence: o
        });
      }
      if (r === "sender") {
        const o = Number(t.params.refundNoReceiverDelay);
        i.push({
          leaf: e.unilateralRefundWithoutReceiver(),
          sequence: o
        });
      }
    }
    return i;
  },
  getSpendablePaths(e, t, n) {
    const r = Vu(t, n), i = [];
    if (!r)
      return i;
    const s = t.params?.preimage, o = BigInt(t.params.refundLocktime), a = Math.floor(n.currentTime / 1e3);
    if (n.collaborative)
      return r === "receiver" && s && i.push({
        leaf: e.claim(),
        extraWitness: [D.decode(s)]
      }), r === "sender" && BigInt(a) >= o && i.push({
        leaf: e.refundWithoutReceiver()
      }), i;
    if (r === "receiver" && s) {
      const c = Number(t.params.claimDelay);
      Pi(n, c) && i.push({
        leaf: e.unilateralClaim(),
        extraWitness: [D.decode(s)],
        sequence: c
      });
    }
    if (r === "sender") {
      const c = Number(t.params.refundNoReceiverDelay);
      Pi(n, c) && i.push({
        leaf: e.unilateralRefundWithoutReceiver(),
        sequence: c
      });
    }
    return i;
  }
};
zs.register(Vv);
zs.register(Mv);
let Fv = class fm {
  constructor(t) {
    this.initialized = !1, this.eventCallbacks = /* @__PURE__ */ new Set(), this.config = t, this.watcher = new _v({
      indexerProvider: t.indexerProvider,
      walletRepository: t.walletRepository,
      ...t.watcherConfig
    });
  }
  /**
   * Static factory method for creating a new ContractManager.
   * Initialize the manager by loading persisted contracts and starting to watch.
   *
   * After initialization, the manager automatically watches all active contracts
   * and contracts with VTXOs. Use `onContractEvent()` to register event callbacks.
   *
   * @param config ContractManagerConfig
   */
  static async create(t) {
    const n = new fm(t);
    return await n.initialize(), n;
  }
  async initialize() {
    if (this.initialized)
      return;
    const t = await this.config.contractRepository.getContracts();
    await this.getVtxosForContracts(t);
    const n = Date.now();
    for (const r of t)
      r.state === "active" && r.expiresAt && r.expiresAt <= n && (r.state = "inactive", await this.config.contractRepository.saveContract(r)), await this.watcher.addContract(r);
    this.initialized = !0, this.stopWatcherFn = await this.watcher.startWatching((r) => {
      this.handleContractEvent(r);
    });
  }
  /**
   * Create and register a new contract.
   *
   * @param params - Contract parameters
   * @returns The created contract
   */
  async createContract(t) {
    const n = zs.get(t.type);
    if (!n)
      throw new Error(`No handler registered for contract type '${t.type}'`);
    try {
      const s = n.createScript(t.params), o = D.encode(s.pkScript);
      if (o !== t.script)
        throw new Error(`Script mismatch: provided script does not match script derived from params. Expected ${o}, got ${t.script}`);
    } catch (s) {
      throw s instanceof Error && s.message.includes("mismatch") ? s : new Error(`Invalid params for contract type '${t.type}': ${s instanceof Error ? s.message : String(s)}`);
    }
    const [r] = await this.getContracts({ script: t.script });
    if (r) {
      if (r.type === t.type)
        return r;
      throw new Error(`Contract with script ${t.script} already exists with with type ${r.type}.`);
    }
    const i = {
      ...t,
      createdAt: Date.now(),
      state: t.state || "active"
    };
    return await this.config.contractRepository.saveContract(i), await this.getVtxosForContracts([i]), await this.watcher.addContract(i), i;
  }
  /**
   * Get contracts with optional filters.
   *
   * @param filter - Optional filter criteria
   * @returns Filtered contracts TODO: filter spent/unspent
   *
   * @example
   * ```typescript
   * // Get all VHTLC contracts
   * const vhtlcs = await manager.getContracts({ type: 'vhtlc' });
   *
   * // Get all active contracts
   * const active = await manager.getContracts({ state: 'active' });
   * ```
   */
  async getContracts(t) {
    const n = this.buildContractsDbFilter(t ?? {});
    return await this.config.contractRepository.getContracts(n);
  }
  async getContractsWithVtxos(t) {
    const n = await this.getContracts(t), r = await this.getVtxosForContracts(n);
    return n.map((i) => ({
      contract: i,
      vtxos: r.get(i.script) ?? []
    }));
  }
  buildContractsDbFilter(t) {
    return {
      script: t.script,
      state: t.state,
      type: t.type
    };
  }
  /**
   * Update a contract.
   * Nested fields like `params` and `metadata` are replaced with the provided values.
   * If you need to preserve existing fields, merge them manually.
   *
   * @param script - Contract script
   * @param updates - Fields to update
   */
  async updateContract(t, n) {
    const i = (await this.config.contractRepository.getContracts({
      script: t
    }))[0];
    if (!i)
      throw new Error(`Contract ${t} not found`);
    const s = {
      ...i,
      ...n
    };
    return await this.config.contractRepository.saveContract(s), await this.watcher.updateContract(s), s;
  }
  /**
   * Update a contract's params.
   * This method preserves existing params by merging the provided values.
   *
   * @param script - Contract script
   * @param updates - The new values to merge with existing params
   */
  async updateContractParams(t, n) {
    const i = (await this.config.contractRepository.getContracts({
      script: t
    }))[0];
    if (!i)
      throw new Error(`Contract ${t} not found`);
    const s = {
      ...i,
      params: { ...i.params, ...n }
    };
    return await this.config.contractRepository.saveContract(s), await this.watcher.updateContract(s), s;
  }
  /**
   * Set a contract's state.
   */
  async setContractState(t, n) {
    await this.updateContract(t, { state: n });
  }
  /**
   * Delete a contract.
   *
   * @param script - Contract script
   */
  async deleteContract(t) {
    await this.config.contractRepository.deleteContract(t), await this.watcher.removeContract(t);
  }
  /**
   * Get currently spendable paths for a contract.
   *
   * @param contractScript - The contract script
   * @param options - Options for getting spendable paths
   */
  async getSpendablePaths(t) {
    const { contractScript: n, collaborative: r = !0, walletPubKey: i, vtxo: s } = t, [o] = await this.getContracts({ script: n });
    if (!o)
      return [];
    const a = zs.get(o.type);
    if (!a)
      return [];
    const c = a.createScript(o.params), u = {
      collaborative: r,
      currentTime: Date.now(),
      walletPubKey: i,
      vtxo: s
    };
    return a.getSpendablePaths(c, o, u);
  }
  async getAllSpendingPaths(t) {
    const { contractScript: n, collaborative: r = !0, walletPubKey: i } = t, [s] = await this.getContracts({ script: n });
    if (!s)
      return [];
    const o = zs.get(s.type);
    if (!o)
      return [];
    const a = o.createScript(s.params), c = {
      collaborative: r,
      currentTime: Date.now(),
      walletPubKey: i
    };
    return o.getAllSpendingPaths(a, s, c);
  }
  /**
   * Register a callback for contract events.
   *
   * The manager automatically watches after `initialize()`. This method
   * allows registering callbacks to receive events.
   *
   * @param callback - Event callback
   * @returns Unsubscribe function to remove this callback
   *
   * @example
   * ```typescript
   * const unsubscribe = manager.onContractEvent((event) => {
   *   console.log(`${event.type} on ${event.contractScript}`);
   * });
   *
   * // Later: stop receiving events
   * unsubscribe();
   * ```
   */
  onContractEvent(t) {
    return this.eventCallbacks.add(t), () => {
      this.eventCallbacks.delete(t);
    };
  }
  /**
   * Check if currently watching.
   */
  async isWatching() {
    return this.watcher.isCurrentlyWatching();
  }
  /**
   * Emit an event to all registered callbacks.
   */
  emitEvent(t) {
    for (const n of this.eventCallbacks)
      try {
        n(t);
      } catch (r) {
        console.error("Error in contract event callback:", r);
      }
  }
  /**
   * Handle events from the watcher.
   */
  async handleContractEvent(t) {
    switch (t.type) {
      // Every time there is a VTXO event for a contract, refresh all its VTXOs
      case "vtxo_received":
      case "vtxo_spent":
        await this.fetchContractVxosFromIndexer([t.contract], !0);
        break;
      case "connection_reset":
        const n = this.watcher.getActiveContracts();
        await this.fetchContractVxosFromIndexer(n, !1);
        break;
      case "contract_expired":
        await this.config.contractRepository.saveContract(t.contract);
    }
    this.emitEvent(t);
  }
  async getVtxosForContracts(t) {
    return t.length === 0 ? /* @__PURE__ */ new Map() : await this.fetchContractVxosFromIndexer(t, !1);
  }
  async fetchContractVxosFromIndexer(t, n) {
    const r = await this.fetchContractVtxosBulk(t, n), i = /* @__PURE__ */ new Map();
    for (const [s, o] of r) {
      i.set(s, o);
      const a = t.find((c) => c.script === s);
      a && await this.config.walletRepository.saveVtxos(a.address, o);
    }
    return i;
  }
  async fetchContractVtxosBulk(t, n) {
    const r = /* @__PURE__ */ new Map();
    return await Promise.all(t.map(async (i) => {
      const s = await this.fetchContractVtxosPaginated(i, n);
      r.set(i.script, s);
    })), r;
  }
  async fetchContractVtxosPaginated(t, n, r) {
    const s = [];
    let o = 0, a = !0;
    const c = n ? {} : { spendableOnly: !0 };
    for (; a; ) {
      const { vtxos: u, page: l } = await this.config.indexerProvider.getVtxos({
        scripts: [t.script],
        ...c,
        pageIndex: o,
        pageSize: 100
      });
      for (const f of u) {
        const h = this.config.extendVtxo(f);
        s.push({
          ...h,
          contractScript: t.script
        });
      }
      a = l ? u.length === 100 : !1, o++;
    }
    return s;
  }
  /**
   * Dispose of the ContractManager and release all resources.
   *
   * Stops the watcher, clears callbacks, and marks
   * the manager as uninitialized.
   *
   * Implements the disposable pattern for cleanup.
   */
  dispose() {
    this.stopWatcherFn?.(), this.stopWatcherFn = void 0, this.eventCallbacks.clear(), this.initialized = !1;
  }
  /**
   * Symbol.dispose implementation for using with `using` keyword.
   * @example
   * ```typescript
   * {
   *   using manager = await wallet.getContractManager();
   *   // ... use manager
   * } // automatically disposed
   * ```
   */
  [Symbol.dispose]() {
    this.stopWatcherFn?.(), this.stopWatcherFn = void 0, this.eventCallbacks.clear(), this.initialized = !1;
  }
};
function Hv(e) {
  return typeof e == "object" && e !== null && "toReadonly" in e && typeof e.toReadonly == "function";
}
let Mu = class Hl {
  constructor(t, n, r, i, s, o, a, c, u, l, f) {
    this.identity = t, this.network = n, this.onchainProvider = r, this.indexerProvider = i, this.arkServerPublicKey = s, this.offchainTapscript = o, this.boardingTapscript = a, this.dustAmount = c, this.walletRepository = u, this.contractRepository = l, this.watcherConfig = f;
  }
  /**
   * Protected helper to set up shared wallet configuration.
   * Extracts common logic used by both ReadonlyWallet.create() and Wallet.create().
   */
  static async setupWalletConfig(t, n) {
    const r = t.arkProvider || (() => {
      if (!t.arkServerUrl)
        throw new Error("Either arkProvider or arkServerUrl must be provided");
      return new _w(t.arkServerUrl);
    })(), i = t.arkServerUrl || r.serverUrl;
    if (!i)
      throw new Error("Could not determine arkServerUrl from provider");
    const s = t.indexerUrl || i, o = t.indexerProvider || new Hw(s), a = await r.getInfo(), c = eS(a.network), u = t.esploraUrl || nS[a.network], l = t.onchainProvider || new rS(u);
    if (t.exitTimelock) {
      const { value: A, type: R } = t.exitTimelock;
      if (A < 512n && R !== "blocks" || A >= 512n && R !== "seconds")
        throw new Error("invalid exitTimelock");
    }
    const f = t.exitTimelock ?? {
      value: a.unilateralExitDelay,
      type: a.unilateralExitDelay < 512n ? "blocks" : "seconds"
    };
    if (t.boardingTimelock) {
      const { value: A, type: R } = t.boardingTimelock;
      if (A < 512n && R !== "blocks" || A >= 512n && R !== "seconds")
        throw new Error("invalid boardingTimelock");
    }
    const h = t.boardingTimelock ?? {
      value: a.boardingExitDelay,
      type: a.boardingExitDelay < 512n ? "blocks" : "seconds"
    }, g = D.decode(a.signerPubkey).slice(1), d = new di.Script({
      pubKey: n,
      serverPubKey: g,
      csvTimelock: f
    }), p = new di.Script({
      pubKey: n,
      serverPubKey: g,
      csvTimelock: h
    }), y = d, x = t.storage?.walletRepository ?? new Uv(), S = t.storage?.contractRepository ?? new Pv();
    return {
      arkProvider: r,
      indexerProvider: o,
      onchainProvider: l,
      network: c,
      networkName: a.network,
      serverPubKey: g,
      offchainTapscript: y,
      boardingTapscript: p,
      dustAmount: a.dust,
      walletRepository: x,
      contractRepository: S,
      info: a
    };
  }
  static async create(t) {
    const n = await t.identity.xOnlyPublicKey();
    if (!n)
      throw new Error("Invalid configured public key");
    const r = await Hl.setupWalletConfig(t, n);
    return new Hl(t.identity, r.network, r.onchainProvider, r.indexerProvider, r.serverPubKey, r.offchainTapscript, r.boardingTapscript, r.dustAmount, r.walletRepository, r.contractRepository, t.watcherConfig);
  }
  get arkAddress() {
    return this.offchainTapscript.address(this.network.hrp, this.arkServerPublicKey);
  }
  /**
   * Get the contract script for the wallet's default address.
   * This is the pkScript hex, used to identify the wallet in ContractManager.
   */
  get defaultContractScript() {
    return D.encode(this.offchainTapscript.pkScript);
  }
  async getAddress() {
    return this.arkAddress.encode();
  }
  async getBoardingAddress() {
    return this.boardingTapscript.onchainAddress(this.network);
  }
  async getBalance() {
    const [t, n] = await Promise.all([
      this.getBoardingUtxos(),
      this.getVtxos()
    ]);
    let r = 0, i = 0;
    for (const l of t)
      l.status.confirmed ? r += l.value : i += l.value;
    let s = 0, o = 0, a = 0;
    s = n.filter((l) => l.virtualStatus.state === "settled").reduce((l, f) => l + f.value, 0), o = n.filter((l) => l.virtualStatus.state === "preconfirmed").reduce((l, f) => l + f.value, 0), a = n.filter((l) => fa(l) && l.virtualStatus.state === "swept").reduce((l, f) => l + f.value, 0);
    const c = r + i, u = s + o + a;
    return {
      boarding: {
        confirmed: r,
        unconfirmed: i,
        total: c
      },
      settled: s,
      preconfirmed: o,
      available: s + o,
      recoverable: a,
      total: c + u
    };
  }
  // TODO: use contract manager (and repo) will be offline-first
  async getVtxos(t) {
    const n = await this.getAddress(), i = (await this.getVirtualCoins(t)).map((s) => Ri(this, s));
    return await this.walletRepository.saveVtxos(n, i), i;
  }
  async getVirtualCoins(t = { withRecoverable: !0, withUnrolled: !1 }) {
    const n = [D.encode(this.offchainTapscript.pkScript)], i = (await this.indexerProvider.getVtxos({ scripts: n })).vtxos;
    let s = i.filter(fa);
    if (t.withRecoverable || (s = s.filter((o) => !Ya(o) && !yS(o))), t.withUnrolled) {
      const o = i.filter((a) => !fa(a));
      s.push(...o.filter((a) => a.isUnrolled));
    }
    return s;
  }
  async getTransactionHistory() {
    const t = await this.indexerProvider.getVtxos({
      scripts: [D.encode(this.offchainTapscript.pkScript)]
    }), { boardingTxs: n, commitmentsToIgnore: r } = await this.getBoardingTxs(), i = (s) => this.indexerProvider.getVtxos({ outpoints: [{ txid: s, vout: 0 }] }).then((o) => o.vtxos[0]?.createdAt.getTime() || 0);
    return $v(t.vtxos, n, r, i);
  }
  async getBoardingTxs() {
    const t = [], n = /* @__PURE__ */ new Set(), r = await this.getBoardingAddress(), i = await this.onchainProvider.getTransactions(r);
    for (const a of i)
      for (let c = 0; c < a.vout.length; c++) {
        const u = a.vout[c];
        if (u.scriptpubkey_address === r) {
          const f = (await this.onchainProvider.getTxOutspends(a.txid))[c];
          f?.spent && n.add(f.txid), t.push({
            txid: a.txid,
            vout: c,
            value: Number(u.value),
            status: {
              confirmed: a.status.confirmed,
              block_time: a.status.block_time
            },
            isUnrolled: !0,
            virtualStatus: {
              state: f?.spent ? "spent" : "settled",
              commitmentTxIds: f?.spent ? [f.txid] : void 0
            },
            createdAt: a.status.confirmed ? new Date(a.status.block_time * 1e3) : /* @__PURE__ */ new Date(0)
          });
        }
      }
    const s = [], o = [];
    for (const a of t) {
      const c = {
        key: {
          boardingTxid: a.txid,
          commitmentTxid: "",
          arkTxid: ""
        },
        amount: a.value,
        type: Vn.TxReceived,
        settled: a.virtualStatus.state === "spent",
        createdAt: a.status.block_time ? new Date(a.status.block_time * 1e3).getTime() : 0
      };
      a.status.block_time ? o.push(c) : s.push(c);
    }
    return {
      boardingTxs: [...s, ...o],
      commitmentsToIgnore: n
    };
  }
  async getBoardingUtxos() {
    const t = await this.getBoardingAddress(), r = (await this.onchainProvider.getCoins(t)).map((i) => OS(this, i));
    return await this.walletRepository.saveUtxos(t, r), r;
  }
  async notifyIncomingFunds(t) {
    const n = await this.getAddress(), r = await this.getBoardingAddress();
    let i, s;
    if (this.onchainProvider && r) {
      const a = (c) => c.vout.findIndex((u) => u.scriptpubkey_address === r);
      i = await this.onchainProvider.watchAddresses([r], (c) => {
        const u = c.filter((l) => a(l) !== -1).map((l) => {
          const { txid: f, status: h } = l, g = a(l), d = Number(l.vout[g].value);
          return { txid: f, vout: g, value: d, status: h };
        });
        t({
          type: "utxo",
          coins: u
        });
      });
    }
    if (this.indexerProvider && n) {
      const a = this.offchainTapscript, c = await this.indexerProvider.subscribeForScripts([
        D.encode(a.pkScript)
      ]), u = new AbortController(), l = this.indexerProvider.getSubscription(c, u.signal);
      s = async () => {
        u.abort(), await this.indexerProvider?.unsubscribeForScripts(c);
      }, (async () => {
        try {
          for await (const f of l)
            (f.newVtxos?.length > 0 || f.spentVtxos?.length > 0) && t({
              type: "vtxo",
              newVtxos: f.newVtxos.map((h) => Ri(this, h)),
              spentVtxos: f.spentVtxos.map((h) => Ri(this, h))
            });
        } catch (f) {
          console.error("Subscription error:", f);
        }
      })();
    }
    return () => {
      i?.(), s?.();
    };
  }
  async fetchPendingTxs() {
    const t = [D.encode(this.offchainTapscript.pkScript)];
    let { vtxos: n } = await this.indexerProvider.getVtxos({
      scripts: t
    });
    return n.filter((r) => r.virtualStatus.state !== "swept" && r.virtualStatus.state !== "settled" && r.arkTxId !== void 0).map((r) => r.arkTxId);
  }
  // ========================================================================
  // Contract Management
  // ========================================================================
  /**
   * Get the ContractManager for managing contracts including the wallet's default address.
   *
   * The ContractManager handles:
   * - The wallet's default receiving address (as a "default" contract)
   * - External contracts (Boltz swaps, HTLCs, etc.)
   * - Multi-contract watching with resilient connections
   *
   * @example
   * ```typescript
   * const manager = await wallet.getContractManager();
   *
   * // Create a contract for a Boltz swap
   * const contract = await manager.createContract({
   *   label: "Boltz Swap",
   *   type: "vhtlc",
   *   params: { ... },
   *   script: swapScript,
   *   address: swapAddress,
   * });
   *
   * // Start watching for events (includes wallet's default address)
   * const stop = await manager.onContractEvent((event) => {
   *   console.log(`${event.type} on ${event.contractScript}`);
   * });
   * ```
   */
  async getContractManager() {
    if (this._contractManager)
      return this._contractManager;
    if (this._contractManagerInitializing)
      return this._contractManagerInitializing;
    this._contractManagerInitializing = this.initializeContractManager();
    try {
      const t = await this._contractManagerInitializing;
      return this._contractManager = t, t;
    } catch (t) {
      throw this._contractManagerInitializing = void 0, t;
    } finally {
      this._contractManagerInitializing = void 0;
    }
  }
  async initializeContractManager() {
    const t = await Fv.create({
      indexerProvider: this.indexerProvider,
      contractRepository: this.contractRepository,
      walletRepository: this.walletRepository,
      extendVtxo: (r) => Ri(this, r),
      getDefaultAddress: () => this.getAddress(),
      watcherConfig: this.watcherConfig
    }), n = this.offchainTapscript.options.csvTimelock ?? di.Script.DEFAULT_TIMELOCK;
    return await t.createContract({
      type: "default",
      params: {
        pubKey: D.encode(this.offchainTapscript.options.pubKey),
        serverPubKey: D.encode(this.offchainTapscript.options.serverPubKey),
        csvTimelock: qs(n).toString()
      },
      script: this.defaultContractScript,
      address: await this.getAddress(),
      state: "active"
    }), t;
  }
}, Wl = class dm extends Mu {
  constructor(t, n, r, i, s, o, a, c, u, l, f, h, g, d, p, y, x) {
    super(t, n, i, o, a, c, u, g, d, p, x), this.networkName = r, this.arkProvider = s, this.serverUnrollScript = l, this.forfeitOutputScript = f, this.forfeitPubkey = h, this.identity = t, this.renewalConfig = {
      enabled: y?.enabled ?? !1,
      ...vS,
      ...y
    };
  }
  static async create(t) {
    const n = await t.identity.xOnlyPublicKey();
    if (!n)
      throw new Error("Invalid configured public key");
    const r = await Mu.setupWalletConfig(t, n);
    let i;
    try {
      const c = D.decode(r.info.checkpointTapscript);
      i = Yt.decode(c);
    } catch {
      throw new Error("Invalid checkpointTapscript from server");
    }
    const s = D.decode(r.info.forfeitPubkey).slice(1), o = Cr(r.network).decode(r.info.forfeitAddress), a = Ot.encode(o);
    return new dm(t.identity, r.network, r.networkName, r.onchainProvider, r.arkProvider, r.indexerProvider, r.serverPubKey, r.offchainTapscript, r.boardingTapscript, i, a, s, r.dustAmount, r.walletRepository, r.contractRepository, t.renewalConfig, t.watcherConfig);
  }
  /**
   * Convert this wallet to a readonly wallet.
   *
   * @returns A readonly wallet with the same configuration but readonly identity
   * @example
   * ```typescript
   * const wallet = await Wallet.create({ identity: SingleKey.fromHex('...'), ... });
   * const readonlyWallet = await wallet.toReadonly();
   *
   * // Can query balance and addresses
   * const balance = await readonlyWallet.getBalance();
   * const address = await readonlyWallet.getAddress();
   *
   * // But cannot send transactions (type error)
   * // readonlyWallet.sendBitcoin(...); // TypeScript error
   * ```
   */
  async toReadonly() {
    const t = Hv(this.identity) ? await this.identity.toReadonly() : this.identity;
    return new Mu(t, this.network, this.onchainProvider, this.indexerProvider, this.arkServerPublicKey, this.offchainTapscript, this.boardingTapscript, this.dustAmount, this.walletRepository, this.contractRepository, this.watcherConfig);
  }
  async sendBitcoin(t) {
    if (t.amount <= 0)
      throw new Error("Amount must be positive");
    if (!Wv(t.address))
      throw new Error("Invalid Ark address " + t.address);
    const n = await this.getVirtualCoins({
      withRecoverable: !1
    });
    let r;
    if (t.selectedVtxos) {
      const d = t.selectedVtxos.map((y) => y.value).reduce((y, x) => y + x, 0);
      if (d < t.amount)
        throw new Error("Selected VTXOs do not cover specified amount");
      const p = d - t.amount;
      r = {
        inputs: t.selectedVtxos,
        changeAmount: BigInt(p)
      };
    } else
      r = Kv(n, t.amount);
    const i = this.offchainTapscript.forfeit();
    if (!i)
      throw new Error("Selected leaf not found");
    const s = Sr.decode(t.address), a = [
      {
        script: BigInt(t.amount) < this.dustAmount ? s.subdustPkScript : s.pkScript,
        amount: BigInt(t.amount)
      }
    ];
    if (r.changeAmount > 0n) {
      const d = r.changeAmount < this.dustAmount ? this.arkAddress.subdustPkScript : this.arkAddress.pkScript;
      a.push({
        script: d,
        amount: BigInt(r.changeAmount)
      });
    }
    const c = this.offchainTapscript.encode(), u = Ul(r.inputs.map((d) => ({
      ...d,
      tapLeafScript: i,
      tapTree: c
    })), a, this.serverUnrollScript), l = await this.identity.sign(u.arkTx), { arkTxid: f, signedCheckpointTxs: h } = await this.arkProvider.submitTx(qt.encode(l.toPSBT()), u.checkpoints.map((d) => qt.encode(d.toPSBT()))), g = await Promise.all(h.map(async (d) => {
      const p = ze.fromPSBT(qt.decode(d)), y = await this.identity.sign(p);
      return qt.encode(y.toPSBT());
    }));
    await this.arkProvider.finalizeTx(f, g);
    try {
      const d = [], p = /* @__PURE__ */ new Set();
      let y = Number.MAX_SAFE_INTEGER;
      for (const [A, R] of r.inputs.entries()) {
        const N = Ri(this, R), F = h[A], w = ze.fromPSBT(qt.decode(F));
        if (d.push({
          ...N,
          virtualStatus: { ...N.virtualStatus, state: "spent" },
          spentBy: w.id,
          arkTxId: f,
          isSpent: !0
        }), N.virtualStatus.commitmentTxIds)
          for (const K of N.virtualStatus.commitmentTxIds)
            p.add(K);
        N.virtualStatus.batchExpiry && (y = Math.min(y, N.virtualStatus.batchExpiry));
      }
      const x = Date.now(), S = this.arkAddress.encode();
      if (r.changeAmount > 0n && y !== Number.MAX_SAFE_INTEGER) {
        const A = {
          txid: f,
          vout: a.length - 1,
          createdAt: new Date(x),
          forfeitTapLeafScript: this.offchainTapscript.forfeit(),
          intentTapLeafScript: this.offchainTapscript.forfeit(),
          isUnrolled: !1,
          isSpent: !1,
          tapTree: this.offchainTapscript.encode(),
          value: Number(r.changeAmount),
          virtualStatus: {
            state: "preconfirmed",
            commitmentTxIds: Array.from(p),
            batchExpiry: y
          },
          status: {
            confirmed: !1
          }
        };
        await this.walletRepository.saveVtxos(S, [A]);
      }
      await this.walletRepository.saveVtxos(S, d), await this.walletRepository.saveTransactions(S, [
        {
          key: {
            boardingTxid: "",
            commitmentTxid: "",
            arkTxid: f
          },
          amount: t.amount,
          type: Vn.TxSent,
          settled: !1,
          createdAt: Date.now()
        }
      ]);
    } catch (d) {
      console.warn("error saving offchain tx to repository", d);
    } finally {
      return f;
    }
  }
  async settle(t, n) {
    if (t?.inputs) {
      for (const d of t.inputs)
        if (typeof d == "string")
          try {
            vr.fromString(d);
          } catch {
            throw new Error(`Invalid arknote "${d}"`);
          }
    }
    if (!t) {
      const { fees: d } = await this.arkProvider.getInfo(), p = new kv(d.intentFee);
      let y = 0;
      const S = Yt.decode(D.decode(this.boardingTapscript.exitScript)).params.timelock, A = (await this.getBoardingUtxos()).filter((W) => !ES(W, S)), R = [];
      for (const W of A) {
        const B = p.evalOnchainInput({
          amount: BigInt(W.value)
        });
        B.value >= W.value || (R.push(W), y += W.value - B.satoshis);
      }
      const N = await this.getVtxos({ withRecoverable: !0 }), F = [];
      for (const W of N) {
        const B = p.evalOffchainInput({
          amount: BigInt(W.value),
          type: W.virtualStatus.state === "swept" ? "recoverable" : "vtxo",
          weight: 0,
          birth: W.createdAt,
          expiry: W.virtualStatus.batchExpiry ? new Date(W.virtualStatus.batchExpiry * 1e3) : /* @__PURE__ */ new Date()
        });
        B.value >= W.value || (F.push(W), y += W.value - B.satoshis);
      }
      const w = [...R, ...F];
      if (w.length === 0)
        throw new Error("No inputs found");
      const K = {
        address: await this.getAddress(),
        amount: BigInt(y)
      }, U = p.evalOffchainOutput({
        amount: K.amount,
        script: D.encode(Sr.decode(K.address).pkScript)
      });
      if (K.amount -= BigInt(U.satoshis), K.amount <= this.dustAmount)
        throw new Error("Output amount is below dust limit");
      t = {
        inputs: w,
        outputs: [K]
      };
    }
    const r = [], i = [];
    let s = !1;
    for (const [d, p] of t.outputs.entries()) {
      let y;
      try {
        y = Sr.decode(p.address).pkScript, s = !0;
      } catch {
        const x = Cr(this.network).decode(p.address);
        y = Ot.encode(x), r.push(d);
      }
      i.push({
        amount: p.amount,
        script: y
      });
    }
    let o;
    const a = [];
    s && (o = this.identity.signerSession(), a.push(D.encode(await o.getPublicKey())));
    const [c, u] = await Promise.all([
      this.makeRegisterIntentSignature(t.inputs, i, r, a),
      this.makeDeleteIntentSignature(t.inputs)
    ]), l = await this.safeRegisterIntent(c), f = [
      ...a,
      ...t.inputs.map((d) => `${d.txid}:${d.vout}`)
    ], h = this.createBatchHandler(l, t.inputs, o), g = new AbortController();
    try {
      const d = this.arkProvider.getEventStream(g.signal, f);
      return await Za.join(d, h, {
        abortController: g,
        skipVtxoTreeSigning: !s,
        eventCallback: n ? (p) => Promise.resolve(n(p)) : void 0
      });
    } catch (d) {
      throw await this.arkProvider.deleteIntent(u).catch(() => {
      }), d;
    } finally {
      g.abort();
    }
  }
  async handleSettlementFinalizationEvent(t, n, r, i) {
    const s = [], o = await this.getVirtualCoins();
    let a = ze.fromPSBT(qt.decode(t.commitmentTx)), c = !1, u = 0;
    const l = i?.leaves() || [];
    for (const f of n) {
      const h = o.find((A) => A.txid === f.txid && A.vout === f.vout);
      if (!h) {
        for (let A = 0; A < a.inputsLength; A++) {
          const R = a.getInput(A);
          if (!R.txid || R.index === void 0)
            throw new Error("The server returned incomplete data. No settlement input found in the PSBT");
          if (D.encode(R.txid) === f.txid && R.index === f.vout) {
            a.updateInput(A, {
              tapLeafScript: [f.forfeitTapLeafScript]
            }), a = await this.identity.sign(a, [
              A
            ]), c = !0;
            break;
          }
        }
        continue;
      }
      if (Ya(h) || wS(h, this.dustAmount))
        continue;
      if (l.length === 0)
        throw new Error("connectors not received");
      if (u >= l.length)
        throw new Error("not enough connectors received");
      const g = l[u], d = g.id, p = g.getOutput(0);
      if (!p)
        throw new Error("connector output not found");
      const y = p.amount, x = p.script;
      if (!y || !x)
        throw new Error("invalid connector output");
      u++;
      let S = Dw([
        {
          txid: f.txid,
          index: f.vout,
          witnessUtxo: {
            amount: BigInt(h.value),
            script: Pe.decode(f.tapTree).pkScript
          },
          sighashType: Rr.DEFAULT,
          tapLeafScript: [f.forfeitTapLeafScript]
        },
        {
          txid: d,
          index: 0,
          witnessUtxo: {
            amount: y,
            script: x
          }
        }
      ], r);
      S = await this.identity.sign(S, [0]), s.push(qt.encode(S.toPSBT()));
    }
    (s.length > 0 || c) && await this.arkProvider.submitSignedForfeitTxs(s, c ? qt.encode(a.toPSBT()) : void 0);
  }
  /**
   * @implements Batch.Handler interface.
   * @param intentId - The intent ID.
   * @param inputs - The inputs of the intent.
   * @param session - The musig2 signing session, if not provided, the signing will be skipped.
   */
  createBatchHandler(t, n, r) {
    let i;
    return {
      onBatchStarted: async (s) => {
        const o = new TextEncoder().encode(t), a = ge(o), c = D.encode(a);
        let u = !0;
        for (const f of s.intentIdHashes)
          if (f === c) {
            if (!this.arkProvider)
              throw new Error("Ark provider not configured");
            await this.arkProvider.confirmRegistration(t), u = !1;
          }
        if (u)
          return { skip: u };
        const l = Yt.encode({
          timelock: {
            value: s.batchExpiry,
            type: s.batchExpiry >= 512n ? "seconds" : "blocks"
          },
          pubkeys: [this.forfeitPubkey]
        }).script;
        return i = Mi(l), { skip: !1 };
      },
      onTreeSigningStarted: async (s, o) => {
        if (!r)
          return { skip: !0 };
        if (!i)
          throw new Error("Sweep tap tree root not set");
        const a = s.cosignersPublicKeys.map((d) => d.slice(2)), u = (await r.getPublicKey()).subarray(1);
        if (!a.includes(D.encode(u)))
          return { skip: !0 };
        const l = ze.fromPSBT(qt.decode(s.unsignedCommitmentTx));
        Mw(o, l, i);
        const f = l.getOutput(0);
        if (!f?.amount)
          throw new Error("Shared output not found");
        await r.init(o, i, f.amount);
        const h = D.encode(await r.getPublicKey()), g = await r.getNonces();
        return await this.arkProvider.submitTreeNonces(s.id, h, g), { skip: !1 };
      },
      onTreeNonces: async (s) => {
        if (!r)
          return { fullySigned: !0 };
        const { hasAllNonces: o } = await r.aggregatedNonces(s.txid, s.nonces);
        if (!o)
          return { fullySigned: !1 };
        const a = await r.sign(), c = D.encode(await r.getPublicKey());
        return await this.arkProvider.submitTreeSignatures(s.id, c, a), { fullySigned: !0 };
      },
      onBatchFinalization: async (s, o, a) => {
        if (!this.forfeitOutputScript)
          throw new Error("Forfeit output script not set");
        a && Vw(s.commitmentTx, a), await this.handleSettlementFinalizationEvent(s, n, this.forfeitOutputScript, a);
      }
    };
  }
  async safeRegisterIntent(t) {
    try {
      return await this.arkProvider.registerIntent(t);
    } catch (n) {
      if (n instanceof Uw && n.code === 0 && n.message.includes("duplicated input")) {
        const r = await this.getVtxos({
          withRecoverable: !0
        }), i = await this.makeDeleteIntentSignature(r);
        return await this.arkProvider.deleteIntent(i), this.arkProvider.registerIntent(t);
      }
      throw n;
    }
  }
  async makeRegisterIntentSignature(t, n, r, i) {
    const s = this.prepareIntentProofInputs(t), o = {
      type: "register",
      onchain_output_indexes: r,
      valid_at: 0,
      expire_at: 0,
      cosigners_public_keys: i
    }, a = vn.create(o, s, n), c = await this.identity.sign(a);
    return {
      proof: qt.encode(c.toPSBT()),
      message: o
    };
  }
  async makeDeleteIntentSignature(t) {
    const n = this.prepareIntentProofInputs(t), r = {
      type: "delete",
      expire_at: 0
    }, i = vn.create(r, n, []), s = await this.identity.sign(i);
    return {
      proof: qt.encode(s.toPSBT()),
      message: r
    };
  }
  async makeGetPendingTxIntentSignature(t) {
    const n = this.prepareIntentProofInputs(t), r = {
      type: "get-pending-tx",
      expire_at: 0
    }, i = vn.create(r, n, []), s = await this.identity.sign(i);
    return {
      proof: qt.encode(s.toPSBT()),
      message: r
    };
  }
  /**
   * Finalizes pending transactions by retrieving them from the server and finalizing each one.
   * @param vtxos - Optional list of VTXOs to use instead of retrieving them from the server
   * @returns Array of transaction IDs that were finalized
   */
  async finalizePendingTxs(t) {
    if (!t || t.length === 0) {
      const s = [D.encode(this.offchainTapscript.pkScript)];
      let { vtxos: o } = await this.indexerProvider.getVtxos({
        scripts: s
      });
      if (o = o.filter((a) => a.virtualStatus.state !== "swept" && a.virtualStatus.state !== "settled"), o.length === 0)
        return { finalized: [], pending: [] };
      t = o.map((a) => Ri(this, a));
    }
    const r = [], i = [];
    for (let s = 0; s < t.length; s += 20) {
      const o = t.slice(s, s + 20), a = await this.makeGetPendingTxIntentSignature(o), c = await this.arkProvider.getPendingTxs(a);
      for (const u of c) {
        i.push(u.arkTxid);
        try {
          const l = await Promise.all(u.signedCheckpointTxs.map(async (f) => {
            const h = ze.fromPSBT(qt.decode(f)), g = await this.identity.sign(h);
            return qt.encode(g.toPSBT());
          }));
          await this.arkProvider.finalizeTx(u.arkTxid, l), r.push(u.arkTxid);
        } catch (l) {
          console.error(`Failed to finalize transaction ${u.arkTxid}:`, l);
        }
      }
    }
    return { finalized: r, pending: i };
  }
  prepareIntentProofInputs(t) {
    const n = [];
    for (const r of t) {
      const i = Pe.decode(r.tapTree), s = dd(r.intentTapLeafScript), o = [ed.encode(r.tapTree)];
      r.extraWitness && o.push(Rw.encode(r.extraWitness)), n.push({
        txid: D.decode(r.txid),
        index: r.vout,
        witnessUtxo: {
          amount: BigInt(r.value),
          script: i.pkScript
        },
        sequence: s,
        tapLeafScript: [r.intentTapLeafScript],
        unknown: o
      });
    }
    return n;
  }
};
Wl.MIN_FEE_RATE = 1;
function dd(e) {
  let t;
  try {
    const n = e[1], r = n.subarray(0, n.length - 1);
    try {
      const i = Yt.decode(r).params;
      t = lo.encode(i.timelock.type === "blocks" ? { blocks: Number(i.timelock.value) } : { seconds: Number(i.timelock.value) });
    } catch {
      const i = ts.decode(r).params;
      t = Number(i.absoluteTimelock);
    }
  } catch {
  }
  return t;
}
function Wv(e) {
  try {
    return Sr.decode(e), !0;
  } catch {
    return !1;
  }
}
function Kv(e, t) {
  const n = [...e].sort((o, a) => {
    const c = o.virtualStatus.batchExpiry || Number.MAX_SAFE_INTEGER, u = a.virtualStatus.batchExpiry || Number.MAX_SAFE_INTEGER;
    return c !== u ? c - u : a.value - o.value;
  }), r = [];
  let i = 0;
  for (const o of n)
    if (r.push(o), i += o.value, i >= t)
      break;
  if (i === t)
    return { inputs: r, changeAmount: 0n };
  if (i < t)
    throw new Error("Insufficient funds");
  const s = BigInt(i - t);
  return {
    inputs: r,
    changeAmount: s
  };
}
const Fu = (e) => e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
let sn = class Zt {
  constructor(t, n, r, i, s, o) {
    this.hasWitness = t, this.inputCount = n, this.outputCount = r, this.inputSize = i, this.inputWitnessSize = s, this.outputSize = o;
  }
  static create() {
    return new Zt(!1, 0, 0, 0, 0, 0);
  }
  addP2AInput() {
    return this.inputCount++, this.inputSize += Zt.INPUT_SIZE, this;
  }
  addKeySpendInput(t = !0) {
    return this.inputCount++, this.inputWitnessSize += 65 + (t ? 0 : 1), this.inputSize += Zt.INPUT_SIZE, this.hasWitness = !0, this;
  }
  addP2PKHInput() {
    return this.inputCount++, this.inputWitnessSize++, this.inputSize += Zt.INPUT_SIZE + Zt.P2PKH_SCRIPT_SIG_SIZE, this;
  }
  addTapscriptInput(t, n, r) {
    const i = 1 + Zt.BASE_CONTROL_BLOCK_SIZE + 1 + n + 1 + r;
    return this.inputCount++, this.inputWitnessSize += t + 1 + i, this.inputSize += Zt.INPUT_SIZE, this.hasWitness = !0, this;
  }
  addP2WPKHOutput() {
    return this.outputCount++, this.outputSize += Zt.OUTPUT_SIZE + Zt.P2WPKH_OUTPUT_SIZE, this;
  }
  addP2TROutput() {
    return this.outputCount++, this.outputSize += Zt.OUTPUT_SIZE + Zt.P2TR_OUTPUT_SIZE, this;
  }
  /**
   * Adds an output given a raw script.
   * Cost = 8 bytes (amount) + varint(scriptLen) + scriptLen
   */
  addOutputScript(t) {
    return this.outputCount++, this.outputSize += 8 + Fu(t.length) + t.length, this;
  }
  /**
   * Adds an output by decoding the address to get the exact script size.
   */
  addOutputAddress(t, n) {
    const r = Cr(n).decode(t), i = Ot.encode(r);
    return this.addOutputScript(i);
  }
  vsize() {
    const t = Fu(this.inputCount), n = Fu(this.outputCount);
    let i = (Zt.BASE_TX_SIZE + t + this.inputSize + n + this.outputSize) * Zt.WITNESS_SCALE_FACTOR;
    return this.hasWitness && (i += Zt.WITNESS_HEADER_SIZE + this.inputWitnessSize), jv(i);
  }
};
sn.P2PKH_SCRIPT_SIG_SIZE = 108;
sn.INPUT_SIZE = 41;
sn.BASE_CONTROL_BLOCK_SIZE = 33;
sn.OUTPUT_SIZE = 9;
sn.P2WPKH_OUTPUT_SIZE = 22;
sn.BASE_TX_SIZE = 10;
sn.WITNESS_HEADER_SIZE = 2;
sn.WITNESS_SCALE_FACTOR = 4;
sn.P2TR_OUTPUT_SIZE = 34;
const jv = (e) => {
  const t = BigInt(Math.ceil(e / sn.WITNESS_SCALE_FACTOR));
  return {
    value: t,
    fee: (n) => n * t
  };
};
var Ap;
(function(e) {
  let t;
  (function(i) {
    i[i.UNROLL = 0] = "UNROLL", i[i.WAIT = 1] = "WAIT", i[i.DONE = 2] = "DONE";
  })(t = e.StepType || (e.StepType = {}));
  class n {
    constructor(s, o, a, c) {
      this.toUnroll = s, this.bumper = o, this.explorer = a, this.indexer = c;
    }
    static async create(s, o, a, c) {
      const { chain: u } = await c.getVtxoChain(s);
      return new n({ ...s, chain: u }, o, a, c);
    }
    /**
     * Get the next step to be executed
     * @returns The next step to be executed + the function to execute it
     */
    async next() {
      let s;
      const o = this.toUnroll.chain;
      for (let u = o.length - 1; u >= 0; u--) {
        const l = o[u];
        if (!(l.type === Fi.COMMITMENT || l.type === Fi.UNSPECIFIED))
          try {
            if (!(await this.explorer.getTxStatus(l.txid)).confirmed)
              return {
                type: t.WAIT,
                txid: l.txid,
                do: Gv(this.explorer, l.txid)
              };
          } catch {
            s = l;
            break;
          }
      }
      if (!s)
        return {
          type: t.DONE,
          vtxoTxid: this.toUnroll.txid,
          do: () => Promise.resolve()
        };
      const a = await this.indexer.getVirtualTxs([
        s.txid
      ]);
      if (a.txs.length === 0)
        throw new Error(`Tx ${s.txid} not found`);
      const c = Re.fromPSBT(qt.decode(a.txs[0]));
      if (s.type === Fi.TREE) {
        const u = c.getInput(0);
        if (!u)
          throw new Error("Input not found");
        const l = u.tapKeySig;
        if (!l)
          throw new Error("Tap key sig not found");
        c.updateInput(0, {
          finalScriptWitness: [l]
        });
      } else
        c.finalize();
      return {
        type: t.UNROLL,
        tx: c,
        do: qv(this.bumper, this.explorer, c)
      };
    }
    /**
     * Iterate over the steps to be executed and execute them
     * @returns An async iterator over the executed steps
     */
    async *[Symbol.asyncIterator]() {
      let s;
      do {
        s !== void 0 && await zv(1e3);
        const o = await this.next();
        await o.do(), yield o, s = o.type;
      } while (s !== t.DONE);
    }
  }
  e.Session = n;
  async function r(i, s, o) {
    const a = await i.onchainProvider.getChainTip();
    let c = await i.getVtxos({ withUnrolled: !0 });
    if (c = c.filter((x) => s.includes(x.txid)), c.length === 0)
      throw new Error("No vtxos to complete unroll");
    const u = [];
    let l = 0n;
    const f = sn.create();
    for (const x of c) {
      if (!x.isUnrolled)
        throw new Error(`Vtxo ${x.txid}:${x.vout} is not fully unrolled, use unroll first`);
      const S = await i.onchainProvider.getTxStatus(x.txid);
      if (!S.confirmed)
        throw new Error(`tx ${x.txid} is not confirmed`);
      const A = Yv({ height: S.blockHeight, time: S.blockTime }, a, x);
      if (!A)
        throw new Error(`no available exit path found for vtxo ${x.txid}:${x.vout}`);
      const R = Pe.decode(x.tapTree).findLeaf(D.encode(A.script));
      if (!R)
        throw new Error(`spending leaf not found for vtxo ${x.txid}:${x.vout}`);
      l += BigInt(x.value), u.push({
        txid: x.txid,
        index: x.vout,
        tapLeafScript: [R],
        sequence: 4294967294,
        witnessUtxo: {
          amount: BigInt(x.value),
          script: Pe.decode(x.tapTree).pkScript
        },
        sighashType: Rr.DEFAULT
      }), f.addTapscriptInput(64, R[1].length, xn.encode(R[0]).length);
    }
    const h = new Re({ version: 2 });
    for (const x of u)
      h.addInput(x);
    f.addOutputAddress(o, i.network);
    let g = await i.onchainProvider.getFeeRate();
    (!g || g < Wl.MIN_FEE_RATE) && (g = Wl.MIN_FEE_RATE);
    const d = f.vsize().fee(BigInt(g));
    if (d > l)
      throw new Error("fee amount is greater than the total amount");
    const p = l - d;
    if (p < BigInt(IS))
      throw new Error("send amount is less than dust amount");
    h.addOutputAddress(o, p);
    const y = await i.identity.sign(h);
    return y.finalize(), await i.onchainProvider.broadcastTransaction(y.hex), y.id;
  }
  e.completeUnroll = r;
})(Ap || (Ap = {}));
function zv(e) {
  return new Promise((t) => setTimeout(t, e));
}
function qv(e, t, n) {
  return async () => {
    const [r, i] = await e.bumpP2A(n);
    await t.broadcastTransaction(r, i);
  };
}
function Gv(e, t) {
  return () => new Promise((n, r) => {
    const i = setInterval(async () => {
      try {
        (await e.getTxStatus(t)).confirmed && (clearInterval(i), n());
      } catch (s) {
        clearInterval(i), r(s);
      }
    }, 5e3);
  });
}
function Yv(e, t, n) {
  const r = Pe.decode(n.tapTree).exitPaths();
  for (const i of r)
    if (i.params.timelock.type === "blocks") {
      if (t.height >= e.height + Number(i.params.timelock.value))
        return i;
    } else if (t.time >= e.time + Number(i.params.timelock.value))
      return i;
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function hd(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function Nr(e, t = "") {
  if (!Number.isSafeInteger(e) || e < 0) {
    const n = t && `"${t}" `;
    throw new Error(`${n}expected integer >= 0, got ${e}`);
  }
}
function st(e, t, n = "") {
  const r = hd(e), i = e?.length, s = t !== void 0;
  if (!r || s && i !== t) {
    const o = n && `"${n}" `, a = s ? ` of length ${t}` : "", c = r ? `length=${i}` : `type=${typeof e}`;
    throw new Error(o + "expected Uint8Array" + a + ", got " + c);
  }
  return e;
}
function hm(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  Nr(e.outputLen), Nr(e.blockLen);
}
function ec(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function Zv(e, t) {
  st(e, void 0, "digestInto() output");
  const n = t.outputLen;
  if (e.length < n)
    throw new Error('"digestInto() output" expected to be of length >=' + n);
}
function rs(...e) {
  for (let t = 0; t < e.length; t++)
    e[t].fill(0);
}
function Hu(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function un(e, t) {
  return e << 32 - t | e >>> t;
}
function Fo(e, t) {
  return e << t | e >>> 32 - t >>> 0;
}
const pm = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", Xv = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Zc(e) {
  if (st(e), pm)
    return e.toHex();
  let t = "";
  for (let n = 0; n < e.length; n++)
    t += Xv[e[n]];
  return t;
}
const Pn = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function $p(e) {
  if (e >= Pn._0 && e <= Pn._9)
    return e - Pn._0;
  if (e >= Pn.A && e <= Pn.F)
    return e - (Pn.A - 10);
  if (e >= Pn.a && e <= Pn.f)
    return e - (Pn.a - 10);
}
function nc(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (pm)
    return Uint8Array.fromHex(e);
  const t = e.length, n = t / 2;
  if (t % 2)
    throw new Error("hex string expected, got unpadded hex of length " + t);
  const r = new Uint8Array(n);
  for (let i = 0, s = 0; i < n; i++, s += 2) {
    const o = $p(e.charCodeAt(s)), a = $p(e.charCodeAt(s + 1));
    if (o === void 0 || a === void 0) {
      const c = e[s] + e[s + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + s);
    }
    r[i] = o * 16 + a;
  }
  return r;
}
function Ge(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    st(i), t += i.length;
  }
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const s = e[r];
    n.set(s, i), i += s.length;
  }
  return n;
}
function gm(e, t = {}) {
  const n = (i, s) => e(s).update(i).digest(), r = e(void 0);
  return n.outputLen = r.outputLen, n.blockLen = r.blockLen, n.create = (i) => e(i), Object.assign(n, t), Object.freeze(n);
}
function Es(e = 32) {
  const t = typeof globalThis == "object" ? globalThis.crypto : null;
  if (typeof t?.getRandomValues != "function")
    throw new Error("crypto.getRandomValues must be defined");
  return t.getRandomValues(new Uint8Array(e));
}
const Qv = (e) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, e])
});
function Jv(e, t, n) {
  return e & t ^ ~e & n;
}
function t1(e, t, n) {
  return e & t ^ e & n ^ t & n;
}
let ym = class {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = !1;
  length = 0;
  pos = 0;
  destroyed = !1;
  constructor(t, n, r, i) {
    this.blockLen = t, this.outputLen = n, this.padOffset = r, this.isLE = i, this.buffer = new Uint8Array(t), this.view = Hu(this.buffer);
  }
  update(t) {
    ec(this), st(t);
    const { view: n, buffer: r, blockLen: i } = this, s = t.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = Hu(t);
        for (; i <= s - o; o += i)
          this.process(c, o);
        continue;
      }
      r.set(t.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(n, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    ec(this), Zv(t, this), this.finished = !0;
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    n[o++] = 128, rs(this.buffer.subarray(o)), this.padOffset > i - o && (this.process(r, 0), o = 0);
    for (let f = o; f < i; f++)
      n[f] = 0;
    r.setBigUint64(i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = Hu(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      a.setUint32(4 * f, l[f], s);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t ||= new this.constructor(), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a } = this;
    return t.destroyed = o, t.finished = s, t.length = i, t.pos = a, i % n && t.buffer.set(r), t;
  }
  clone() {
    return this._cloneInto();
  }
};
const or = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), e1 = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), ar = /* @__PURE__ */ new Uint32Array(64);
let n1 = class extends ym {
  constructor(t) {
    super(64, t, 8, !1);
  }
  get() {
    const { A: t, B: n, C: r, D: i, E: s, F: o, G: a, H: c } = this;
    return [t, n, r, i, s, o, a, c];
  }
  // prettier-ignore
  set(t, n, r, i, s, o, a, c) {
    this.A = t | 0, this.B = n | 0, this.C = r | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, n) {
    for (let f = 0; f < 16; f++, n += 4)
      ar[f] = t.getUint32(n, !1);
    for (let f = 16; f < 64; f++) {
      const h = ar[f - 15], g = ar[f - 2], d = un(h, 7) ^ un(h, 18) ^ h >>> 3, p = un(g, 17) ^ un(g, 19) ^ g >>> 10;
      ar[f] = p + ar[f - 7] + d + ar[f - 16] | 0;
    }
    let { A: r, B: i, C: s, D: o, E: a, F: c, G: u, H: l } = this;
    for (let f = 0; f < 64; f++) {
      const h = un(a, 6) ^ un(a, 11) ^ un(a, 25), g = l + h + Jv(a, c, u) + e1[f] + ar[f] | 0, p = (un(r, 2) ^ un(r, 13) ^ un(r, 22)) + t1(r, i, s) | 0;
      l = u, u = c, c = a, a = o + g | 0, o = s, s = i, i = r, r = g + p | 0;
    }
    r = r + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, i, s, o, a, c, u, l);
  }
  roundClean() {
    rs(ar);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), rs(this.buffer);
  }
}, r1 = class extends n1 {
  // We cannot use array here since array allows indexing by variable
  // which means optimizer/compiler cannot use registers.
  A = or[0] | 0;
  B = or[1] | 0;
  C = or[2] | 0;
  D = or[3] | 0;
  E = or[4] | 0;
  F = or[5] | 0;
  G = or[6] | 0;
  H = or[7] | 0;
  constructor() {
    super(32);
  }
};
const Bt = /* @__PURE__ */ gm(
  () => new r1(),
  /* @__PURE__ */ Qv(1)
);
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function is(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function wm(e) {
  if (!is(e))
    throw new Error("Uint8Array expected");
}
function mm(e, t) {
  return Array.isArray(t) ? t.length === 0 ? !0 : e ? t.every((n) => typeof n == "string") : t.every((n) => Number.isSafeInteger(n)) : !1;
}
function pd(e) {
  if (typeof e != "function")
    throw new Error("function expected");
  return !0;
}
function Lr(e, t) {
  if (typeof t != "string")
    throw new Error(`${e}: string expected`);
  return !0;
}
function xs(e) {
  if (!Number.isSafeInteger(e))
    throw new Error(`invalid integer: ${e}`);
}
function rc(e) {
  if (!Array.isArray(e))
    throw new Error("array expected");
}
function ic(e, t) {
  if (!mm(!0, t))
    throw new Error(`${e}: array of strings expected`);
}
function gd(e, t) {
  if (!mm(!1, t))
    throw new Error(`${e}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function vo(...e) {
  const t = (s) => s, n = (s, o) => (a) => s(o(a)), r = e.map((s) => s.encode).reduceRight(n, t), i = e.map((s) => s.decode).reduce(n, t);
  return { encode: r, decode: i };
}
// @__NO_SIDE_EFFECTS__
function Xc(e) {
  const t = typeof e == "string" ? e.split("") : e, n = t.length;
  ic("alphabet", t);
  const r = new Map(t.map((i, s) => [i, s]));
  return {
    encode: (i) => (rc(i), i.map((s) => {
      if (!Number.isSafeInteger(s) || s < 0 || s >= n)
        throw new Error(`alphabet.encode: digit index outside alphabet "${s}". Allowed: ${e}`);
      return t[s];
    })),
    decode: (i) => (rc(i), i.map((s) => {
      Lr("alphabet.decode", s);
      const o = r.get(s);
      if (o === void 0)
        throw new Error(`Unknown letter: "${s}". Allowed: ${e}`);
      return o;
    }))
  };
}
// @__NO_SIDE_EFFECTS__
function Qc(e = "") {
  return Lr("join", e), {
    encode: (t) => (ic("join.decode", t), t.join(e)),
    decode: (t) => (Lr("join.decode", t), t.split(e))
  };
}
// @__NO_SIDE_EFFECTS__
function i1(e, t = "=") {
  return xs(e), Lr("padding", t), {
    encode(n) {
      for (ic("padding.encode", n); n.length * e % 8; )
        n.push(t);
      return n;
    },
    decode(n) {
      ic("padding.decode", n);
      let r = n.length;
      if (r * e % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; r > 0 && n[r - 1] === t; r--)
        if ((r - 1) * e % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      return n.slice(0, r);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function s1(e) {
  return pd(e), { encode: (t) => t, decode: (t) => e(t) };
}
function Ip(e, t, n) {
  if (t < 2)
    throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);
  if (n < 2)
    throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);
  if (rc(e), !e.length)
    return [];
  let r = 0;
  const i = [], s = Array.from(e, (a) => {
    if (xs(a), a < 0 || a >= t)
      throw new Error(`invalid integer: ${a}`);
    return a;
  }), o = s.length;
  for (; ; ) {
    let a = 0, c = !0;
    for (let u = r; u < o; u++) {
      const l = s[u], f = t * a, h = f + l;
      if (!Number.isSafeInteger(h) || f / t !== a || h - l !== f)
        throw new Error("convertRadix: carry overflow");
      const g = h / n;
      a = h % n;
      const d = Math.floor(g);
      if (s[u] = d, !Number.isSafeInteger(d) || d * n + a !== h)
        throw new Error("convertRadix: carry overflow");
      if (c)
        d ? c = !1 : r = u;
      else continue;
    }
    if (i.push(a), c)
      break;
  }
  for (let a = 0; a < e.length - 1 && e[a] === 0; a++)
    i.push(0);
  return i.reverse();
}
const bm = (e, t) => t === 0 ? e : bm(t, e % t), sc = /* @__NO_SIDE_EFFECTS__ */ (e, t) => e + (t - bm(e, t)), ba = /* @__PURE__ */ (() => {
  let e = [];
  for (let t = 0; t < 40; t++)
    e.push(2 ** t);
  return e;
})();
function Kl(e, t, n, r) {
  if (rc(e), t <= 0 || t > 32)
    throw new Error(`convertRadix2: wrong from=${t}`);
  if (n <= 0 || n > 32)
    throw new Error(`convertRadix2: wrong to=${n}`);
  if (/* @__PURE__ */ sc(t, n) > 32)
    throw new Error(`convertRadix2: carry overflow from=${t} to=${n} carryBits=${/* @__PURE__ */ sc(t, n)}`);
  let i = 0, s = 0;
  const o = ba[t], a = ba[n] - 1, c = [];
  for (const u of e) {
    if (xs(u), u >= o)
      throw new Error(`convertRadix2: invalid data word=${u} from=${t}`);
    if (i = i << t | u, s + t > 32)
      throw new Error(`convertRadix2: carry overflow pos=${s} from=${t}`);
    for (s += t; s >= n; s -= n)
      c.push((i >> s - n & a) >>> 0);
    const l = ba[s];
    if (l === void 0)
      throw new Error("invalid carry");
    i &= l - 1;
  }
  if (i = i << n - s & a, !r && s >= t)
    throw new Error("Excess padding");
  if (!r && i > 0)
    throw new Error(`Non-zero padding: ${i}`);
  return r && s > 0 && c.push(i >>> 0), c;
}
// @__NO_SIDE_EFFECTS__
function o1(e) {
  xs(e);
  const t = 2 ** 8;
  return {
    encode: (n) => {
      if (!is(n))
        throw new Error("radix.encode input should be Uint8Array");
      return Ip(Array.from(n), t, e);
    },
    decode: (n) => (gd("radix.decode", n), Uint8Array.from(Ip(n, e, t)))
  };
}
// @__NO_SIDE_EFFECTS__
function yd(e, t = !1) {
  if (xs(e), e <= 0 || e > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ sc(8, e) > 32 || /* @__PURE__ */ sc(e, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (n) => {
      if (!is(n))
        throw new Error("radix2.encode input should be Uint8Array");
      return Kl(Array.from(n), 8, e, !t);
    },
    decode: (n) => (gd("radix2.decode", n), Uint8Array.from(Kl(n, e, 8, t)))
  };
}
function Op(e) {
  return pd(e), function(...t) {
    try {
      return e.apply(null, t);
    } catch {
    }
  };
}
function a1(e, t) {
  return xs(e), pd(t), {
    encode(n) {
      if (!is(n))
        throw new Error("checksum.encode: input should be Uint8Array");
      const r = t(n).slice(0, e), i = new Uint8Array(n.length + e);
      return i.set(n), i.set(r, n.length), i;
    },
    decode(n) {
      if (!is(n))
        throw new Error("checksum.decode: input should be Uint8Array");
      const r = n.slice(0, -e), i = n.slice(-e), s = t(r).slice(0, e);
      for (let o = 0; o < e; o++)
        if (s[o] !== i[o])
          throw new Error("Invalid checksum");
      return r;
    }
  };
}
const c1 = typeof Uint8Array.from([]).toBase64 == "function" && typeof Uint8Array.fromBase64 == "function", u1 = (e, t) => {
  Lr("base64", e);
  const n = /^[A-Za-z0-9=+/]+$/, r = "base64";
  if (e.length > 0 && !n.test(e))
    throw new Error("invalid base64");
  return Uint8Array.fromBase64(e, { alphabet: r, lastChunkHandling: "strict" });
}, ut = c1 ? {
  encode(e) {
    return wm(e), e.toBase64();
  },
  decode(e) {
    return u1(e);
  }
} : /* @__PURE__ */ vo(/* @__PURE__ */ yd(6), /* @__PURE__ */ Xc("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ i1(6), /* @__PURE__ */ Qc("")), l1 = /* @__NO_SIDE_EFFECTS__ */ (e) => /* @__PURE__ */ vo(/* @__PURE__ */ o1(58), /* @__PURE__ */ Xc(e), /* @__PURE__ */ Qc("")), jl = /* @__PURE__ */ l1("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), f1 = (e) => /* @__PURE__ */ vo(a1(4, (t) => e(e(t))), jl), zl = /* @__PURE__ */ vo(/* @__PURE__ */ Xc("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ Qc("")), Bp = [996825010, 642813549, 513874426, 1027748829, 705979059];
function Cs(e) {
  const t = e >> 25;
  let n = (e & 33554431) << 5;
  for (let r = 0; r < Bp.length; r++)
    (t >> r & 1) === 1 && (n ^= Bp[r]);
  return n;
}
function Cp(e, t, n = 1) {
  const r = e.length;
  let i = 1;
  for (let s = 0; s < r; s++) {
    const o = e.charCodeAt(s);
    if (o < 33 || o > 126)
      throw new Error(`Invalid prefix (${e})`);
    i = Cs(i) ^ o >> 5;
  }
  i = Cs(i);
  for (let s = 0; s < r; s++)
    i = Cs(i) ^ e.charCodeAt(s) & 31;
  for (let s of t)
    i = Cs(i) ^ s;
  for (let s = 0; s < 6; s++)
    i = Cs(i);
  return i ^= n, zl.encode(Kl([i % ba[30]], 30, 5, !1));
}
// @__NO_SIDE_EFFECTS__
function Em(e) {
  const t = e === "bech32" ? 1 : 734539939, n = /* @__PURE__ */ yd(5), r = n.decode, i = n.encode, s = Op(r);
  function o(f, h, g = 90) {
    Lr("bech32.encode prefix", f), is(h) && (h = Array.from(h)), gd("bech32.encode", h);
    const d = f.length;
    if (d === 0)
      throw new TypeError(`Invalid prefix length ${d}`);
    const p = d + 7 + h.length;
    if (g !== !1 && p > g)
      throw new TypeError(`Length ${p} exceeds limit ${g}`);
    const y = f.toLowerCase(), x = Cp(y, h, t);
    return `${y}1${zl.encode(h)}${x}`;
  }
  function a(f, h = 90) {
    Lr("bech32.decode input", f);
    const g = f.length;
    if (g < 8 || h !== !1 && g > h)
      throw new TypeError(`invalid string length: ${g} (${f}). Expected (8..${h})`);
    const d = f.toLowerCase();
    if (f !== d && f !== f.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    const p = d.lastIndexOf("1");
    if (p === 0 || p === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const y = d.slice(0, p), x = d.slice(p + 1);
    if (x.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const S = zl.decode(x).slice(0, -6), A = Cp(y, S, t);
    if (!x.endsWith(A))
      throw new Error(`Invalid checksum in ${f}: expected "${A}"`);
    return { prefix: y, words: S };
  }
  const c = Op(a);
  function u(f) {
    const { prefix: h, words: g } = a(f, !1);
    return { prefix: h, words: g, bytes: r(g) };
  }
  function l(f, h) {
    return o(f, i(h));
  }
  return {
    encode: o,
    decode: a,
    encodeFromBytes: l,
    decodeToBytes: u,
    decodeUnsafe: c,
    fromWords: r,
    fromWordsUnsafe: s,
    toWords: i
  };
}
const ql = /* @__PURE__ */ Em("bech32"), Ni = /* @__PURE__ */ Em("bech32m"), d1 = {
  encode: (e) => new TextDecoder().decode(e),
  decode: (e) => new TextEncoder().encode(e)
}, h1 = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", p1 = {
  encode(e) {
    return wm(e), e.toHex();
  },
  decode(e) {
    return Lr("hex", e), Uint8Array.fromHex(e);
  }
}, C = h1 ? p1 : /* @__PURE__ */ vo(/* @__PURE__ */ yd(4), /* @__PURE__ */ Xc("0123456789abcdef"), /* @__PURE__ */ Qc(""), /* @__PURE__ */ s1((e) => {
  if (typeof e != "string" || e.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);
  return e.toLowerCase();
}));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const wd = /* @__PURE__ */ BigInt(0), Gl = /* @__PURE__ */ BigInt(1);
function oc(e, t = "") {
  if (typeof e != "boolean") {
    const n = t && `"${t}" `;
    throw new Error(n + "expected boolean, got type=" + typeof e);
  }
  return e;
}
function xm(e) {
  if (typeof e == "bigint") {
    if (!Ea(e))
      throw new Error("positive bigint expected, got " + e);
  } else
    Nr(e);
  return e;
}
function Ho(e) {
  const t = xm(e).toString(16);
  return t.length & 1 ? "0" + t : t;
}
function Tm(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return e === "" ? wd : BigInt("0x" + e);
}
function Zn(e) {
  return Tm(Zc(e));
}
function Sm(e) {
  return Tm(Zc(g1(st(e)).reverse()));
}
function ko(e, t) {
  Nr(t), e = xm(e);
  const n = nc(e.toString(16).padStart(t * 2, "0"));
  if (n.length !== t)
    throw new Error("number too large");
  return n;
}
function vm(e, t) {
  return ko(e, t).reverse();
}
function ho(e, t) {
  if (e.length !== t.length)
    return !1;
  let n = 0;
  for (let r = 0; r < e.length; r++)
    n |= e[r] ^ t[r];
  return n === 0;
}
function g1(e) {
  return Uint8Array.from(e);
}
function y1(e) {
  return Uint8Array.from(e, (t, n) => {
    const r = t.charCodeAt(0);
    if (t.length !== 1 || r > 127)
      throw new Error(`string contains non-ASCII character "${e[n]}" with code ${r} at position ${n}`);
    return r;
  });
}
const Ea = (e) => typeof e == "bigint" && wd <= e;
function w1(e, t, n) {
  return Ea(e) && Ea(t) && Ea(n) && t <= e && e < n;
}
function km(e, t, n, r) {
  if (!w1(t, n, r))
    throw new Error("expected valid " + e + ": " + n + " <= n < " + r + ", got " + t);
}
function m1(e) {
  let t;
  for (t = 0; e > wd; e >>= Gl, t += 1)
    ;
  return t;
}
const md = (e) => (Gl << BigInt(e)) - Gl;
function b1(e, t, n) {
  if (Nr(e, "hashLen"), Nr(t, "qByteLen"), typeof n != "function")
    throw new Error("hmacFn must be a function");
  const r = (y) => new Uint8Array(y), i = Uint8Array.of(), s = Uint8Array.of(0), o = Uint8Array.of(1), a = 1e3;
  let c = r(e), u = r(e), l = 0;
  const f = () => {
    c.fill(1), u.fill(0), l = 0;
  }, h = (...y) => n(u, Ge(c, ...y)), g = (y = i) => {
    u = h(s, y), c = h(), y.length !== 0 && (u = h(o, y), c = h());
  }, d = () => {
    if (l++ >= a)
      throw new Error("drbg: tried max amount of iterations");
    let y = 0;
    const x = [];
    for (; y < t; ) {
      c = h();
      const S = c.slice();
      x.push(S), y += c.length;
    }
    return Ge(...x);
  };
  return (y, x) => {
    f(), g(y);
    let S;
    for (; !(S = x(d())); )
      g();
    return f(), S;
  };
}
function bd(e, t = {}, n = {}) {
  if (!e || typeof e != "object")
    throw new Error("expected valid options object");
  function r(s, o, a) {
    const c = e[s];
    if (a && c === void 0)
      return;
    const u = typeof c;
    if (u !== o || c === null)
      throw new Error(`param "${s}" is invalid: expected ${o}, got ${u}`);
  }
  const i = (s, o) => Object.entries(s).forEach(([a, c]) => r(a, c, o));
  i(t, !1), i(n, !0);
}
function Rp(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return (n, ...r) => {
    const i = t.get(n);
    if (i !== void 0)
      return i;
    const s = e(n, ...r);
    return t.set(n, s), s;
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const oe = /* @__PURE__ */ BigInt(0), Jt = /* @__PURE__ */ BigInt(1), si = /* @__PURE__ */ BigInt(2), Am = /* @__PURE__ */ BigInt(3), $m = /* @__PURE__ */ BigInt(4), Im = /* @__PURE__ */ BigInt(5), E1 = /* @__PURE__ */ BigInt(7), Om = /* @__PURE__ */ BigInt(8), x1 = /* @__PURE__ */ BigInt(9), Bm = /* @__PURE__ */ BigInt(16);
function He(e, t) {
  const n = e % t;
  return n >= oe ? n : t + n;
}
function ve(e, t, n) {
  let r = e;
  for (; t-- > oe; )
    r *= r, r %= n;
  return r;
}
function Pp(e, t) {
  if (e === oe)
    throw new Error("invert: expected non-zero number");
  if (t <= oe)
    throw new Error("invert: expected positive modulus, got " + t);
  let n = He(e, t), r = t, i = oe, s = Jt;
  for (; n !== oe; ) {
    const a = r / n, c = r % n, u = i - s * a;
    r = n, n = c, i = s, s = u;
  }
  if (r !== Jt)
    throw new Error("invert: does not exist");
  return He(i, t);
}
function Ed(e, t, n) {
  if (!e.eql(e.sqr(t), n))
    throw new Error("Cannot find square root");
}
function Cm(e, t) {
  const n = (e.ORDER + Jt) / $m, r = e.pow(t, n);
  return Ed(e, r, t), r;
}
function T1(e, t) {
  const n = (e.ORDER - Im) / Om, r = e.mul(t, si), i = e.pow(r, n), s = e.mul(t, i), o = e.mul(e.mul(s, si), i), a = e.mul(s, e.sub(o, e.ONE));
  return Ed(e, a, t), a;
}
function S1(e) {
  const t = Jc(e), n = Rm(e), r = n(t, t.neg(t.ONE)), i = n(t, r), s = n(t, t.neg(r)), o = (e + E1) / Bm;
  return (a, c) => {
    let u = a.pow(c, o), l = a.mul(u, r);
    const f = a.mul(u, i), h = a.mul(u, s), g = a.eql(a.sqr(l), c), d = a.eql(a.sqr(f), c);
    u = a.cmov(u, l, g), l = a.cmov(h, f, d);
    const p = a.eql(a.sqr(l), c), y = a.cmov(u, l, p);
    return Ed(a, y, c), y;
  };
}
function Rm(e) {
  if (e < Am)
    throw new Error("sqrt is not defined for small field");
  let t = e - Jt, n = 0;
  for (; t % si === oe; )
    t /= si, n++;
  let r = si;
  const i = Jc(e);
  for (; Np(i, r) === 1; )
    if (r++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (n === 1)
    return Cm;
  let s = i.pow(r, t);
  const o = (t + Jt) / si;
  return function(c, u) {
    if (c.is0(u))
      return u;
    if (Np(c, u) !== 1)
      throw new Error("Cannot find square root");
    let l = n, f = c.mul(c.ONE, s), h = c.pow(u, t), g = c.pow(u, o);
    for (; !c.eql(h, c.ONE); ) {
      if (c.is0(h))
        return c.ZERO;
      let d = 1, p = c.sqr(h);
      for (; !c.eql(p, c.ONE); )
        if (d++, p = c.sqr(p), d === l)
          throw new Error("Cannot find square root");
      const y = Jt << BigInt(l - d - 1), x = c.pow(f, y);
      l = d, f = c.sqr(x), h = c.mul(h, f), g = c.mul(g, x);
    }
    return g;
  };
}
function v1(e) {
  return e % $m === Am ? Cm : e % Om === Im ? T1 : e % Bm === x1 ? S1(e) : Rm(e);
}
const k1 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function A1(e) {
  const t = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  }, n = k1.reduce((r, i) => (r[i] = "function", r), t);
  return bd(e, n), e;
}
function $1(e, t, n) {
  if (n < oe)
    throw new Error("invalid exponent, negatives unsupported");
  if (n === oe)
    return e.ONE;
  if (n === Jt)
    return t;
  let r = e.ONE, i = t;
  for (; n > oe; )
    n & Jt && (r = e.mul(r, i)), i = e.sqr(i), n >>= Jt;
  return r;
}
function Pm(e, t, n = !1) {
  const r = new Array(t.length).fill(n ? e.ZERO : void 0), i = t.reduce((o, a, c) => e.is0(a) ? o : (r[c] = o, e.mul(o, a)), e.ONE), s = e.inv(i);
  return t.reduceRight((o, a, c) => e.is0(a) ? o : (r[c] = e.mul(o, r[c]), e.mul(o, a)), s), r;
}
function Np(e, t) {
  const n = (e.ORDER - Jt) / si, r = e.pow(t, n), i = e.eql(r, e.ONE), s = e.eql(r, e.ZERO), o = e.eql(r, e.neg(e.ONE));
  if (!i && !s && !o)
    throw new Error("invalid Legendre symbol result");
  return i ? 1 : s ? 0 : -1;
}
function I1(e, t) {
  t !== void 0 && Nr(t);
  const n = t !== void 0 ? t : e.toString(2).length, r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
let O1 = class {
  ORDER;
  BITS;
  BYTES;
  isLE;
  ZERO = oe;
  ONE = Jt;
  _lengths;
  _sqrt;
  // cached sqrt
  _mod;
  constructor(t, n = {}) {
    if (t <= oe)
      throw new Error("invalid field: expected ORDER > 0, got " + t);
    let r;
    this.isLE = !1, n != null && typeof n == "object" && (typeof n.BITS == "number" && (r = n.BITS), typeof n.sqrt == "function" && (this.sqrt = n.sqrt), typeof n.isLE == "boolean" && (this.isLE = n.isLE), n.allowedLengths && (this._lengths = n.allowedLengths?.slice()), typeof n.modFromBytes == "boolean" && (this._mod = n.modFromBytes));
    const { nBitLength: i, nByteLength: s } = I1(t, r);
    if (s > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = t, this.BITS = i, this.BYTES = s, this._sqrt = void 0, Object.preventExtensions(this);
  }
  create(t) {
    return He(t, this.ORDER);
  }
  isValid(t) {
    if (typeof t != "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof t);
    return oe <= t && t < this.ORDER;
  }
  is0(t) {
    return t === oe;
  }
  // is valid and invertible
  isValidNot0(t) {
    return !this.is0(t) && this.isValid(t);
  }
  isOdd(t) {
    return (t & Jt) === Jt;
  }
  neg(t) {
    return He(-t, this.ORDER);
  }
  eql(t, n) {
    return t === n;
  }
  sqr(t) {
    return He(t * t, this.ORDER);
  }
  add(t, n) {
    return He(t + n, this.ORDER);
  }
  sub(t, n) {
    return He(t - n, this.ORDER);
  }
  mul(t, n) {
    return He(t * n, this.ORDER);
  }
  pow(t, n) {
    return $1(this, t, n);
  }
  div(t, n) {
    return He(t * Pp(n, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(t) {
    return t * t;
  }
  addN(t, n) {
    return t + n;
  }
  subN(t, n) {
    return t - n;
  }
  mulN(t, n) {
    return t * n;
  }
  inv(t) {
    return Pp(t, this.ORDER);
  }
  sqrt(t) {
    return this._sqrt || (this._sqrt = v1(this.ORDER)), this._sqrt(this, t);
  }
  toBytes(t) {
    return this.isLE ? vm(t, this.BYTES) : ko(t, this.BYTES);
  }
  fromBytes(t, n = !1) {
    st(t);
    const { _lengths: r, BYTES: i, isLE: s, ORDER: o, _mod: a } = this;
    if (r) {
      if (!r.includes(t.length) || t.length > i)
        throw new Error("Field.fromBytes: expected " + r + " bytes, got " + t.length);
      const u = new Uint8Array(i);
      u.set(t, s ? 0 : u.length - t.length), t = u;
    }
    if (t.length !== i)
      throw new Error("Field.fromBytes: expected " + i + " bytes, got " + t.length);
    let c = s ? Sm(t) : Zn(t);
    if (a && (c = He(c, o)), !n && !this.isValid(c))
      throw new Error("invalid field element: outside of range 0..ORDER");
    return c;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(t) {
    return Pm(this, t);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(t, n, r) {
    return r ? n : t;
  }
};
function Jc(e, t = {}) {
  return new O1(e, t);
}
function Nm(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function Lm(e) {
  const t = Nm(e);
  return t + Math.ceil(t / 2);
}
function Um(e, t, n = !1) {
  st(e);
  const r = e.length, i = Nm(t), s = Lm(t);
  if (r < 16 || r < s || r > 1024)
    throw new Error("expected " + s + "-1024 bytes of input, got " + r);
  const o = n ? Sm(e) : Zn(e), a = He(o, t - Jt) + Jt;
  return n ? vm(a, i) : ko(a, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ss = /* @__PURE__ */ BigInt(0), oi = /* @__PURE__ */ BigInt(1);
function ac(e, t) {
  const n = t.negate();
  return e ? n : t;
}
function Lp(e, t) {
  const n = Pm(e.Fp, t.map((r) => r.Z));
  return t.map((r, i) => e.fromAffine(r.toAffine(n[i])));
}
function _m(e, t) {
  if (!Number.isSafeInteger(e) || e <= 0 || e > t)
    throw new Error("invalid window size, expected [1.." + t + "], got W=" + e);
}
function Wu(e, t) {
  _m(e, t);
  const n = Math.ceil(t / e) + 1, r = 2 ** (e - 1), i = 2 ** e, s = md(e), o = BigInt(e);
  return { windows: n, windowSize: r, mask: s, maxNumber: i, shiftBy: o };
}
function Up(e, t, n) {
  const { windowSize: r, mask: i, maxNumber: s, shiftBy: o } = n;
  let a = Number(e & i), c = e >> o;
  a > r && (a -= s, c += oi);
  const u = t * r, l = u + Math.abs(a) - 1, f = a === 0, h = a < 0, g = t % 2 !== 0;
  return { nextN: c, offset: l, isZero: f, isNeg: h, isNegF: g, offsetF: u };
}
const Ku = /* @__PURE__ */ new WeakMap(), Dm = /* @__PURE__ */ new WeakMap();
function ju(e) {
  return Dm.get(e) || 1;
}
function _p(e) {
  if (e !== ss)
    throw new Error("invalid wNAF");
}
let B1 = class {
  BASE;
  ZERO;
  Fn;
  bits;
  // Parametrized with a given Point class (not individual point)
  constructor(t, n) {
    this.BASE = t.BASE, this.ZERO = t.ZERO, this.Fn = t.Fn, this.bits = n;
  }
  // non-const time multiplication ladder
  _unsafeLadder(t, n, r = this.ZERO) {
    let i = t;
    for (; n > ss; )
      n & oi && (r = r.add(i)), i = i.double(), n >>= oi;
    return r;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:
   * - ùëä is the window size
   * - ùëõ is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(t, n) {
    const { windows: r, windowSize: i } = Wu(n, this.bits), s = [];
    let o = t, a = o;
    for (let c = 0; c < r; c++) {
      a = o, s.push(a);
      for (let u = 1; u < i; u++)
        a = a.add(o), s.push(a);
      o = a.double();
    }
    return s;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(t, n, r) {
    if (!this.Fn.isValid(r))
      throw new Error("invalid scalar");
    let i = this.ZERO, s = this.BASE;
    const o = Wu(t, this.bits);
    for (let a = 0; a < o.windows; a++) {
      const { nextN: c, offset: u, isZero: l, isNeg: f, isNegF: h, offsetF: g } = Up(r, a, o);
      r = c, l ? s = s.add(ac(h, n[g])) : i = i.add(ac(f, n[u]));
    }
    return _p(r), { p: i, f: s };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(t, n, r, i = this.ZERO) {
    const s = Wu(t, this.bits);
    for (let o = 0; o < s.windows && r !== ss; o++) {
      const { nextN: a, offset: c, isZero: u, isNeg: l } = Up(r, o, s);
      if (r = a, !u) {
        const f = n[c];
        i = i.add(l ? f.negate() : f);
      }
    }
    return _p(r), i;
  }
  getPrecomputes(t, n, r) {
    let i = Ku.get(n);
    return i || (i = this.precomputeWindow(n, t), t !== 1 && (typeof r == "function" && (i = r(i)), Ku.set(n, i))), i;
  }
  cached(t, n, r) {
    const i = ju(t);
    return this.wNAF(i, this.getPrecomputes(i, t, r), n);
  }
  unsafe(t, n, r, i) {
    const s = ju(t);
    return s === 1 ? this._unsafeLadder(t, n, i) : this.wNAFUnsafe(s, this.getPrecomputes(s, t, r), n, i);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(t, n) {
    _m(n, this.bits), Dm.set(t, n), Ku.delete(t);
  }
  hasCache(t) {
    return ju(t) !== 1;
  }
};
function C1(e, t, n, r) {
  let i = t, s = e.ZERO, o = e.ZERO;
  for (; n > ss || r > ss; )
    n & oi && (s = s.add(i)), r & oi && (o = o.add(i)), i = i.double(), n >>= oi, r >>= oi;
  return { p1: s, p2: o };
}
function Dp(e, t, n) {
  if (t) {
    if (t.ORDER !== e)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return A1(t), t;
  } else
    return Jc(e, { isLE: n });
}
function R1(e, t, n = {}, r) {
  if (r === void 0 && (r = e === "edwards"), !t || typeof t != "object")
    throw new Error(`expected valid ${e} CURVE object`);
  for (const c of ["p", "n", "h"]) {
    const u = t[c];
    if (!(typeof u == "bigint" && u > ss))
      throw new Error(`CURVE.${c} must be positive bigint`);
  }
  const i = Dp(t.p, n.Fp, r), s = Dp(t.n, n.Fn, r), a = ["Gx", "Gy", "a", "b"];
  for (const c of a)
    if (!i.isValid(t[c]))
      throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);
  return t = Object.freeze(Object.assign({}, t)), { CURVE: t, Fp: i, Fn: s };
}
function Vm(e, t) {
  return function(r) {
    const i = e(r);
    return { secretKey: i, publicKey: t(i) };
  };
}
let Mm = class {
  oHash;
  iHash;
  blockLen;
  outputLen;
  finished = !1;
  destroyed = !1;
  constructor(t, n) {
    if (hm(t), st(n, void 0, "key"), this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const r = this.blockLen, i = new Uint8Array(r);
    i.set(n.length > r ? t.create().update(n).digest() : n);
    for (let s = 0; s < i.length; s++)
      i[s] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let s = 0; s < i.length; s++)
      i[s] ^= 106;
    this.oHash.update(i), rs(i);
  }
  update(t) {
    return ec(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    ec(this), st(t, this.outputLen, "output"), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t ||= Object.create(Object.getPrototypeOf(this), {});
    const { oHash: n, iHash: r, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;
    return t = t, t.finished = i, t.destroyed = s, t.blockLen = o, t.outputLen = a, t.oHash = n._cloneInto(t.oHash), t.iHash = r._cloneInto(t.iHash), t;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const Fm = (e, t, n) => new Mm(e, t).update(n).digest();
Fm.create = (e, t) => new Mm(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Vp = (e, t) => (e + (e >= 0 ? t : -t) / Hm) / t;
function P1(e, t, n) {
  const [[r, i], [s, o]] = t, a = Vp(o * e, n), c = Vp(-i * e, n);
  let u = e - a * r - c * s, l = -a * i - c * o;
  const f = u < Hn, h = l < Hn;
  f && (u = -u), h && (l = -l);
  const g = md(Math.ceil(m1(n) / 2)) + Hi;
  if (u < Hn || u >= g || l < Hn || l >= g)
    throw new Error("splitScalar (endomorphism): failed, k=" + e);
  return { k1neg: f, k1: u, k2neg: h, k2: l };
}
function Yl(e) {
  if (!["compact", "recovered", "der"].includes(e))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return e;
}
function zu(e, t) {
  const n = {};
  for (let r of Object.keys(t))
    n[r] = e[r] === void 0 ? t[r] : e[r];
  return oc(n.lowS, "lowS"), oc(n.prehash, "prehash"), n.format !== void 0 && Yl(n.format), n;
}
let N1 = class extends Error {
  constructor(t = "") {
    super(t);
  }
};
const gr = {
  // asn.1 DER encoding utils
  Err: N1,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, t) => {
      const { Err: n } = gr;
      if (e < 0 || e > 256)
        throw new n("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new n("tlv.encode: unpadded data");
      const r = t.length / 2, i = Ho(r);
      if (i.length / 2 & 128)
        throw new n("tlv.encode: long form length too big");
      const s = r > 127 ? Ho(i.length / 2 | 128) : "";
      return Ho(e) + s + i + t;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, t) {
      const { Err: n } = gr;
      let r = 0;
      if (e < 0 || e > 256)
        throw new n("tlv.encode: wrong tag");
      if (t.length < 2 || t[r++] !== e)
        throw new n("tlv.decode: wrong tlv");
      const i = t[r++], s = !!(i & 128);
      let o = 0;
      if (!s)
        o = i;
      else {
        const c = i & 127;
        if (!c)
          throw new n("tlv.decode(long): indefinite length not supported");
        if (c > 4)
          throw new n("tlv.decode(long): byte length is too big");
        const u = t.subarray(r, r + c);
        if (u.length !== c)
          throw new n("tlv.decode: length bytes not complete");
        if (u[0] === 0)
          throw new n("tlv.decode(long): zero leftmost byte");
        for (const l of u)
          o = o << 8 | l;
        if (r += c, o < 128)
          throw new n("tlv.decode(long): not minimal encoding");
      }
      const a = t.subarray(r, r + o);
      if (a.length !== o)
        throw new n("tlv.decode: wrong value length");
      return { v: a, l: t.subarray(r + o) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: t } = gr;
      if (e < Hn)
        throw new t("integer: negative integers are not allowed");
      let n = Ho(e);
      if (Number.parseInt(n[0], 16) & 8 && (n = "00" + n), n.length & 1)
        throw new t("unexpected DER parsing assertion: unpadded hex");
      return n;
    },
    decode(e) {
      const { Err: t } = gr;
      if (e[0] & 128)
        throw new t("invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new t("invalid signature integer: unnecessary leading zero");
      return Zn(e);
    }
  },
  toSig(e) {
    const { Err: t, _int: n, _tlv: r } = gr, i = st(e, void 0, "signature"), { v: s, l: o } = r.decode(48, i);
    if (o.length)
      throw new t("invalid signature: left bytes after parsing");
    const { v: a, l: c } = r.decode(2, s), { v: u, l } = r.decode(2, c);
    if (l.length)
      throw new t("invalid signature: left bytes after parsing");
    return { r: n.decode(a), s: n.decode(u) };
  },
  hexFromSig(e) {
    const { _tlv: t, _int: n } = gr, r = t.encode(2, n.encode(e.r)), i = t.encode(2, n.encode(e.s)), s = r + i;
    return t.encode(48, s);
  }
}, Hn = BigInt(0), Hi = BigInt(1), Hm = BigInt(2), Wo = BigInt(3), L1 = BigInt(4);
function U1(e, t = {}) {
  const n = R1("weierstrass", e, t), { Fp: r, Fn: i } = n;
  let s = n.CURVE;
  const { h: o, n: a } = s;
  bd(t, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo: c } = t;
  if (c && (!r.is0(s.a) || typeof c.beta != "bigint" || !Array.isArray(c.basises)))
    throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const u = Km(r, i);
  function l() {
    if (!r.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function f(v, b, E) {
    const { x: m, y: T } = b.toAffine(), k = r.toBytes(m);
    if (oc(E, "isCompressed"), E) {
      l();
      const P = !r.isOdd(T);
      return Ge(Wm(P), k);
    } else
      return Ge(Uint8Array.of(4), k, r.toBytes(T));
  }
  function h(v) {
    st(v, void 0, "Point");
    const { publicKey: b, publicKeyUncompressed: E } = u, m = v.length, T = v[0], k = v.subarray(1);
    if (m === b && (T === 2 || T === 3)) {
      const P = r.fromBytes(k);
      if (!r.isValid(P))
        throw new Error("bad point: is not on curve, wrong x");
      const O = p(P);
      let I;
      try {
        I = r.sqrt(O);
      } catch (z) {
        const H = z instanceof Error ? ": " + z.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + H);
      }
      l();
      const $ = r.isOdd(I);
      return (T & 1) === 1 !== $ && (I = r.neg(I)), { x: P, y: I };
    } else if (m === E && T === 4) {
      const P = r.BYTES, O = r.fromBytes(k.subarray(0, P)), I = r.fromBytes(k.subarray(P, P * 2));
      if (!y(O, I))
        throw new Error("bad point: is not on curve");
      return { x: O, y: I };
    } else
      throw new Error(`bad point: got length ${m}, expected compressed=${b} or uncompressed=${E}`);
  }
  const g = t.toBytes || f, d = t.fromBytes || h;
  function p(v) {
    const b = r.sqr(v), E = r.mul(b, v);
    return r.add(r.add(E, r.mul(v, s.a)), s.b);
  }
  function y(v, b) {
    const E = r.sqr(b), m = p(v);
    return r.eql(E, m);
  }
  if (!y(s.Gx, s.Gy))
    throw new Error("bad curve params: generator point");
  const x = r.mul(r.pow(s.a, Wo), L1), S = r.mul(r.sqr(s.b), BigInt(27));
  if (r.is0(r.add(x, S)))
    throw new Error("bad curve params: a or b");
  function A(v, b, E = !1) {
    if (!r.isValid(b) || E && r.is0(b))
      throw new Error(`bad point coordinate ${v}`);
    return b;
  }
  function R(v) {
    if (!(v instanceof U))
      throw new Error("Weierstrass Point expected");
  }
  function N(v) {
    if (!c || !c.basises)
      throw new Error("no endo");
    return P1(v, c.basises, i.ORDER);
  }
  const F = Rp((v, b) => {
    const { X: E, Y: m, Z: T } = v;
    if (r.eql(T, r.ONE))
      return { x: E, y: m };
    const k = v.is0();
    b == null && (b = k ? r.ONE : r.inv(T));
    const P = r.mul(E, b), O = r.mul(m, b), I = r.mul(T, b);
    if (k)
      return { x: r.ZERO, y: r.ZERO };
    if (!r.eql(I, r.ONE))
      throw new Error("invZ was invalid");
    return { x: P, y: O };
  }), w = Rp((v) => {
    if (v.is0()) {
      if (t.allowInfinityPoint && !r.is0(v.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: b, y: E } = v.toAffine();
    if (!r.isValid(b) || !r.isValid(E))
      throw new Error("bad point: x or y not field elements");
    if (!y(b, E))
      throw new Error("bad point: equation left != right");
    if (!v.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  function K(v, b, E, m, T) {
    return E = new U(r.mul(E.X, v), E.Y, E.Z), b = ac(m, b), E = ac(T, E), b.add(E);
  }
  class U {
    // base / generator point
    static BASE = new U(s.Gx, s.Gy, r.ONE);
    // zero / infinity / identity point
    static ZERO = new U(r.ZERO, r.ONE, r.ZERO);
    // 0, 1, 0
    // math field
    static Fp = r;
    // scalar field
    static Fn = i;
    X;
    Y;
    Z;
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(b, E, m) {
      this.X = A("x", b), this.Y = A("y", E, !0), this.Z = A("z", m), Object.freeze(this);
    }
    static CURVE() {
      return s;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(b) {
      const { x: E, y: m } = b || {};
      if (!b || !r.isValid(E) || !r.isValid(m))
        throw new Error("invalid affine point");
      if (b instanceof U)
        throw new Error("projective point not allowed");
      return r.is0(E) && r.is0(m) ? U.ZERO : new U(E, m, r.ONE);
    }
    static fromBytes(b) {
      const E = U.fromAffine(d(st(b, void 0, "point")));
      return E.assertValidity(), E;
    }
    static fromHex(b) {
      return U.fromBytes(nc(b));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(b = 8, E = !0) {
      return B.createCache(this, b), E || this.multiply(Wo), this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      w(this);
    }
    hasEvenY() {
      const { y: b } = this.toAffine();
      if (!r.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !r.isOdd(b);
    }
    /** Compare one point to another. */
    equals(b) {
      R(b);
      const { X: E, Y: m, Z: T } = this, { X: k, Y: P, Z: O } = b, I = r.eql(r.mul(E, O), r.mul(k, T)), $ = r.eql(r.mul(m, O), r.mul(P, T));
      return I && $;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new U(this.X, r.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: b, b: E } = s, m = r.mul(E, Wo), { X: T, Y: k, Z: P } = this;
      let O = r.ZERO, I = r.ZERO, $ = r.ZERO, L = r.mul(T, T), z = r.mul(k, k), H = r.mul(P, P), _ = r.mul(T, k);
      return _ = r.add(_, _), $ = r.mul(T, P), $ = r.add($, $), O = r.mul(b, $), I = r.mul(m, H), I = r.add(O, I), O = r.sub(z, I), I = r.add(z, I), I = r.mul(O, I), O = r.mul(_, O), $ = r.mul(m, $), H = r.mul(b, H), _ = r.sub(L, H), _ = r.mul(b, _), _ = r.add(_, $), $ = r.add(L, L), L = r.add($, L), L = r.add(L, H), L = r.mul(L, _), I = r.add(I, L), H = r.mul(k, P), H = r.add(H, H), L = r.mul(H, _), O = r.sub(O, L), $ = r.mul(H, z), $ = r.add($, $), $ = r.add($, $), new U(O, I, $);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(b) {
      R(b);
      const { X: E, Y: m, Z: T } = this, { X: k, Y: P, Z: O } = b;
      let I = r.ZERO, $ = r.ZERO, L = r.ZERO;
      const z = s.a, H = r.mul(s.b, Wo);
      let _ = r.mul(E, k), j = r.mul(m, P), Y = r.mul(T, O), ot = r.add(E, m), q = r.add(k, P);
      ot = r.mul(ot, q), q = r.add(_, j), ot = r.sub(ot, q), q = r.add(E, T);
      let Q = r.add(k, O);
      return q = r.mul(q, Q), Q = r.add(_, Y), q = r.sub(q, Q), Q = r.add(m, T), I = r.add(P, O), Q = r.mul(Q, I), I = r.add(j, Y), Q = r.sub(Q, I), L = r.mul(z, q), I = r.mul(H, Y), L = r.add(I, L), I = r.sub(j, L), L = r.add(j, L), $ = r.mul(I, L), j = r.add(_, _), j = r.add(j, _), Y = r.mul(z, Y), q = r.mul(H, q), j = r.add(j, Y), Y = r.sub(_, Y), Y = r.mul(z, Y), q = r.add(q, Y), _ = r.mul(j, q), $ = r.add($, _), _ = r.mul(Q, q), I = r.mul(ot, I), I = r.sub(I, _), _ = r.mul(ot, j), L = r.mul(Q, L), L = r.add(L, _), new U(I, $, L);
    }
    subtract(b) {
      return this.add(b.negate());
    }
    is0() {
      return this.equals(U.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(b) {
      const { endo: E } = t;
      if (!i.isValidNot0(b))
        throw new Error("invalid scalar: out of range");
      let m, T;
      const k = (P) => B.cached(this, P, (O) => Lp(U, O));
      if (E) {
        const { k1neg: P, k1: O, k2neg: I, k2: $ } = N(b), { p: L, f: z } = k(O), { p: H, f: _ } = k($);
        T = z.add(_), m = K(E.beta, L, H, P, I);
      } else {
        const { p: P, f: O } = k(b);
        m = P, T = O;
      }
      return Lp(U, [m, T])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(b) {
      const { endo: E } = t, m = this;
      if (!i.isValid(b))
        throw new Error("invalid scalar: out of range");
      if (b === Hn || m.is0())
        return U.ZERO;
      if (b === Hi)
        return m;
      if (B.hasCache(this))
        return this.multiply(b);
      if (E) {
        const { k1neg: T, k1: k, k2neg: P, k2: O } = N(b), { p1: I, p2: $ } = C1(U, m, k, O);
        return K(E.beta, I, $, T, P);
      } else
        return B.unsafe(m, b);
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(b) {
      return F(this, b);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: b } = t;
      return o === Hi ? !0 : b ? b(U, this) : B.unsafe(this, a).is0();
    }
    clearCofactor() {
      const { clearCofactor: b } = t;
      return o === Hi ? this : b ? b(U, this) : this.multiplyUnsafe(o);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(o).is0();
    }
    toBytes(b = !0) {
      return oc(b, "isCompressed"), this.assertValidity(), g(U, this, b);
    }
    toHex(b = !0) {
      return Zc(this.toBytes(b));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  const W = i.BITS, B = new B1(U, t.endo ? Math.ceil(W / 2) : W);
  return U.BASE.precompute(8), U;
}
function Wm(e) {
  return Uint8Array.of(e ? 2 : 3);
}
function Km(e, t) {
  return {
    secretKey: t.BYTES,
    publicKey: 1 + e.BYTES,
    publicKeyUncompressed: 1 + 2 * e.BYTES,
    publicKeyHasPrefix: !0,
    signature: 2 * t.BYTES
  };
}
function _1(e, t = {}) {
  const { Fn: n } = e, r = t.randomBytes || Es, i = Object.assign(Km(e.Fp, n), { seed: Lm(n.ORDER) });
  function s(g) {
    try {
      const d = n.fromBytes(g);
      return n.isValidNot0(d);
    } catch {
      return !1;
    }
  }
  function o(g, d) {
    const { publicKey: p, publicKeyUncompressed: y } = i;
    try {
      const x = g.length;
      return d === !0 && x !== p || d === !1 && x !== y ? !1 : !!e.fromBytes(g);
    } catch {
      return !1;
    }
  }
  function a(g = r(i.seed)) {
    return Um(st(g, i.seed, "seed"), n.ORDER);
  }
  function c(g, d = !0) {
    return e.BASE.multiply(n.fromBytes(g)).toBytes(d);
  }
  function u(g) {
    const { secretKey: d, publicKey: p, publicKeyUncompressed: y } = i;
    if (!hd(g) || "_lengths" in n && n._lengths || d === p)
      return;
    const x = st(g, void 0, "key").length;
    return x === p || x === y;
  }
  function l(g, d, p = !0) {
    if (u(g) === !0)
      throw new Error("first arg must be private key");
    if (u(d) === !1)
      throw new Error("second arg must be public key");
    const y = n.fromBytes(g);
    return e.fromBytes(d).multiply(y).toBytes(p);
  }
  const f = {
    isValidSecretKey: s,
    isValidPublicKey: o,
    randomSecretKey: a
  }, h = Vm(a, c);
  return Object.freeze({ getPublicKey: c, getSharedSecret: l, keygen: h, Point: e, utils: f, lengths: i });
}
function D1(e, t, n = {}) {
  hm(t), bd(n, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  }), n = Object.assign({}, n);
  const r = n.randomBytes || Es, i = n.hmac || ((E, m) => Fm(t, E, m)), { Fp: s, Fn: o } = e, { ORDER: a, BITS: c } = o, { keygen: u, getPublicKey: l, getSharedSecret: f, utils: h, lengths: g } = _1(e, n), d = {
    prehash: !0,
    lowS: typeof n.lowS == "boolean" ? n.lowS : !0,
    format: "compact",
    extraEntropy: !1
  }, p = a * Hm < s.ORDER;
  function y(E) {
    const m = a >> Hi;
    return E > m;
  }
  function x(E, m) {
    if (!o.isValidNot0(m))
      throw new Error(`invalid signature ${E}: out of range 1..Point.Fn.ORDER`);
    return m;
  }
  function S() {
    if (p)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function A(E, m) {
    Yl(m);
    const T = g.signature, k = m === "compact" ? T : m === "recovered" ? T + 1 : void 0;
    return st(E, k);
  }
  class R {
    r;
    s;
    recovery;
    constructor(m, T, k) {
      if (this.r = x("r", m), this.s = x("s", T), k != null) {
        if (S(), ![0, 1, 2, 3].includes(k))
          throw new Error("invalid recovery id");
        this.recovery = k;
      }
      Object.freeze(this);
    }
    static fromBytes(m, T = d.format) {
      A(m, T);
      let k;
      if (T === "der") {
        const { r: $, s: L } = gr.toSig(st(m));
        return new R($, L);
      }
      T === "recovered" && (k = m[0], T = "compact", m = m.subarray(1));
      const P = g.signature / 2, O = m.subarray(0, P), I = m.subarray(P, P * 2);
      return new R(o.fromBytes(O), o.fromBytes(I), k);
    }
    static fromHex(m, T) {
      return this.fromBytes(nc(m), T);
    }
    assertRecovery() {
      const { recovery: m } = this;
      if (m == null)
        throw new Error("invalid recovery id: must be present");
      return m;
    }
    addRecoveryBit(m) {
      return new R(this.r, this.s, m);
    }
    recoverPublicKey(m) {
      const { r: T, s: k } = this, P = this.assertRecovery(), O = P === 2 || P === 3 ? T + a : T;
      if (!s.isValid(O))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const I = s.toBytes(O), $ = e.fromBytes(Ge(Wm((P & 1) === 0), I)), L = o.inv(O), z = F(st(m, void 0, "msgHash")), H = o.create(-z * L), _ = o.create(k * L), j = e.BASE.multiplyUnsafe(H).add($.multiplyUnsafe(_));
      if (j.is0())
        throw new Error("invalid recovery: point at infinify");
      return j.assertValidity(), j;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return y(this.s);
    }
    toBytes(m = d.format) {
      if (Yl(m), m === "der")
        return nc(gr.hexFromSig(this));
      const { r: T, s: k } = this, P = o.toBytes(T), O = o.toBytes(k);
      return m === "recovered" ? (S(), Ge(Uint8Array.of(this.assertRecovery()), P, O)) : Ge(P, O);
    }
    toHex(m) {
      return Zc(this.toBytes(m));
    }
  }
  const N = n.bits2int || function(m) {
    if (m.length > 8192)
      throw new Error("input is too large");
    const T = Zn(m), k = m.length * 8 - c;
    return k > 0 ? T >> BigInt(k) : T;
  }, F = n.bits2int_modN || function(m) {
    return o.create(N(m));
  }, w = md(c);
  function K(E) {
    return km("num < 2^" + c, E, Hn, w), o.toBytes(E);
  }
  function U(E, m) {
    return st(E, void 0, "message"), m ? st(t(E), void 0, "prehashed message") : E;
  }
  function W(E, m, T) {
    const { lowS: k, prehash: P, extraEntropy: O } = zu(T, d);
    E = U(E, P);
    const I = F(E), $ = o.fromBytes(m);
    if (!o.isValidNot0($))
      throw new Error("invalid private key");
    const L = [K($), K(I)];
    if (O != null && O !== !1) {
      const j = O === !0 ? r(g.secretKey) : O;
      L.push(st(j, void 0, "extraEntropy"));
    }
    const z = Ge(...L), H = I;
    function _(j) {
      const Y = N(j);
      if (!o.isValidNot0(Y))
        return;
      const ot = o.inv(Y), q = e.BASE.multiply(Y).toAffine(), Q = o.create(q.x);
      if (Q === Hn)
        return;
      const ee = o.create(ot * o.create(H + Q * $));
      if (ee === Hn)
        return;
      let Qn = (q.x === Q ? 0 : 2) | Number(q.y & Hi), Jn = ee;
      return k && y(ee) && (Jn = o.neg(ee), Qn ^= 1), new R(Q, Jn, p ? void 0 : Qn);
    }
    return { seed: z, k2sig: _ };
  }
  function B(E, m, T = {}) {
    const { seed: k, k2sig: P } = W(E, m, T);
    return b1(t.outputLen, o.BYTES, i)(k, P).toBytes(T.format);
  }
  function v(E, m, T, k = {}) {
    const { lowS: P, prehash: O, format: I } = zu(k, d);
    if (T = st(T, void 0, "publicKey"), m = U(m, O), !hd(E)) {
      const $ = E instanceof R ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + $);
    }
    A(E, I);
    try {
      const $ = R.fromBytes(E, I), L = e.fromBytes(T);
      if (P && $.hasHighS())
        return !1;
      const { r: z, s: H } = $, _ = F(m), j = o.inv(H), Y = o.create(_ * j), ot = o.create(z * j), q = e.BASE.multiplyUnsafe(Y).add(L.multiplyUnsafe(ot));
      return q.is0() ? !1 : o.create(q.x) === z;
    } catch {
      return !1;
    }
  }
  function b(E, m, T = {}) {
    const { prehash: k } = zu(T, d);
    return m = U(m, k), R.fromBytes(E, "recovered").recoverPublicKey(m).toBytes();
  }
  return Object.freeze({
    keygen: u,
    getPublicKey: l,
    getSharedSecret: f,
    utils: h,
    lengths: g,
    Point: e,
    sign: B,
    verify: v,
    recoverPublicKey: b,
    Signature: R,
    hash: t
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const tu = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
}, V1 = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
}, M1 = /* @__PURE__ */ BigInt(0), Zl = /* @__PURE__ */ BigInt(2);
function F1(e) {
  const t = tu.p, n = BigInt(3), r = BigInt(6), i = BigInt(11), s = BigInt(22), o = BigInt(23), a = BigInt(44), c = BigInt(88), u = e * e * e % t, l = u * u * e % t, f = ve(l, n, t) * l % t, h = ve(f, n, t) * l % t, g = ve(h, Zl, t) * u % t, d = ve(g, i, t) * g % t, p = ve(d, s, t) * d % t, y = ve(p, a, t) * p % t, x = ve(y, c, t) * y % t, S = ve(x, a, t) * p % t, A = ve(S, n, t) * l % t, R = ve(A, o, t) * d % t, N = ve(R, r, t) * u % t, F = ve(N, Zl, t);
  if (!cc.eql(cc.sqr(F), e))
    throw new Error("Cannot find square root");
  return F;
}
const cc = Jc(tu.p, { sqrt: F1 }), vi = /* @__PURE__ */ U1(tu, {
  Fp: cc,
  endo: V1
}), xr = /* @__PURE__ */ D1(vi, Bt), Mp = {};
function uc(e, ...t) {
  let n = Mp[e];
  if (n === void 0) {
    const r = Bt(y1(e));
    n = Ge(r, r), Mp[e] = n;
  }
  return Bt(Ge(n, ...t));
}
const xd = (e) => e.toBytes(!0).slice(1), Td = (e) => e % Zl === M1;
function Xl(e) {
  const { Fn: t, BASE: n } = vi, r = t.fromBytes(e), i = n.multiply(r);
  return { scalar: Td(i.y) ? r : t.neg(r), bytes: xd(i) };
}
function jm(e) {
  const t = cc;
  if (!t.isValidNot0(e))
    throw new Error("invalid x: Fail if x ‚â• p");
  const n = t.create(e * e), r = t.create(n * e + BigInt(7));
  let i = t.sqrt(r);
  Td(i) || (i = t.neg(i));
  const s = vi.fromAffine({ x: e, y: i });
  return s.assertValidity(), s;
}
const Ys = Zn;
function zm(...e) {
  return vi.Fn.create(Ys(uc("BIP0340/challenge", ...e)));
}
function Fp(e) {
  return Xl(e).bytes;
}
function H1(e, t, n = Es(32)) {
  const { Fn: r } = vi, i = st(e, void 0, "message"), { bytes: s, scalar: o } = Xl(t), a = st(n, 32, "auxRand"), c = r.toBytes(o ^ Ys(uc("BIP0340/aux", a))), u = uc("BIP0340/nonce", c, s, i), { bytes: l, scalar: f } = Xl(u), h = zm(l, s, i), g = new Uint8Array(64);
  if (g.set(l, 0), g.set(r.toBytes(r.create(f + h * o)), 32), !qm(g, i, s))
    throw new Error("sign: Invalid signature produced");
  return g;
}
function qm(e, t, n) {
  const { Fp: r, Fn: i, BASE: s } = vi, o = st(e, 64, "signature"), a = st(t, void 0, "message"), c = st(n, 32, "publicKey");
  try {
    const u = jm(Ys(c)), l = Ys(o.subarray(0, 32));
    if (!r.isValidNot0(l))
      return !1;
    const f = Ys(o.subarray(32, 64));
    if (!i.isValidNot0(f))
      return !1;
    const h = zm(i.toBytes(l), xd(u), a), g = s.multiplyUnsafe(f).add(u.multiplyUnsafe(i.neg(h))), { x: d, y: p } = g.toAffine();
    return !(g.is0() || !Td(p) || d !== l);
  } catch {
    return !1;
  }
}
const Xn = /* @__PURE__ */ (() => {
  const n = (r = Es(48)) => Um(r, tu.n);
  return {
    keygen: Vm(n, Fp),
    getPublicKey: Fp,
    sign: H1,
    verify: qm,
    Point: vi,
    utils: {
      randomSecretKey: n,
      taggedHash: uc,
      lift_x: jm,
      pointToBytes: xd
    },
    lengths: {
      secretKey: 32,
      publicKey: 32,
      publicKeyHasPrefix: !1,
      signature: 64,
      seed: 48
    }
  };
})(), W1 = /* @__PURE__ */ Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]), Gm = Uint8Array.from(new Array(16).fill(0).map((e, t) => t)), K1 = Gm.map((e) => (9 * e + 5) % 16), Ym = /* @__PURE__ */ (() => {
  const n = [[Gm], [K1]];
  for (let r = 0; r < 4; r++)
    for (let i of n)
      i.push(i[r].map((s) => W1[s]));
  return n;
})(), Zm = Ym[0], Xm = Ym[1], Qm = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((e) => Uint8Array.from(e)), j1 = /* @__PURE__ */ Zm.map((e, t) => e.map((n) => Qm[t][n])), z1 = /* @__PURE__ */ Xm.map((e, t) => e.map((n) => Qm[t][n])), q1 = /* @__PURE__ */ Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), G1 = /* @__PURE__ */ Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function Hp(e, t, n, r) {
  return e === 0 ? t ^ n ^ r : e === 1 ? t & n | ~t & r : e === 2 ? (t | ~n) ^ r : e === 3 ? t & r | n & ~r : t ^ (n | ~r);
}
const Ko = /* @__PURE__ */ new Uint32Array(16);
class Y1 extends ym {
  h0 = 1732584193;
  h1 = -271733879;
  h2 = -1732584194;
  h3 = 271733878;
  h4 = -1009589776;
  constructor() {
    super(64, 20, 8, !0);
  }
  get() {
    const { h0: t, h1: n, h2: r, h3: i, h4: s } = this;
    return [t, n, r, i, s];
  }
  set(t, n, r, i, s) {
    this.h0 = t | 0, this.h1 = n | 0, this.h2 = r | 0, this.h3 = i | 0, this.h4 = s | 0;
  }
  process(t, n) {
    for (let g = 0; g < 16; g++, n += 4)
      Ko[g] = t.getUint32(n, !0);
    let r = this.h0 | 0, i = r, s = this.h1 | 0, o = s, a = this.h2 | 0, c = a, u = this.h3 | 0, l = u, f = this.h4 | 0, h = f;
    for (let g = 0; g < 5; g++) {
      const d = 4 - g, p = q1[g], y = G1[g], x = Zm[g], S = Xm[g], A = j1[g], R = z1[g];
      for (let N = 0; N < 16; N++) {
        const F = Fo(r + Hp(g, s, a, u) + Ko[x[N]] + p, A[N]) + f | 0;
        r = f, f = u, u = Fo(a, 10) | 0, a = s, s = F;
      }
      for (let N = 0; N < 16; N++) {
        const F = Fo(i + Hp(d, o, c, l) + Ko[S[N]] + y, R[N]) + h | 0;
        i = h, h = l, l = Fo(c, 10) | 0, c = o, o = F;
      }
    }
    this.set(this.h1 + a + l | 0, this.h2 + u + h | 0, this.h3 + f + i | 0, this.h4 + r + o | 0, this.h0 + s + c | 0);
  }
  roundClean() {
    rs(Ko);
  }
  destroy() {
    this.destroyed = !0, rs(this.buffer), this.set(0, 0, 0, 0, 0);
  }
}
const Jm = /* @__PURE__ */ gm(() => new Y1()), $t = /* @__PURE__ */ Uint8Array.of(), tb = /* @__PURE__ */ Uint8Array.of(0);
function os(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function Ce(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function Z1(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    if (!Ce(i))
      throw new Error("Uint8Array expected");
    t += i.length;
  }
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const s = e[r];
    n.set(s, i), i += s.length;
  }
  return n;
}
const eb = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
function Ao(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function On(e) {
  return Number.isSafeInteger(e);
}
const Sd = {
  equalBytes: os,
  isBytes: Ce,
  concatBytes: Z1
}, nb = (e) => {
  if (e !== null && typeof e != "string" && !Qe(e) && !Ce(e) && !On(e))
    throw new Error(`lengthCoder: expected null | number | Uint8Array | CoderType, got ${e} (${typeof e})`);
  return {
    encodeStream(t, n) {
      if (e === null)
        return;
      if (Qe(e))
        return e.encodeStream(t, n);
      let r;
      if (typeof e == "number" ? r = e : typeof e == "string" && (r = qn.resolve(t.stack, e)), typeof r == "bigint" && (r = Number(r)), r === void 0 || r !== n)
        throw t.err(`Wrong length: ${r} len=${e} exp=${n} (${typeof n})`);
    },
    decodeStream(t) {
      let n;
      if (Qe(e) ? n = Number(e.decodeStream(t)) : typeof e == "number" ? n = e : typeof e == "string" && (n = qn.resolve(t.stack, e)), typeof n == "bigint" && (n = Number(n)), typeof n != "number")
        throw t.err(`Wrong length: ${n}`);
      return n;
    }
  };
}, Ft = {
  BITS: 32,
  FULL_MASK: -1 >>> 0,
  // 1<<32 will overflow
  len: (e) => Math.ceil(e / 32),
  create: (e) => new Uint32Array(Ft.len(e)),
  clean: (e) => e.fill(0),
  debug: (e) => Array.from(e).map((t) => (t >>> 0).toString(2).padStart(32, "0")),
  checkLen: (e, t) => {
    if (Ft.len(t) !== e.length)
      throw new Error(`wrong length=${e.length}. Expected: ${Ft.len(t)}`);
  },
  chunkLen: (e, t, n) => {
    if (t < 0)
      throw new Error(`wrong pos=${t}`);
    if (t + n > e)
      throw new Error(`wrong range=${t}/${n} of ${e}`);
  },
  set: (e, t, n, r = !0) => !r && (e[t] & n) !== 0 ? !1 : (e[t] |= n, !0),
  pos: (e, t) => ({
    chunk: Math.floor((e + t) / 32),
    mask: 1 << 32 - (e + t) % 32 - 1
  }),
  indices: (e, t, n = !1) => {
    Ft.checkLen(e, t);
    const { FULL_MASK: r, BITS: i } = Ft, s = i - t % i, o = s ? r >>> s << s : r, a = [];
    for (let c = 0; c < e.length; c++) {
      let u = e[c];
      if (n && (u = ~u), c === e.length - 1 && (u &= o), u !== 0)
        for (let l = 0; l < i; l++) {
          const f = 1 << i - l - 1;
          u & f && a.push(c * i + l);
        }
    }
    return a;
  },
  range: (e) => {
    const t = [];
    let n;
    for (const r of e)
      n === void 0 || r !== n.pos + n.length ? t.push(n = { pos: r, length: 1 }) : n.length += 1;
    return t;
  },
  rangeDebug: (e, t, n = !1) => `[${Ft.range(Ft.indices(e, t, n)).map((r) => `(${r.pos}/${r.length})`).join(", ")}]`,
  setRange: (e, t, n, r, i = !0) => {
    Ft.chunkLen(t, n, r);
    const { FULL_MASK: s, BITS: o } = Ft, a = n % o ? Math.floor(n / o) : void 0, c = n + r, u = c % o ? Math.floor(c / o) : void 0;
    if (a !== void 0 && a === u)
      return Ft.set(e, a, s >>> o - r << o - r - n, i);
    if (a !== void 0 && !Ft.set(e, a, s >>> n % o, i))
      return !1;
    const l = a !== void 0 ? a + 1 : n / o, f = u !== void 0 ? u : c / o;
    for (let h = l; h < f; h++)
      if (!Ft.set(e, h, s, i))
        return !1;
    return !(u !== void 0 && a !== u && !Ft.set(e, u, s << o - c % o, i));
  }
}, qn = {
  /**
   * Internal method for handling stack of paths (debug, errors, dynamic fields via path)
   * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).
   * Also, this makes impossible:
   * - pushing field when stack is empty
   * - pushing field inside of field (real bug)
   * NOTE: we don't want to do '.pop' on error!
   */
  pushObj: (e, t, n) => {
    const r = { obj: t };
    e.push(r), n((i, s) => {
      r.field = i, s(), r.field = void 0;
    }), e.pop();
  },
  path: (e) => {
    const t = [];
    for (const n of e)
      n.field !== void 0 && t.push(n.field);
    return t.join("/");
  },
  err: (e, t, n) => {
    const r = new Error(`${e}(${qn.path(t)}): ${typeof n == "string" ? n : n.message}`);
    return n instanceof Error && n.stack && (r.stack = n.stack), r;
  },
  resolve: (e, t) => {
    const n = t.split("/"), r = e.map((o) => o.obj);
    let i = 0;
    for (; i < n.length && n[i] === ".."; i++)
      r.pop();
    let s = r.pop();
    for (; i < n.length; i++) {
      if (!s || s[n[i]] === void 0)
        return;
      s = s[n[i]];
    }
    return s;
  }
};
class vd {
  pos = 0;
  data;
  opts;
  stack;
  parent;
  parentOffset;
  bitBuf = 0;
  bitPos = 0;
  bs;
  // bitset
  view;
  constructor(t, n = {}, r = [], i = void 0, s = 0) {
    this.data = t, this.opts = n, this.stack = r, this.parent = i, this.parentOffset = s, this.view = eb(t);
  }
  /** Internal method for pointers. */
  _enablePointers() {
    if (this.parent)
      return this.parent._enablePointers();
    this.bs || (this.bs = Ft.create(this.data.length), Ft.setRange(this.bs, this.data.length, 0, this.pos, this.opts.allowMultipleReads));
  }
  markBytesBS(t, n) {
    return this.parent ? this.parent.markBytesBS(this.parentOffset + t, n) : !n || !this.bs ? !0 : Ft.setRange(this.bs, this.data.length, t, n, !1);
  }
  markBytes(t) {
    const n = this.pos;
    this.pos += t;
    const r = this.markBytesBS(n, t);
    if (!this.opts.allowMultipleReads && !r)
      throw this.err(`multiple read pos=${this.pos} len=${t}`);
    return r;
  }
  pushObj(t, n) {
    return qn.pushObj(this.stack, t, n);
  }
  readView(t, n) {
    if (!Number.isFinite(t))
      throw this.err(`readView: wrong length=${t}`);
    if (this.pos + t > this.data.length)
      throw this.err("readView: Unexpected end of buffer");
    const r = n(this.view, this.pos);
    return this.markBytes(t), r;
  }
  // read bytes by absolute offset
  absBytes(t) {
    if (t > this.data.length)
      throw new Error("Unexpected end of buffer");
    return this.data.subarray(t);
  }
  finish() {
    if (!this.opts.allowUnreadBytes) {
      if (this.bitPos)
        throw this.err(`${this.bitPos} bits left after unpack: ${C.encode(this.data.slice(this.pos))}`);
      if (this.bs && !this.parent) {
        const t = Ft.indices(this.bs, this.data.length, !0);
        if (t.length) {
          const n = Ft.range(t).map(({ pos: r, length: i }) => `(${r}/${i})[${C.encode(this.data.subarray(r, r + i))}]`).join(", ");
          throw this.err(`unread byte ranges: ${n} (total=${this.data.length})`);
        } else
          return;
      }
      if (!this.isEnd())
        throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${C.encode(this.data.slice(this.pos))}`);
    }
  }
  // User methods
  err(t) {
    return qn.err("Reader", this.stack, t);
  }
  offsetReader(t) {
    if (t > this.data.length)
      throw this.err("offsetReader: Unexpected end of buffer");
    return new vd(this.absBytes(t), this.opts, this.stack, this, t);
  }
  bytes(t, n = !1) {
    if (this.bitPos)
      throw this.err("readBytes: bitPos not empty");
    if (!Number.isFinite(t))
      throw this.err(`readBytes: wrong length=${t}`);
    if (this.pos + t > this.data.length)
      throw this.err("readBytes: Unexpected end of buffer");
    const r = this.data.subarray(this.pos, this.pos + t);
    return n || this.markBytes(t), r;
  }
  byte(t = !1) {
    if (this.bitPos)
      throw this.err("readByte: bitPos not empty");
    if (this.pos + 1 > this.data.length)
      throw this.err("readBytes: Unexpected end of buffer");
    const n = this.data[this.pos];
    return t || this.markBytes(1), n;
  }
  get leftBytes() {
    return this.data.length - this.pos;
  }
  get totalBytes() {
    return this.data.length;
  }
  isEnd() {
    return this.pos >= this.data.length && !this.bitPos;
  }
  // bits are read in BE mode (left to right): (0b1000_0000).readBits(1) == 1
  bits(t) {
    if (t > 32)
      throw this.err("BitReader: cannot read more than 32 bits in single call");
    let n = 0;
    for (; t; ) {
      this.bitPos || (this.bitBuf = this.byte(), this.bitPos = 8);
      const r = Math.min(t, this.bitPos);
      this.bitPos -= r, n = n << r | this.bitBuf >> this.bitPos & 2 ** r - 1, this.bitBuf &= 2 ** this.bitPos - 1, t -= r;
    }
    return n >>> 0;
  }
  find(t, n = this.pos) {
    if (!Ce(t))
      throw this.err(`find: needle is not bytes! ${t}`);
    if (this.bitPos)
      throw this.err("findByte: bitPos not empty");
    if (!t.length)
      throw this.err("find: needle is empty");
    for (let r = n; (r = this.data.indexOf(t[0], r)) !== -1; r++) {
      if (r === -1 || this.data.length - r < t.length)
        return;
      if (os(t, this.data.subarray(r, r + t.length)))
        return r;
    }
  }
}
class X1 {
  pos = 0;
  stack;
  // We could have a single buffer here and re-alloc it with
  // x1.5-2 size each time it full, but it will be slower:
  // basic/encode bench: 395ns -> 560ns
  buffers = [];
  ptrs = [];
  bitBuf = 0;
  bitPos = 0;
  viewBuf = new Uint8Array(8);
  view;
  finished = !1;
  constructor(t = []) {
    this.stack = t, this.view = eb(this.viewBuf);
  }
  pushObj(t, n) {
    return qn.pushObj(this.stack, t, n);
  }
  writeView(t, n) {
    if (this.finished)
      throw this.err("buffer: finished");
    if (!On(t) || t > 8)
      throw new Error(`wrong writeView length=${t}`);
    n(this.view), this.bytes(this.viewBuf.slice(0, t)), this.viewBuf.fill(0);
  }
  // User methods
  err(t) {
    if (this.finished)
      throw this.err("buffer: finished");
    return qn.err("Reader", this.stack, t);
  }
  bytes(t) {
    if (this.finished)
      throw this.err("buffer: finished");
    if (this.bitPos)
      throw this.err("writeBytes: ends with non-empty bit buffer");
    this.buffers.push(t), this.pos += t.length;
  }
  byte(t) {
    if (this.finished)
      throw this.err("buffer: finished");
    if (this.bitPos)
      throw this.err("writeByte: ends with non-empty bit buffer");
    this.buffers.push(new Uint8Array([t])), this.pos++;
  }
  finish(t = !0) {
    if (this.finished)
      throw this.err("buffer: finished");
    if (this.bitPos)
      throw this.err("buffer: ends with non-empty bit buffer");
    const n = this.buffers.concat(this.ptrs.map((s) => s.buffer)), r = n.map((s) => s.length).reduce((s, o) => s + o, 0), i = new Uint8Array(r);
    for (let s = 0, o = 0; s < n.length; s++) {
      const a = n[s];
      i.set(a, o), o += a.length;
    }
    for (let s = this.pos, o = 0; o < this.ptrs.length; o++) {
      const a = this.ptrs[o];
      i.set(a.ptr.encode(s), a.pos), s += a.buffer.length;
    }
    if (t) {
      this.buffers = [];
      for (const s of this.ptrs)
        s.buffer.fill(0);
      this.ptrs = [], this.finished = !0, this.bitBuf = 0;
    }
    return i;
  }
  bits(t, n) {
    if (n > 32)
      throw this.err("writeBits: cannot write more than 32 bits in single call");
    if (t >= 2 ** n)
      throw this.err(`writeBits: value (${t}) >= 2**bits (${n})`);
    for (; n; ) {
      const r = Math.min(n, 8 - this.bitPos);
      this.bitBuf = this.bitBuf << r | t >> n - r, this.bitPos += r, n -= r, t &= 2 ** n - 1, this.bitPos === 8 && (this.bitPos = 0, this.buffers.push(new Uint8Array([this.bitBuf])), this.pos++);
    }
  }
}
const Ql = (e) => Uint8Array.from(e).reverse();
function Q1(e, t, n) {
  if (n) {
    const r = 2n ** (t - 1n);
    if (e < -r || e >= r)
      throw new Error(`value out of signed bounds. Expected ${-r} <= ${e} < ${r}`);
  } else if (0n > e || e >= 2n ** t)
    throw new Error(`value out of unsigned bounds. Expected 0 <= ${e} < ${2n ** t}`);
}
function rb(e) {
  return {
    // NOTE: we cannot export validate here, since it is likely mistake.
    encodeStream: e.encodeStream,
    decodeStream: e.decodeStream,
    size: e.size,
    encode: (t) => {
      const n = new X1();
      return e.encodeStream(n, t), n.finish();
    },
    decode: (t, n = {}) => {
      const r = new vd(t, n), i = e.decodeStream(r);
      return r.finish(), i;
    }
  };
}
function de(e, t) {
  if (!Qe(e))
    throw new Error(`validate: invalid inner value ${e}`);
  if (typeof t != "function")
    throw new Error("validate: fn should be function");
  return rb({
    size: e.size,
    encodeStream: (n, r) => {
      let i;
      try {
        i = t(r);
      } catch (s) {
        throw n.err(s);
      }
      e.encodeStream(n, i);
    },
    decodeStream: (n) => {
      const r = e.decodeStream(n);
      try {
        return t(r);
      } catch (i) {
        throw n.err(i);
      }
    }
  });
}
const he = (e) => {
  const t = rb(e);
  return e.validate ? de(t, e.validate) : t;
}, eu = (e) => Ao(e) && typeof e.decode == "function" && typeof e.encode == "function";
function Qe(e) {
  return Ao(e) && eu(e) && typeof e.encodeStream == "function" && typeof e.decodeStream == "function" && (e.size === void 0 || On(e.size));
}
function J1() {
  return {
    encode: (e) => {
      if (!Array.isArray(e))
        throw new Error("array expected");
      const t = {};
      for (const n of e) {
        if (!Array.isArray(n) || n.length !== 2)
          throw new Error("array of two elements expected");
        const r = n[0], i = n[1];
        if (t[r] !== void 0)
          throw new Error(`key(${r}) appears twice in struct`);
        t[r] = i;
      }
      return t;
    },
    decode: (e) => {
      if (!Ao(e))
        throw new Error(`expected plain object, got ${e}`);
      return Object.entries(e);
    }
  };
}
const tk = {
  encode: (e) => {
    if (typeof e != "bigint")
      throw new Error(`expected bigint, got ${typeof e}`);
    if (e > BigInt(Number.MAX_SAFE_INTEGER))
      throw new Error(`element bigger than MAX_SAFE_INTEGER=${e}`);
    return Number(e);
  },
  decode: (e) => {
    if (!On(e))
      throw new Error("element is not a safe integer");
    return BigInt(e);
  }
};
function ek(e) {
  if (!Ao(e))
    throw new Error("plain object expected");
  return {
    encode: (t) => {
      if (!On(t) || !(t in e))
        throw new Error(`wrong value ${t}`);
      return e[t];
    },
    decode: (t) => {
      if (typeof t != "string")
        throw new Error(`wrong value ${typeof t}`);
      return e[t];
    }
  };
}
function nk(e, t = !1) {
  if (!On(e))
    throw new Error(`decimal/precision: wrong value ${e}`);
  if (typeof t != "boolean")
    throw new Error(`decimal/round: expected boolean, got ${typeof t}`);
  const n = 10n ** BigInt(e);
  return {
    encode: (r) => {
      if (typeof r != "bigint")
        throw new Error(`expected bigint, got ${typeof r}`);
      let i = (r < 0n ? -r : r).toString(10), s = i.length - e;
      s < 0 && (i = i.padStart(i.length - s, "0"), s = 0);
      let o = i.length - 1;
      for (; o >= s && i[o] === "0"; o--)
        ;
      let a = i.slice(0, s), c = i.slice(s, o + 1);
      return a || (a = "0"), r < 0n && (a = "-" + a), c ? `${a}.${c}` : a;
    },
    decode: (r) => {
      if (typeof r != "string")
        throw new Error(`expected string, got ${typeof r}`);
      if (r === "-0")
        throw new Error("negative zero is not allowed");
      let i = !1;
      if (r.startsWith("-") && (i = !0, r = r.slice(1)), !/^(0|[1-9]\d*)(\.\d+)?$/.test(r))
        throw new Error(`wrong string value=${r}`);
      let s = r.indexOf(".");
      s = s === -1 ? r.length : s;
      const o = r.slice(0, s), a = r.slice(s + 1).replace(/0+$/, ""), c = BigInt(o) * n;
      if (!t && a.length > e)
        throw new Error(`fractional part cannot be represented with this precision (num=${r}, prec=${e})`);
      const u = Math.min(a.length, e), l = BigInt(a.slice(0, u)) * 10n ** BigInt(e - u), f = c + l;
      return i ? -f : f;
    }
  };
}
function rk(e) {
  if (!Array.isArray(e))
    throw new Error(`expected array, got ${typeof e}`);
  for (const t of e)
    if (!eu(t))
      throw new Error(`wrong base coder ${t}`);
  return {
    encode: (t) => {
      for (const n of e) {
        const r = n.encode(t);
        if (r !== void 0)
          return r;
      }
      throw new Error(`match/encode: cannot find match in ${t}`);
    },
    decode: (t) => {
      for (const n of e) {
        const r = n.decode(t);
        if (r !== void 0)
          return r;
      }
      throw new Error(`match/decode: cannot find match in ${t}`);
    }
  };
}
const ib = (e) => {
  if (!eu(e))
    throw new Error("BaseCoder expected");
  return { encode: e.decode, decode: e.encode };
}, nu = { dict: J1, numberBigint: tk, tsEnum: ek, decimal: nk, match: rk, reverse: ib }, kd = (e, t = !1, n = !1, r = !0) => {
  if (!On(e))
    throw new Error(`bigint/size: wrong value ${e}`);
  if (typeof t != "boolean")
    throw new Error(`bigint/le: expected boolean, got ${typeof t}`);
  if (typeof n != "boolean")
    throw new Error(`bigint/signed: expected boolean, got ${typeof n}`);
  if (typeof r != "boolean")
    throw new Error(`bigint/sized: expected boolean, got ${typeof r}`);
  const i = BigInt(e), s = 2n ** (8n * i - 1n);
  return he({
    size: r ? e : void 0,
    encodeStream: (o, a) => {
      n && a < 0 && (a = a | s);
      const c = [];
      for (let l = 0; l < e; l++)
        c.push(Number(a & 255n)), a >>= 8n;
      let u = new Uint8Array(c).reverse();
      if (!r) {
        let l = 0;
        for (l = 0; l < u.length && u[l] === 0; l++)
          ;
        u = u.subarray(l);
      }
      o.bytes(t ? u.reverse() : u);
    },
    decodeStream: (o) => {
      const a = o.bytes(r ? e : Math.min(e, o.leftBytes)), c = t ? a : Ql(a);
      let u = 0n;
      for (let l = 0; l < c.length; l++)
        u |= BigInt(c[l]) << 8n * BigInt(l);
      return n && u & s && (u = (u ^ s) - s), u;
    },
    validate: (o) => {
      if (typeof o != "bigint")
        throw new Error(`bigint: invalid value: ${o}`);
      return Q1(o, 8n * i, !!n), o;
    }
  });
}, sb = /* @__PURE__ */ kd(32, !1), xa = /* @__PURE__ */ kd(8, !0), ik = /* @__PURE__ */ kd(8, !0, !0), sk = (e, t) => he({
  size: e,
  encodeStream: (n, r) => n.writeView(e, (i) => t.write(i, r)),
  decodeStream: (n) => n.readView(e, t.read),
  validate: (n) => {
    if (typeof n != "number")
      throw new Error(`viewCoder: expected number, got ${typeof n}`);
    return t.validate && t.validate(n), n;
  }
}), $o = (e, t, n) => {
  const r = e * 8, i = 2 ** (r - 1), s = (c) => {
    if (!On(c))
      throw new Error(`sintView: value is not safe integer: ${c}`);
    if (c < -i || c >= i)
      throw new Error(`sintView: value out of bounds. Expected ${-i} <= ${c} < ${i}`);
  }, o = 2 ** r, a = (c) => {
    if (!On(c))
      throw new Error(`uintView: value is not safe integer: ${c}`);
    if (0 > c || c >= o)
      throw new Error(`uintView: value out of bounds. Expected 0 <= ${c} < ${o}`);
  };
  return sk(e, {
    write: n.write,
    read: n.read,
    validate: t ? s : a
  });
}, ht = /* @__PURE__ */ $o(4, !1, {
  read: (e, t) => e.getUint32(t, !0),
  write: (e, t) => e.setUint32(0, t, !0)
}), ok = /* @__PURE__ */ $o(4, !1, {
  read: (e, t) => e.getUint32(t, !1),
  write: (e, t) => e.setUint32(0, t, !1)
}), Li = /* @__PURE__ */ $o(4, !0, {
  read: (e, t) => e.getInt32(t, !0),
  write: (e, t) => e.setInt32(0, t, !0)
}), Wp = /* @__PURE__ */ $o(2, !1, {
  read: (e, t) => e.getUint16(t, !0),
  write: (e, t) => e.setUint16(0, t, !0)
}), kr = /* @__PURE__ */ $o(1, !1, {
  read: (e, t) => e.getUint8(t),
  write: (e, t) => e.setUint8(0, t)
}), kt = (e, t = !1) => {
  if (typeof t != "boolean")
    throw new Error(`bytes/le: expected boolean, got ${typeof t}`);
  const n = nb(e), r = Ce(e);
  return he({
    size: typeof e == "number" ? e : void 0,
    encodeStream: (i, s) => {
      r || n.encodeStream(i, s.length), i.bytes(t ? Ql(s) : s), r && i.bytes(e);
    },
    decodeStream: (i) => {
      let s;
      if (r) {
        const o = i.find(e);
        if (!o)
          throw i.err("bytes: cannot find terminator");
        s = i.bytes(o - i.pos), i.bytes(e.length);
      } else
        s = i.bytes(e === null ? i.leftBytes : n.decodeStream(i));
      return t ? Ql(s) : s;
    },
    validate: (i) => {
      if (!Ce(i))
        throw new Error(`bytes: invalid value ${i}`);
      return i;
    }
  });
};
function ak(e, t) {
  if (!Qe(t))
    throw new Error(`prefix: invalid inner value ${t}`);
  return Ur(kt(e), ib(t));
}
const Ad = (e, t = !1) => de(Ur(kt(e, t), d1), (n) => {
  if (typeof n != "string")
    throw new Error(`expected string, got ${typeof n}`);
  return n;
}), ck = (e, t = { isLE: !1, with0x: !1 }) => {
  let n = Ur(kt(e, t.isLE), C);
  const r = t.with0x;
  if (typeof r != "boolean")
    throw new Error(`hex/with0x: expected boolean, got ${typeof r}`);
  return r && (n = Ur(n, {
    encode: (i) => `0x${i}`,
    decode: (i) => {
      if (!i.startsWith("0x"))
        throw new Error("hex(with0x=true).encode input should start with 0x");
      return i.slice(2);
    }
  })), n;
};
function Ur(e, t) {
  if (!Qe(e))
    throw new Error(`apply: invalid inner value ${e}`);
  if (!eu(t))
    throw new Error(`apply: invalid base value ${e}`);
  return he({
    size: e.size,
    encodeStream: (n, r) => {
      let i;
      try {
        i = t.decode(r);
      } catch (s) {
        throw n.err("" + s);
      }
      return e.encodeStream(n, i);
    },
    decodeStream: (n) => {
      const r = e.decodeStream(n);
      try {
        return t.encode(r);
      } catch (i) {
        throw n.err("" + i);
      }
    }
  });
}
const uk = (e, t = !1) => {
  if (!Ce(e))
    throw new Error(`flag/flagValue: expected Uint8Array, got ${typeof e}`);
  if (typeof t != "boolean")
    throw new Error(`flag/xor: expected boolean, got ${typeof t}`);
  return he({
    size: e.length,
    encodeStream: (n, r) => {
      !!r !== t && n.bytes(e);
    },
    decodeStream: (n) => {
      let r = n.leftBytes >= e.length;
      return r && (r = os(n.bytes(e.length, !0), e), r && n.bytes(e.length)), r !== t;
    },
    validate: (n) => {
      if (n !== void 0 && typeof n != "boolean")
        throw new Error(`flag: expected boolean value or undefined, got ${typeof n}`);
      return n;
    }
  });
};
function lk(e, t, n) {
  if (!Qe(t))
    throw new Error(`flagged: invalid inner value ${t}`);
  return he({
    encodeStream: (r, i) => {
      qn.resolve(r.stack, e) && t.encodeStream(r, i);
    },
    decodeStream: (r) => {
      let i = !1;
      if (i = !!qn.resolve(r.stack, e), i)
        return t.decodeStream(r);
    }
  });
}
function $d(e, t, n = !0) {
  if (!Qe(e))
    throw new Error(`magic: invalid inner value ${e}`);
  if (typeof n != "boolean")
    throw new Error(`magic: expected boolean, got ${typeof n}`);
  return he({
    size: e.size,
    encodeStream: (r, i) => e.encodeStream(r, t),
    decodeStream: (r) => {
      const i = e.decodeStream(r);
      if (n && typeof i != "object" && i !== t || Ce(t) && !os(t, i))
        throw r.err(`magic: invalid value: ${i} !== ${t}`);
    },
    validate: (r) => {
      if (r !== void 0)
        throw new Error(`magic: wrong value=${typeof r}`);
      return r;
    }
  });
}
function ob(e) {
  let t = 0;
  for (const n of e) {
    if (n.size === void 0)
      return;
    if (!On(n.size))
      throw new Error(`sizeof: wrong element size=${t}`);
    t += n.size;
  }
  return t;
}
function zt(e) {
  if (!Ao(e))
    throw new Error(`struct: expected plain object, got ${e}`);
  for (const t in e)
    if (!Qe(e[t]))
      throw new Error(`struct: field ${t} is not CoderType`);
  return he({
    size: ob(Object.values(e)),
    encodeStream: (t, n) => {
      t.pushObj(n, (r) => {
        for (const i in e)
          r(i, () => e[i].encodeStream(t, n[i]));
      });
    },
    decodeStream: (t) => {
      const n = {};
      return t.pushObj(n, (r) => {
        for (const i in e)
          r(i, () => n[i] = e[i].decodeStream(t));
      }), n;
    },
    validate: (t) => {
      if (typeof t != "object" || t === null)
        throw new Error(`struct: invalid value ${t}`);
      return t;
    }
  });
}
function fk(e) {
  if (!Array.isArray(e))
    throw new Error(`Packed.Tuple: got ${typeof e} instead of array`);
  for (let t = 0; t < e.length; t++)
    if (!Qe(e[t]))
      throw new Error(`tuple: field ${t} is not CoderType`);
  return he({
    size: ob(e),
    encodeStream: (t, n) => {
      if (!Array.isArray(n))
        throw t.err(`tuple: invalid value ${n}`);
      t.pushObj(n, (r) => {
        for (let i = 0; i < e.length; i++)
          r(`${i}`, () => e[i].encodeStream(t, n[i]));
      });
    },
    decodeStream: (t) => {
      const n = [];
      return t.pushObj(n, (r) => {
        for (let i = 0; i < e.length; i++)
          r(`${i}`, () => n.push(e[i].decodeStream(t)));
      }), n;
    },
    validate: (t) => {
      if (!Array.isArray(t))
        throw new Error(`tuple: invalid value ${t}`);
      if (t.length !== e.length)
        throw new Error(`tuple: wrong length=${t.length}, expected ${e.length}`);
      return t;
    }
  });
}
function ue(e, t) {
  if (!Qe(t))
    throw new Error(`array: invalid inner value ${t}`);
  const n = nb(typeof e == "string" ? `../${e}` : e);
  return he({
    size: typeof e == "number" && t.size ? e * t.size : void 0,
    encodeStream: (r, i) => {
      const s = r;
      s.pushObj(i, (o) => {
        Ce(e) || n.encodeStream(r, i.length);
        for (let a = 0; a < i.length; a++)
          o(`${a}`, () => {
            const c = i[a], u = r.pos;
            if (t.encodeStream(r, c), Ce(e)) {
              if (e.length > s.pos - u)
                return;
              const l = s.finish(!1).subarray(u, s.pos);
              if (os(l.subarray(0, e.length), e))
                throw s.err(`array: inner element encoding same as separator. elm=${c} data=${l}`);
            }
          });
      }), Ce(e) && r.bytes(e);
    },
    decodeStream: (r) => {
      const i = [];
      return r.pushObj(i, (s) => {
        if (e === null)
          for (let o = 0; !r.isEnd() && (s(`${o}`, () => i.push(t.decodeStream(r))), !(t.size && r.leftBytes < t.size)); o++)
            ;
        else if (Ce(e))
          for (let o = 0; ; o++) {
            if (os(r.bytes(e.length, !0), e)) {
              r.bytes(e.length);
              break;
            }
            s(`${o}`, () => i.push(t.decodeStream(r)));
          }
        else {
          let o;
          s("arrayLen", () => o = n.decodeStream(r));
          for (let a = 0; a < o; a++)
            s(`${a}`, () => i.push(t.decodeStream(r)));
        }
      }), i;
    },
    validate: (r) => {
      if (!Array.isArray(r))
        throw new Error(`array: invalid value ${r}`);
      return r;
    }
  });
}
const Ts = xr.Point, Kp = Ts.Fn, ab = Ts.Fn.ORDER, Io = (e) => e % 2n === 0n, xt = Sd.isBytes, br = Sd.concatBytes, Nt = Sd.equalBytes, cb = (e) => Jm(Bt(e)), cr = (...e) => Bt(Bt(br(...e))), Jl = Xn.utils.randomSecretKey, Id = Xn.getPublicKey, ub = xr.getPublicKey, jp = (e) => e.r < ab / 2n;
function dk(e, t, n = !1) {
  let r = xr.Signature.fromBytes(xr.sign(e, t, { prehash: !1 }));
  if (n && !jp(r)) {
    const i = new Uint8Array(32);
    let s = 0;
    for (; !jp(r); )
      if (i.set(ht.encode(s++)), r = xr.Signature.fromBytes(xr.sign(e, t, { prehash: !1, extraEntropy: i })), s > 4294967295)
        throw new Error("lowR counter overflow: report the error");
  }
  return r.toBytes("der");
}
const zp = Xn.sign, Od = Xn.utils.taggedHash, we = {
  ecdsa: 0,
  schnorr: 1
};
function as(e, t) {
  const n = e.length;
  if (t === we.ecdsa) {
    if (n === 32)
      throw new Error("Expected non-Schnorr key");
    return Ts.fromBytes(e), e;
  } else if (t === we.schnorr) {
    if (n !== 32)
      throw new Error("Expected 32-byte Schnorr key");
    return Xn.utils.lift_x(Zn(e)), e;
  } else
    throw new Error("Unknown key type");
}
function lb(e, t) {
  const r = Xn.utils.taggedHash("TapTweak", e, t), i = Zn(r);
  if (i >= ab)
    throw new Error("tweak higher than curve order");
  return i;
}
function hk(e, t = Uint8Array.of()) {
  const n = Xn.utils, r = Zn(e), i = Ts.BASE.multiply(r), s = Io(i.y) ? r : Kp.neg(r), o = n.pointToBytes(i), a = lb(o, t);
  return ko(Kp.add(s, a), 32);
}
function tf(e, t) {
  const n = Xn.utils, r = lb(e, t), s = n.lift_x(Zn(e)).add(Ts.BASE.multiply(r)), o = Io(s.y) ? 0 : 1;
  return [n.pointToBytes(s), o];
}
const Bd = Bt(Ts.BASE.toBytes(!1)), cs = {
  bech32: "bc",
  pubKeyHash: 0,
  scriptHash: 5,
  wif: 128
}, jo = {
  bech32: "tb",
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
function lc(e, t) {
  if (!xt(e) || !xt(t))
    throw new Error(`cmp: wrong type a=${typeof e} b=${typeof t}`);
  const n = Math.min(e.length, t.length);
  for (let r = 0; r < n; r++)
    if (e[r] != t[r])
      return Math.sign(e[r] - t[r]);
  return Math.sign(e.length - t.length);
}
function fb(e) {
  const t = {};
  for (const n in e) {
    if (t[e[n]] !== void 0)
      throw new Error("duplicate key");
    t[e[n]] = n;
  }
  return t;
}
const Vt = {
  OP_0: 0,
  PUSHDATA1: 76,
  PUSHDATA2: 77,
  PUSHDATA4: 78,
  "1NEGATE": 79,
  RESERVED: 80,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  // Control
  NOP: 97,
  VER: 98,
  IF: 99,
  NOTIF: 100,
  VERIF: 101,
  VERNOTIF: 102,
  ELSE: 103,
  ENDIF: 104,
  VERIFY: 105,
  RETURN: 106,
  // Stack
  TOALTSTACK: 107,
  FROMALTSTACK: 108,
  "2DROP": 109,
  "2DUP": 110,
  "3DUP": 111,
  "2OVER": 112,
  "2ROT": 113,
  "2SWAP": 114,
  IFDUP: 115,
  DEPTH: 116,
  DROP: 117,
  DUP: 118,
  NIP: 119,
  OVER: 120,
  PICK: 121,
  ROLL: 122,
  ROT: 123,
  SWAP: 124,
  TUCK: 125,
  // Splice
  CAT: 126,
  SUBSTR: 127,
  LEFT: 128,
  RIGHT: 129,
  SIZE: 130,
  // Boolean logic
  INVERT: 131,
  AND: 132,
  OR: 133,
  XOR: 134,
  EQUAL: 135,
  EQUALVERIFY: 136,
  RESERVED1: 137,
  RESERVED2: 138,
  // Numbers
  "1ADD": 139,
  "1SUB": 140,
  "2MUL": 141,
  "2DIV": 142,
  NEGATE: 143,
  ABS: 144,
  NOT: 145,
  "0NOTEQUAL": 146,
  ADD: 147,
  SUB: 148,
  MUL: 149,
  DIV: 150,
  MOD: 151,
  LSHIFT: 152,
  RSHIFT: 153,
  BOOLAND: 154,
  BOOLOR: 155,
  NUMEQUAL: 156,
  NUMEQUALVERIFY: 157,
  NUMNOTEQUAL: 158,
  LESSTHAN: 159,
  GREATERTHAN: 160,
  LESSTHANOREQUAL: 161,
  GREATERTHANOREQUAL: 162,
  MIN: 163,
  MAX: 164,
  WITHIN: 165,
  // Crypto
  RIPEMD160: 166,
  SHA1: 167,
  SHA256: 168,
  HASH160: 169,
  HASH256: 170,
  CODESEPARATOR: 171,
  CHECKSIG: 172,
  CHECKSIGVERIFY: 173,
  CHECKMULTISIG: 174,
  CHECKMULTISIGVERIFY: 175,
  // Expansion
  NOP1: 176,
  CHECKLOCKTIMEVERIFY: 177,
  CHECKSEQUENCEVERIFY: 178,
  NOP4: 179,
  NOP5: 180,
  NOP6: 181,
  NOP7: 182,
  NOP8: 183,
  NOP9: 184,
  NOP10: 185,
  // BIP 342
  CHECKSIGADD: 186,
  // Invalid
  INVALID: 255
}, pk = fb(Vt);
function Cd(e = 6, t = !1) {
  return he({
    encodeStream: (n, r) => {
      if (r === 0n)
        return;
      const i = r < 0, s = BigInt(r), o = [];
      for (let a = i ? -s : s; a; a >>= 8n)
        o.push(Number(a & 0xffn));
      o[o.length - 1] >= 128 ? o.push(i ? 128 : 0) : i && (o[o.length - 1] |= 128), n.bytes(new Uint8Array(o));
    },
    decodeStream: (n) => {
      const r = n.leftBytes;
      if (r > e)
        throw new Error(`ScriptNum: number (${r}) bigger than limit=${e}`);
      if (r === 0)
        return 0n;
      if (t) {
        const o = n.bytes(r, !0);
        if ((o[o.length - 1] & 127) === 0 && (r <= 1 || (o[o.length - 2] & 128) === 0))
          throw new Error("Non-minimally encoded ScriptNum");
      }
      let i = 0, s = 0n;
      for (let o = 0; o < r; ++o)
        i = n.byte(), s |= BigInt(i) << 8n * BigInt(o);
      return i >= 128 && (s &= 2n ** BigInt(r * 8) - 1n >> 1n, s = -s), s;
    }
  });
}
function gk(e, t = 4, n = !0) {
  if (typeof e == "number")
    return e;
  if (xt(e))
    try {
      const r = Cd(t, n).decode(e);
      return r > Number.MAX_SAFE_INTEGER ? void 0 : Number(r);
    } catch {
      return;
    }
}
const et = he({
  encodeStream: (e, t) => {
    for (let n of t) {
      if (typeof n == "string") {
        if (Vt[n] === void 0)
          throw new Error(`Unknown opcode=${n}`);
        e.byte(Vt[n]);
        continue;
      } else if (typeof n == "number") {
        if (n === 0) {
          e.byte(0);
          continue;
        } else if (1 <= n && n <= 16) {
          e.byte(Vt.OP_1 - 1 + n);
          continue;
        }
      }
      if (typeof n == "number" && (n = Cd().encode(BigInt(n))), !xt(n))
        throw new Error(`Wrong Script OP=${n} (${typeof n})`);
      const r = n.length;
      r < Vt.PUSHDATA1 ? e.byte(r) : r <= 255 ? (e.byte(Vt.PUSHDATA1), e.byte(r)) : r <= 65535 ? (e.byte(Vt.PUSHDATA2), e.bytes(Wp.encode(r))) : (e.byte(Vt.PUSHDATA4), e.bytes(ht.encode(r))), e.bytes(n);
    }
  },
  decodeStream: (e) => {
    const t = [];
    for (; !e.isEnd(); ) {
      const n = e.byte();
      if (Vt.OP_0 < n && n <= Vt.PUSHDATA4) {
        let r;
        if (n < Vt.PUSHDATA1)
          r = n;
        else if (n === Vt.PUSHDATA1)
          r = kr.decodeStream(e);
        else if (n === Vt.PUSHDATA2)
          r = Wp.decodeStream(e);
        else if (n === Vt.PUSHDATA4)
          r = ht.decodeStream(e);
        else
          throw new Error("Should be not possible");
        t.push(e.bytes(r));
      } else if (n === 0)
        t.push(0);
      else if (Vt.OP_1 <= n && n <= Vt.OP_16)
        t.push(n - (Vt.OP_1 - 1));
      else {
        const r = pk[n];
        if (r === void 0)
          throw new Error(`Unknown opcode=${n.toString(16)}`);
        t.push(r);
      }
    }
    return t;
  }
}), qp = {
  253: [253, 2, 253n, 65535n],
  254: [254, 4, 65536n, 4294967295n],
  255: [255, 8, 4294967296n, 18446744073709551615n]
}, ru = he({
  encodeStream: (e, t) => {
    if (typeof t == "number" && (t = BigInt(t)), 0n <= t && t <= 252n)
      return e.byte(Number(t));
    for (const [n, r, i, s] of Object.values(qp))
      if (!(i > t || t > s)) {
        e.byte(n);
        for (let o = 0; o < r; o++)
          e.byte(Number(t >> 8n * BigInt(o) & 0xffn));
        return;
      }
    throw e.err(`VarInt too big: ${t}`);
  },
  decodeStream: (e) => {
    const t = e.byte();
    if (t <= 252)
      return BigInt(t);
    const [n, r, i] = qp[t];
    let s = 0n;
    for (let o = 0; o < r; o++)
      s |= BigInt(e.byte()) << 8n * BigInt(o);
    if (s < i)
      throw e.err(`Wrong CompactSize(${8 * r})`);
    return s;
  }
}), Je = Ur(ru, nu.numberBigint), je = kt(ru), po = ue(Je, je), fc = (e) => ue(ru, e), db = zt({
  txid: kt(32, !0),
  // hash(prev_tx),
  index: ht,
  // output number of previous tx
  finalScriptSig: je,
  // btc merges input and output script, executes it. If ok = tx passes
  sequence: ht
  // ?
}), ai = zt({ amount: xa, script: je }), yk = zt({
  version: Li,
  segwitFlag: uk(new Uint8Array([0, 1])),
  inputs: fc(db),
  outputs: fc(ai),
  witnesses: lk("segwitFlag", ue("inputs/length", po)),
  // < 500000000	Block number at which this transaction is unlocked
  // >= 500000000	UNIX timestamp at which this transaction is unlocked
  // Handled as part of PSBTv2
  lockTime: ht
});
function wk(e) {
  if (e.segwitFlag && e.witnesses && !e.witnesses.length)
    throw new Error("Segwit flag with empty witnesses array");
  return e;
}
const Wi = de(yk, wk), Ms = zt({
  version: Li,
  inputs: fc(db),
  outputs: fc(ai),
  lockTime: ht
}), ef = de(kt(null), (e) => as(e, we.ecdsa)), dc = de(kt(32), (e) => as(e, we.schnorr)), Gp = de(kt(null), (e) => {
  if (e.length !== 64 && e.length !== 65)
    throw new Error("Schnorr signature should be 64 or 65 bytes long");
  return e;
}), iu = zt({
  fingerprint: ok,
  path: ue(null, ht)
}), hb = zt({
  hashes: ue(Je, kt(32)),
  der: iu
}), mk = kt(78), bk = zt({ pubKey: dc, leafHash: kt(32) }), Ek = zt({
  version: kr,
  // With parity :(
  internalKey: kt(32),
  merklePath: ue(null, kt(32))
}), Tn = de(Ek, (e) => {
  if (e.merklePath.length > 128)
    throw new Error("TaprootControlBlock: merklePath should be of length 0..128 (inclusive)");
  return e;
}), xk = ue(null, zt({
  depth: kr,
  version: kr,
  script: je
})), Rt = kt(null), Yp = kt(20), Rs = kt(32), Rd = {
  unsignedTx: [0, !1, Ms, [0], [0], !1],
  xpub: [1, mk, iu, [], [0, 2], !1],
  txVersion: [2, !1, ht, [2], [2], !1],
  fallbackLocktime: [3, !1, ht, [], [2], !1],
  inputCount: [4, !1, Je, [2], [2], !1],
  outputCount: [5, !1, Je, [2], [2], !1],
  txModifiable: [6, !1, kr, [], [2], !1],
  // TODO: bitfield
  version: [251, !1, ht, [], [0, 2], !1],
  proprietary: [252, Rt, Rt, [], [0, 2], !1]
}, su = {
  nonWitnessUtxo: [0, !1, Wi, [], [0, 2], !1],
  witnessUtxo: [1, !1, ai, [], [0, 2], !1],
  partialSig: [2, ef, Rt, [], [0, 2], !1],
  sighashType: [3, !1, ht, [], [0, 2], !1],
  redeemScript: [4, !1, Rt, [], [0, 2], !1],
  witnessScript: [5, !1, Rt, [], [0, 2], !1],
  bip32Derivation: [6, ef, iu, [], [0, 2], !1],
  finalScriptSig: [7, !1, Rt, [], [0, 2], !1],
  finalScriptWitness: [8, !1, po, [], [0, 2], !1],
  porCommitment: [9, !1, Rt, [], [0, 2], !1],
  ripemd160: [10, Yp, Rt, [], [0, 2], !1],
  sha256: [11, Rs, Rt, [], [0, 2], !1],
  hash160: [12, Yp, Rt, [], [0, 2], !1],
  hash256: [13, Rs, Rt, [], [0, 2], !1],
  txid: [14, !1, Rs, [2], [2], !0],
  index: [15, !1, ht, [2], [2], !0],
  sequence: [16, !1, ht, [], [2], !0],
  requiredTimeLocktime: [17, !1, ht, [], [2], !1],
  requiredHeightLocktime: [18, !1, ht, [], [2], !1],
  tapKeySig: [19, !1, Gp, [], [0, 2], !1],
  tapScriptSig: [20, bk, Gp, [], [0, 2], !1],
  tapLeafScript: [21, Tn, Rt, [], [0, 2], !1],
  tapBip32Derivation: [22, Rs, hb, [], [0, 2], !1],
  tapInternalKey: [23, !1, dc, [], [0, 2], !1],
  tapMerkleRoot: [24, !1, Rs, [], [0, 2], !1],
  proprietary: [252, Rt, Rt, [], [0, 2], !1]
}, Tk = [
  "txid",
  "sequence",
  "index",
  "witnessUtxo",
  "nonWitnessUtxo",
  "finalScriptSig",
  "finalScriptWitness",
  "unknown"
], Sk = [
  "partialSig",
  "finalScriptSig",
  "finalScriptWitness",
  "tapKeySig",
  "tapScriptSig"
], go = {
  redeemScript: [0, !1, Rt, [], [0, 2], !1],
  witnessScript: [1, !1, Rt, [], [0, 2], !1],
  bip32Derivation: [2, ef, iu, [], [0, 2], !1],
  amount: [3, !1, ik, [2], [2], !0],
  script: [4, !1, Rt, [2], [2], !0],
  tapInternalKey: [5, !1, dc, [], [0, 2], !1],
  tapTree: [6, !1, xk, [], [0, 2], !1],
  tapBip32Derivation: [7, dc, hb, [], [0, 2], !1],
  proprietary: [252, Rt, Rt, [], [0, 2], !1]
}, vk = [], Zp = ue(tb, zt({
  //  <key> := <keylen> <keytype> <keydata> WHERE keylen = len(keytype)+len(keydata)
  key: ak(Je, zt({ type: Je, key: kt(null) })),
  //  <value> := <valuelen> <valuedata>
  value: kt(Je)
}));
function nf(e) {
  const [t, n, r, i, s, o] = e;
  return { type: t, kc: n, vc: r, reqInc: i, allowInc: s, silentIgnore: o };
}
zt({ type: Je, key: kt(null) });
function Pd(e) {
  const t = {};
  for (const n in e) {
    const [r, i, s] = e[n];
    t[r] = [n, i, s];
  }
  return he({
    encodeStream: (n, r) => {
      let i = [];
      for (const s in e) {
        const o = r[s];
        if (o === void 0)
          continue;
        const [a, c, u] = e[s];
        if (!c)
          i.push({ key: { type: a, key: $t }, value: u.encode(o) });
        else {
          const l = o.map(([f, h]) => [
            c.encode(f),
            u.encode(h)
          ]);
          l.sort((f, h) => lc(f[0], h[0]));
          for (const [f, h] of l)
            i.push({ key: { key: f, type: a }, value: h });
        }
      }
      if (r.unknown) {
        r.unknown.sort((s, o) => lc(s[0].key, o[0].key));
        for (const [s, o] of r.unknown)
          i.push({ key: s, value: o });
      }
      Zp.encodeStream(n, i);
    },
    decodeStream: (n) => {
      const r = Zp.decodeStream(n), i = {}, s = {};
      for (const o of r) {
        let a = "unknown", c = o.key.key, u = o.value;
        if (t[o.key.type]) {
          const [l, f, h] = t[o.key.type];
          if (a = l, !f && c.length)
            throw new Error(`PSBT: Non-empty key for ${a} (key=${C.encode(c)} value=${C.encode(u)}`);
          if (c = f ? f.decode(c) : void 0, u = h.decode(u), !f) {
            if (i[a])
              throw new Error(`PSBT: Same keys: ${a} (key=${c} value=${u})`);
            i[a] = u, s[a] = !0;
            continue;
          }
        } else
          c = { type: o.key.type, key: o.key.key };
        if (s[a])
          throw new Error(`PSBT: Key type with empty key and no key=${a} val=${u}`);
        i[a] || (i[a] = []), i[a].push([c, u]);
      }
      return i;
    }
  });
}
const Nd = de(Pd(su), (e) => {
  if (e.finalScriptWitness && !e.finalScriptWitness.length)
    throw new Error("validateInput: empty finalScriptWitness");
  if (e.partialSig && !e.partialSig.length)
    throw new Error("Empty partialSig");
  if (e.partialSig)
    for (const [t] of e.partialSig)
      as(t, we.ecdsa);
  if (e.bip32Derivation)
    for (const [t] of e.bip32Derivation)
      as(t, we.ecdsa);
  if (e.requiredTimeLocktime !== void 0 && e.requiredTimeLocktime < 5e8)
    throw new Error(`validateInput: wrong timeLocktime=${e.requiredTimeLocktime}`);
  if (e.requiredHeightLocktime !== void 0 && (e.requiredHeightLocktime <= 0 || e.requiredHeightLocktime >= 5e8))
    throw new Error(`validateInput: wrong heighLocktime=${e.requiredHeightLocktime}`);
  if (e.tapLeafScript)
    for (const [t, n] of e.tapLeafScript) {
      if ((t.version & 254) !== n[n.length - 1])
        throw new Error("validateInput: tapLeafScript version mimatch");
      if (n[n.length - 1] & 1)
        throw new Error("validateInput: tapLeafScript version has parity bit!");
    }
  return e;
}), Ld = de(Pd(go), (e) => {
  if (e.bip32Derivation)
    for (const [t] of e.bip32Derivation)
      as(t, we.ecdsa);
  return e;
}), pb = de(Pd(Rd), (e) => {
  if ((e.version || 0) === 0) {
    if (!e.unsignedTx)
      throw new Error("PSBTv0: missing unsignedTx");
    for (const n of e.unsignedTx.inputs)
      if (n.finalScriptSig && n.finalScriptSig.length)
        throw new Error("PSBTv0: input scriptSig found in unsignedTx");
  }
  return e;
}), kk = zt({
  magic: $d(Ad(new Uint8Array([255])), "psbt"),
  global: pb,
  inputs: ue("global/unsignedTx/inputs/length", Nd),
  outputs: ue(null, Ld)
}), Ak = zt({
  magic: $d(Ad(new Uint8Array([255])), "psbt"),
  global: pb,
  inputs: ue("global/inputCount", Nd),
  outputs: ue("global/outputCount", Ld)
});
zt({
  magic: $d(Ad(new Uint8Array([255])), "psbt"),
  items: ue(null, Ur(ue(tb, fk([ck(Je), kt(ru)])), nu.dict()))
});
function qu(e, t, n) {
  for (const r in n) {
    if (r === "unknown" || !t[r])
      continue;
    const { allowInc: i } = nf(t[r]);
    if (!i.includes(e))
      throw new Error(`PSBTv${e}: field ${r} is not allowed`);
  }
  for (const r in t) {
    const { reqInc: i } = nf(t[r]);
    if (i.includes(e) && n[r] === void 0)
      throw new Error(`PSBTv${e}: missing required field ${r}`);
  }
}
function Xp(e, t, n) {
  const r = {};
  for (const i in n) {
    const s = i;
    if (s !== "unknown") {
      if (!t[s])
        continue;
      const { allowInc: o, silentIgnore: a } = nf(t[s]);
      if (!o.includes(e)) {
        if (a)
          continue;
        throw new Error(`Failed to serialize in PSBTv${e}: ${s} but versions allows inclusion=${o}`);
      }
    }
    r[s] = n[s];
  }
  return r;
}
function gb(e) {
  const t = e && e.global && e.global.version || 0;
  qu(t, Rd, e.global);
  for (const o of e.inputs)
    qu(t, su, o);
  for (const o of e.outputs)
    qu(t, go, o);
  const n = t ? e.global.inputCount : e.global.unsignedTx.inputs.length;
  if (e.inputs.length < n)
    throw new Error("Not enough inputs");
  const r = e.inputs.slice(n);
  if (r.length > 1 || r.length && Object.keys(r[0]).length)
    throw new Error(`Unexpected inputs left in tx=${r}`);
  const i = t ? e.global.outputCount : e.global.unsignedTx.outputs.length;
  if (e.outputs.length < i)
    throw new Error("Not outputs inputs");
  const s = e.outputs.slice(i);
  if (s.length > 1 || s.length && Object.keys(s[0]).length)
    throw new Error(`Unexpected outputs left in tx=${s}`);
  return e;
}
function rf(e, t, n, r, i) {
  const s = { ...n, ...t };
  for (const o in e) {
    const a = o, [c, u, l] = e[a], f = r && !r.includes(o);
    if (t[o] === void 0 && o in t) {
      if (f)
        throw new Error(`Cannot remove signed field=${o}`);
      delete s[o];
    } else if (u) {
      const h = n && n[o] ? n[o] : [];
      let g = t[a];
      if (g) {
        if (!Array.isArray(g))
          throw new Error(`keyMap(${o}): KV pairs should be [k, v][]`);
        g = g.map((y) => {
          if (y.length !== 2)
            throw new Error(`keyMap(${o}): KV pairs should be [k, v][]`);
          return [
            typeof y[0] == "string" ? u.decode(C.decode(y[0])) : y[0],
            typeof y[1] == "string" ? l.decode(C.decode(y[1])) : y[1]
          ];
        });
        const d = {}, p = (y, x, S) => {
          if (d[y] === void 0) {
            d[y] = [x, S];
            return;
          }
          const A = C.encode(l.encode(d[y][1])), R = C.encode(l.encode(S));
          if (A !== R)
            throw new Error(`keyMap(${a}): same key=${y} oldVal=${A} newVal=${R}`);
        };
        for (const [y, x] of h) {
          const S = C.encode(u.encode(y));
          p(S, y, x);
        }
        for (const [y, x] of g) {
          const S = C.encode(u.encode(y));
          if (x === void 0) {
            if (f)
              throw new Error(`Cannot remove signed field=${a}/${y}`);
            delete d[S];
          } else
            p(S, y, x);
        }
        s[a] = Object.values(d);
      }
    } else if (typeof s[o] == "string")
      s[o] = l.decode(C.decode(s[o]));
    else if (f && o in t && n && n[o] !== void 0 && !Nt(l.encode(t[o]), l.encode(n[o])))
      throw new Error(`Cannot change signed field=${o}`);
  }
  for (const o in s)
    if (!e[o]) {
      if (i && o === "unknown")
        continue;
      delete s[o];
    }
  return s;
}
const Qp = de(kk, gb), Jp = de(Ak, gb), $k = {
  encode(e) {
    if (!(e.length !== 2 || e[0] !== 1 || !xt(e[1]) || C.encode(e[1]) !== "4e73"))
      return { type: "p2a", script: et.encode(e) };
  },
  decode: (e) => {
    if (e.type === "p2a")
      return [1, C.decode("4e73")];
  }
};
function Ui(e, t) {
  try {
    return as(e, t), !0;
  } catch {
    return !1;
  }
}
const Ik = {
  encode(e) {
    if (!(e.length !== 2 || !xt(e[0]) || !Ui(e[0], we.ecdsa) || e[1] !== "CHECKSIG"))
      return { type: "pk", pubkey: e[0] };
  },
  decode: (e) => e.type === "pk" ? [e.pubkey, "CHECKSIG"] : void 0
}, Ok = {
  encode(e) {
    if (!(e.length !== 5 || e[0] !== "DUP" || e[1] !== "HASH160" || !xt(e[2])) && !(e[3] !== "EQUALVERIFY" || e[4] !== "CHECKSIG"))
      return { type: "pkh", hash: e[2] };
  },
  decode: (e) => e.type === "pkh" ? ["DUP", "HASH160", e.hash, "EQUALVERIFY", "CHECKSIG"] : void 0
}, Bk = {
  encode(e) {
    if (!(e.length !== 3 || e[0] !== "HASH160" || !xt(e[1]) || e[2] !== "EQUAL"))
      return { type: "sh", hash: e[1] };
  },
  decode: (e) => e.type === "sh" ? ["HASH160", e.hash, "EQUAL"] : void 0
}, Ck = {
  encode(e) {
    if (!(e.length !== 2 || e[0] !== 0 || !xt(e[1])) && e[1].length === 32)
      return { type: "wsh", hash: e[1] };
  },
  decode: (e) => e.type === "wsh" ? [0, e.hash] : void 0
}, Rk = {
  encode(e) {
    if (!(e.length !== 2 || e[0] !== 0 || !xt(e[1])) && e[1].length === 20)
      return { type: "wpkh", hash: e[1] };
  },
  decode: (e) => e.type === "wpkh" ? [0, e.hash] : void 0
}, Pk = {
  encode(e) {
    const t = e.length - 1;
    if (e[t] !== "CHECKMULTISIG")
      return;
    const n = e[0], r = e[t - 1];
    if (typeof n != "number" || typeof r != "number")
      return;
    const i = e.slice(1, -2);
    if (r === i.length) {
      for (const s of i)
        if (!xt(s))
          return;
      return { type: "ms", m: n, pubkeys: i };
    }
  },
  // checkmultisig(n, ..pubkeys, m)
  decode: (e) => e.type === "ms" ? [e.m, ...e.pubkeys, e.pubkeys.length, "CHECKMULTISIG"] : void 0
}, Nk = {
  encode(e) {
    if (!(e.length !== 2 || e[0] !== 1 || !xt(e[1])))
      return { type: "tr", pubkey: e[1] };
  },
  decode: (e) => e.type === "tr" ? [1, e.pubkey] : void 0
}, Lk = {
  encode(e) {
    const t = e.length - 1;
    if (e[t] !== "CHECKSIG")
      return;
    const n = [];
    for (let r = 0; r < t; r++) {
      const i = e[r];
      if (r & 1) {
        if (i !== "CHECKSIGVERIFY" || r === t - 1)
          return;
        continue;
      }
      if (!xt(i))
        return;
      n.push(i);
    }
    return { type: "tr_ns", pubkeys: n };
  },
  decode: (e) => {
    if (e.type !== "tr_ns")
      return;
    const t = [];
    for (let n = 0; n < e.pubkeys.length - 1; n++)
      t.push(e.pubkeys[n], "CHECKSIGVERIFY");
    return t.push(e.pubkeys[e.pubkeys.length - 1], "CHECKSIG"), t;
  }
}, Uk = {
  encode(e) {
    const t = e.length - 1;
    if (e[t] !== "NUMEQUAL" || e[1] !== "CHECKSIG")
      return;
    const n = [], r = gk(e[t - 1]);
    if (typeof r == "number") {
      for (let i = 0; i < t - 1; i++) {
        const s = e[i];
        if (i & 1) {
          if (s !== (i === 1 ? "CHECKSIG" : "CHECKSIGADD"))
            throw new Error("OutScript.encode/tr_ms: wrong element");
          continue;
        }
        if (!xt(s))
          throw new Error("OutScript.encode/tr_ms: wrong key element");
        n.push(s);
      }
      return { type: "tr_ms", pubkeys: n, m: r };
    }
  },
  decode: (e) => {
    if (e.type !== "tr_ms")
      return;
    const t = [e.pubkeys[0], "CHECKSIG"];
    for (let n = 1; n < e.pubkeys.length; n++)
      t.push(e.pubkeys[n], "CHECKSIGADD");
    return t.push(e.m, "NUMEQUAL"), t;
  }
}, _k = {
  encode(e) {
    return { type: "unknown", script: et.encode(e) };
  },
  decode: (e) => e.type === "unknown" ? et.decode(e.script) : void 0
}, Dk = [
  $k,
  Ik,
  Ok,
  Bk,
  Ck,
  Rk,
  Pk,
  Nk,
  Lk,
  Uk,
  _k
], Vk = Ur(et, nu.match(Dk)), It = de(Vk, (e) => {
  if (e.type === "pk" && !Ui(e.pubkey, we.ecdsa))
    throw new Error("OutScript/pk: wrong key");
  if ((e.type === "pkh" || e.type === "sh" || e.type === "wpkh") && (!xt(e.hash) || e.hash.length !== 20))
    throw new Error(`OutScript/${e.type}: wrong hash`);
  if (e.type === "wsh" && (!xt(e.hash) || e.hash.length !== 32))
    throw new Error("OutScript/wsh: wrong hash");
  if (e.type === "tr" && (!xt(e.pubkey) || !Ui(e.pubkey, we.schnorr)))
    throw new Error("OutScript/tr: wrong taproot public key");
  if ((e.type === "ms" || e.type === "tr_ns" || e.type === "tr_ms") && !Array.isArray(e.pubkeys))
    throw new Error("OutScript/multisig: wrong pubkeys array");
  if (e.type === "ms") {
    const t = e.pubkeys.length;
    for (const n of e.pubkeys)
      if (!Ui(n, we.ecdsa))
        throw new Error("OutScript/multisig: wrong pubkey");
    if (e.m <= 0 || t > 16 || e.m > t)
      throw new Error("OutScript/multisig: invalid params");
  }
  if (e.type === "tr_ns" || e.type === "tr_ms") {
    for (const t of e.pubkeys)
      if (!Ui(t, we.schnorr))
        throw new Error(`OutScript/${e.type}: wrong pubkey`);
  }
  if (e.type === "tr_ms") {
    const t = e.pubkeys.length;
    if (e.m <= 0 || t > 999 || e.m > t)
      throw new Error("OutScript/tr_ms: invalid params");
  }
  return e;
});
function tg(e, t) {
  if (!Nt(e.hash, Bt(t)))
    throw new Error("checkScript: wsh wrong witnessScript hash");
  const n = It.decode(t);
  if (n.type === "tr" || n.type === "tr_ns" || n.type === "tr_ms")
    throw new Error(`checkScript: P2${n.type} cannot be wrapped in P2SH`);
  if (n.type === "wpkh" || n.type === "sh")
    throw new Error(`checkScript: P2${n.type} cannot be wrapped in P2WSH`);
}
function yb(e, t, n) {
  if (e) {
    const r = It.decode(e);
    if (r.type === "tr_ns" || r.type === "tr_ms" || r.type === "ms" || r.type == "pk")
      throw new Error(`checkScript: non-wrapped ${r.type}`);
    if (r.type === "sh" && t) {
      if (!Nt(r.hash, cb(t)))
        throw new Error("checkScript: sh wrong redeemScript hash");
      const i = It.decode(t);
      if (i.type === "tr" || i.type === "tr_ns" || i.type === "tr_ms")
        throw new Error(`checkScript: P2${i.type} cannot be wrapped in P2SH`);
      if (i.type === "sh")
        throw new Error("checkScript: P2SH cannot be wrapped in P2SH");
    }
    r.type === "wsh" && n && tg(r, n);
  }
  if (t) {
    const r = It.decode(t);
    r.type === "wsh" && n && tg(r, n);
  }
}
function Mk(e) {
  const t = {};
  for (const n of e) {
    const r = C.encode(n);
    if (t[r])
      throw new Error(`Multisig: non-uniq pubkey: ${e.map(C.encode)}`);
    t[r] = !0;
  }
}
function Fk(e, t, n = !1, r) {
  const i = It.decode(e);
  if (i.type === "unknown" && n)
    return;
  if (!["tr_ns", "tr_ms"].includes(i.type))
    throw new Error(`P2TR: invalid leaf script=${i.type}`);
  const s = i;
  if (!n && s.pubkeys)
    for (const o of s.pubkeys) {
      if (Nt(o, Bd))
        throw new Error("Unspendable taproot key in leaf script");
      if (Nt(o, t))
        throw new Error("Using P2TR with leaf script with same key as internal key is not supported");
    }
}
function wb(e) {
  const t = Array.from(e);
  for (; t.length >= 2; ) {
    t.sort((o, a) => (a.weight || 1) - (o.weight || 1));
    const r = t.pop(), i = t.pop(), s = (i?.weight || 1) + (r?.weight || 1);
    t.push({
      weight: s,
      // Unwrap children array
      // TODO: Very hard to remove any here
      childs: [i?.childs || i, r?.childs || r]
    });
  }
  const n = t[0];
  return n?.childs || n;
}
function sf(e, t = []) {
  if (!e)
    throw new Error("taprootAddPath: empty tree");
  if (e.type === "leaf")
    return { ...e, path: t };
  if (e.type !== "branch")
    throw new Error(`taprootAddPath: wrong type=${e}`);
  return {
    ...e,
    path: t,
    // Left element has right hash in path and otherwise
    left: sf(e.left, [e.right.hash, ...t]),
    right: sf(e.right, [e.left.hash, ...t])
  };
}
function of(e) {
  if (!e)
    throw new Error("taprootAddPath: empty tree");
  if (e.type === "leaf")
    return [e];
  if (e.type !== "branch")
    throw new Error(`taprootWalkTree: wrong type=${e}`);
  return [...of(e.left), ...of(e.right)];
}
function af(e, t, n = !1, r) {
  if (!e)
    throw new Error("taprootHashTree: empty tree");
  if (Array.isArray(e) && e.length === 1 && (e = e[0]), !Array.isArray(e)) {
    const { leafVersion: c, script: u } = e;
    if (e.tapLeafScript || e.tapMerkleRoot && !Nt(e.tapMerkleRoot, $t))
      throw new Error("P2TR: tapRoot leafScript cannot have tree");
    const l = typeof u == "string" ? C.decode(u) : u;
    if (!xt(l))
      throw new Error(`checkScript: wrong script type=${l}`);
    return Fk(l, t, n), {
      type: "leaf",
      version: c,
      script: l,
      hash: Ki(l, c)
    };
  }
  if (e.length !== 2 && (e = wb(e)), e.length !== 2)
    throw new Error("hashTree: non binary tree!");
  const i = af(e[0], t, n), s = af(e[1], t, n);
  let [o, a] = [i.hash, s.hash];
  return lc(a, o) === -1 && ([o, a] = [a, o]), { type: "branch", left: i, right: s, hash: Od("TapBranch", o, a) };
}
const yo = 192, Ki = (e, t = yo) => Od("TapLeaf", new Uint8Array([t]), je.encode(e));
function Hk(e, t, n = cs, r = !1, i) {
  if (!e && !t)
    throw new Error("p2tr: should have pubKey or scriptTree (or both)");
  const s = typeof e == "string" ? C.decode(e) : e || Bd;
  if (!Ui(s, we.schnorr))
    throw new Error("p2tr: non-schnorr pubkey");
  if (t) {
    let o = sf(af(t, s, r));
    const a = o.hash, [c, u] = tf(s, a), l = of(o).map((f) => ({
      ...f,
      controlBlock: Tn.encode({
        version: (f.version || yo) + u,
        internalKey: s,
        merklePath: f.path
      })
    }));
    return {
      type: "tr",
      script: It.encode({ type: "tr", pubkey: c }),
      address: Gn(n).encode({ type: "tr", pubkey: c }),
      // For tests
      tweakedPubkey: c,
      // PSBT stuff
      tapInternalKey: s,
      leaves: l,
      tapLeafScript: l.map((f) => [
        Tn.decode(f.controlBlock),
        br(f.script, new Uint8Array([f.version || yo]))
      ]),
      tapMerkleRoot: a
    };
  } else {
    const o = tf(s, $t)[0];
    return {
      type: "tr",
      script: It.encode({ type: "tr", pubkey: o }),
      address: Gn(n).encode({ type: "tr", pubkey: o }),
      // For tests
      tweakedPubkey: o,
      // PSBT stuff
      tapInternalKey: s
    };
  }
}
function Wk(e, t, n = !1) {
  return n || Mk(t), {
    type: "tr_ms",
    script: It.encode({ type: "tr_ms", pubkeys: t, m: e })
  };
}
const mb = f1(Bt);
function bb(e, t) {
  if (t.length < 2 || t.length > 40)
    throw new Error("Witness: invalid length");
  if (e > 16)
    throw new Error("Witness: invalid version");
  if (e === 0 && !(t.length === 20 || t.length === 32))
    throw new Error("Witness: invalid length for version");
}
function Gu(e, t, n = cs) {
  bb(e, t);
  const r = e === 0 ? ql : Ni;
  return r.encode(n.bech32, [e].concat(r.toWords(t)));
}
function eg(e, t) {
  return mb.encode(br(Uint8Array.from(t), e));
}
function Gn(e = cs) {
  return {
    encode(t) {
      const { type: n } = t;
      if (n === "wpkh")
        return Gu(0, t.hash, e);
      if (n === "wsh")
        return Gu(0, t.hash, e);
      if (n === "tr")
        return Gu(1, t.pubkey, e);
      if (n === "pkh")
        return eg(t.hash, [e.pubKeyHash]);
      if (n === "sh")
        return eg(t.hash, [e.scriptHash]);
      throw new Error(`Unknown address type=${n}`);
    },
    decode(t) {
      if (t.length < 14 || t.length > 74)
        throw new Error("Invalid address length");
      if (e.bech32 && t.toLowerCase().startsWith(`${e.bech32}1`)) {
        let r;
        try {
          if (r = ql.decode(t), r.words[0] !== 0)
            throw new Error(`bech32: wrong version=${r.words[0]}`);
        } catch {
          if (r = Ni.decode(t), r.words[0] === 0)
            throw new Error(`bech32m: wrong version=${r.words[0]}`);
        }
        if (r.prefix !== e.bech32)
          throw new Error(`wrong bech32 prefix=${r.prefix}`);
        const [i, ...s] = r.words, o = ql.fromWords(s);
        if (bb(i, o), i === 0 && o.length === 32)
          return { type: "wsh", hash: o };
        if (i === 0 && o.length === 20)
          return { type: "wpkh", hash: o };
        if (i === 1 && o.length === 32)
          return { type: "tr", pubkey: o };
        throw new Error("Unknown witness program");
      }
      const n = mb.decode(t);
      if (n.length !== 21)
        throw new Error("Invalid base58 address");
      if (n[0] === e.pubKeyHash)
        return { type: "pkh", hash: n.slice(1) };
      if (n[0] === e.scriptHash)
        return {
          type: "sh",
          hash: n.slice(1)
        };
      throw new Error(`Invalid address prefix=${n[0]}`);
    }
  };
}
const zo = new Uint8Array(32), Kk = {
  amount: 0xffffffffffffffffn,
  script: $t
}, jk = (e) => Math.ceil(e / 4), zk = 8, qk = 2, Yr = 0, Ud = 4294967295;
nu.decimal(zk);
const Zs = (e, t) => e === void 0 ? t : e;
function hc(e) {
  if (Array.isArray(e))
    return e.map((t) => hc(t));
  if (xt(e))
    return Uint8Array.from(e);
  if (["number", "bigint", "boolean", "string", "undefined"].includes(typeof e))
    return e;
  if (e === null)
    return e;
  if (typeof e == "object")
    return Object.fromEntries(Object.entries(e).map(([t, n]) => [t, hc(n)]));
  throw new Error(`cloneDeep: unknown type=${e} (${typeof e})`);
}
const ct = {
  DEFAULT: 0,
  ALL: 1,
  NONE: 2,
  SINGLE: 3,
  ANYONECANPAY: 128
}, _r = {
  DEFAULT: ct.DEFAULT,
  ALL: ct.ALL,
  NONE: ct.NONE,
  SINGLE: ct.SINGLE,
  DEFAULT_ANYONECANPAY: ct.DEFAULT | ct.ANYONECANPAY,
  ALL_ANYONECANPAY: ct.ALL | ct.ANYONECANPAY,
  NONE_ANYONECANPAY: ct.NONE | ct.ANYONECANPAY,
  SINGLE_ANYONECANPAY: ct.SINGLE | ct.ANYONECANPAY
}, Gk = fb(_r);
function Yk(e, t, n, r = $t) {
  return Nt(n, t) && (e = hk(e, r), t = Id(e)), { privKey: e, pubKey: t };
}
function Zr(e) {
  if (e.script === void 0 || e.amount === void 0)
    throw new Error("Transaction/output: script and amount required");
  return { script: e.script, amount: e.amount };
}
function Ps(e) {
  if (e.txid === void 0 || e.index === void 0)
    throw new Error("Transaction/input: txid and index required");
  return {
    txid: e.txid,
    index: e.index,
    sequence: Zs(e.sequence, Ud),
    finalScriptSig: Zs(e.finalScriptSig, $t)
  };
}
function Yu(e) {
  for (const t in e) {
    const n = t;
    Tk.includes(n) || delete e[n];
  }
}
const Zu = zt({ txid: kt(32, !0), index: ht });
function Zk(e) {
  if (typeof e != "number" || typeof Gk[e] != "string")
    throw new Error(`Invalid SigHash=${e}`);
  return e;
}
function ng(e) {
  const t = e & 31;
  return {
    isAny: !!(e & ct.ANYONECANPAY),
    isNone: t === ct.NONE,
    isSingle: t === ct.SINGLE
  };
}
function Xk(e) {
  if (e !== void 0 && {}.toString.call(e) !== "[object Object]")
    throw new Error(`Wrong object type for transaction options: ${e}`);
  const t = {
    ...e,
    // Defaults
    version: Zs(e.version, qk),
    lockTime: Zs(e.lockTime, 0),
    PSBTVersion: Zs(e.PSBTVersion, 0)
  };
  if (typeof t.allowUnknowInput < "u" && (e.allowUnknownInputs = t.allowUnknowInput), typeof t.allowUnknowOutput < "u" && (e.allowUnknownOutputs = t.allowUnknowOutput), typeof t.lockTime != "number")
    throw new Error("Transaction lock time should be number");
  if (ht.encode(t.lockTime), t.PSBTVersion !== 0 && t.PSBTVersion !== 2)
    throw new Error(`Unknown PSBT version ${t.PSBTVersion}`);
  for (const n of [
    "allowUnknownVersion",
    "allowUnknownOutputs",
    "allowUnknownInputs",
    "disableScriptCheck",
    "bip174jsCompat",
    "allowLegacyWitnessUtxo",
    "lowR"
  ]) {
    const r = t[n];
    if (r !== void 0 && typeof r != "boolean")
      throw new Error(`Transation options wrong type: ${n}=${r} (${typeof r})`);
  }
  if (t.allowUnknownVersion ? typeof t.version == "number" : ![-1, 0, 1, 2, 3].includes(t.version))
    throw new Error(`Unknown version: ${t.version}`);
  if (t.customScripts !== void 0) {
    const n = t.customScripts;
    if (!Array.isArray(n))
      throw new Error(`wrong custom scripts type (expected array): customScripts=${n} (${typeof n})`);
    for (const r of n) {
      if (typeof r.encode != "function" || typeof r.decode != "function")
        throw new Error(`wrong script=${r} (${typeof r})`);
      if (r.finalizeTaproot !== void 0 && typeof r.finalizeTaproot != "function")
        throw new Error(`wrong script=${r} (${typeof r})`);
    }
  }
  return Object.freeze(t);
}
function rg(e) {
  if (e.nonWitnessUtxo && e.index !== void 0) {
    const t = e.nonWitnessUtxo.outputs.length - 1;
    if (e.index > t)
      throw new Error(`validateInput: index(${e.index}) not in nonWitnessUtxo`);
    const n = e.nonWitnessUtxo.outputs[e.index];
    if (e.witnessUtxo && (!Nt(e.witnessUtxo.script, n.script) || e.witnessUtxo.amount !== n.amount))
      throw new Error("validateInput: witnessUtxo different from nonWitnessUtxo");
    if (e.txid) {
      if (e.nonWitnessUtxo.outputs.length - 1 < e.index)
        throw new Error("nonWitnessUtxo: incorect output index");
      const i = Xt.fromRaw(Wi.encode(e.nonWitnessUtxo), {
        allowUnknownOutputs: !0,
        disableScriptCheck: !0,
        allowUnknownInputs: !0
      }), s = C.encode(e.txid);
      if (i.isFinal && i.id !== s)
        throw new Error(`nonWitnessUtxo: wrong txid, exp=${s} got=${i.id}`);
    }
  }
  return e;
}
function Ta(e) {
  if (e.nonWitnessUtxo) {
    if (e.index === void 0)
      throw new Error("Unknown input index");
    return e.nonWitnessUtxo.outputs[e.index];
  } else {
    if (e.witnessUtxo)
      return e.witnessUtxo;
    throw new Error("Cannot find previous output info");
  }
}
function ig(e, t, n, r = !1, i = !1) {
  let { nonWitnessUtxo: s, txid: o } = e;
  typeof s == "string" && (s = C.decode(s)), xt(s) && (s = Wi.decode(s)), !("nonWitnessUtxo" in e) && s === void 0 && (s = t?.nonWitnessUtxo), typeof o == "string" && (o = C.decode(o)), o === void 0 && (o = t?.txid);
  let a = { ...t, ...e, nonWitnessUtxo: s, txid: o };
  !("nonWitnessUtxo" in e) && a.nonWitnessUtxo === void 0 && delete a.nonWitnessUtxo, a.sequence === void 0 && (a.sequence = Ud), a.tapMerkleRoot === null && delete a.tapMerkleRoot, a = rf(su, a, t, n, i), Nd.encode(a);
  let c;
  return a.nonWitnessUtxo && a.index !== void 0 ? c = a.nonWitnessUtxo.outputs[a.index] : a.witnessUtxo && (c = a.witnessUtxo), c && !r && yb(c && c.script, a.redeemScript, a.witnessScript), a;
}
function sg(e, t = !1) {
  let n = "legacy", r = ct.ALL;
  const i = Ta(e), s = It.decode(i.script);
  let o = s.type, a = s;
  const c = [s];
  if (s.type === "tr")
    return r = ct.DEFAULT, {
      txType: "taproot",
      type: "tr",
      last: s,
      lastScript: i.script,
      defaultSighash: r,
      sighash: e.sighashType || r
    };
  {
    if ((s.type === "wpkh" || s.type === "wsh") && (n = "segwit"), s.type === "sh") {
      if (!e.redeemScript)
        throw new Error("inputType: sh without redeemScript");
      let h = It.decode(e.redeemScript);
      (h.type === "wpkh" || h.type === "wsh") && (n = "segwit"), c.push(h), a = h, o += `-${h.type}`;
    }
    if (a.type === "wsh") {
      if (!e.witnessScript)
        throw new Error("inputType: wsh without witnessScript");
      let h = It.decode(e.witnessScript);
      h.type === "wsh" && (n = "segwit"), c.push(h), a = h, o += `-${h.type}`;
    }
    const u = c[c.length - 1];
    if (u.type === "sh" || u.type === "wsh")
      throw new Error("inputType: sh/wsh cannot be terminal type");
    const l = It.encode(u), f = {
      type: o,
      txType: n,
      last: u,
      lastScript: l,
      defaultSighash: r,
      sighash: e.sighashType || r
    };
    if (n === "legacy" && !t && !e.nonWitnessUtxo)
      throw new Error("Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure");
    return f;
  }
}
let Xt = class Sa {
  global = {};
  inputs = [];
  // use getInput()
  outputs = [];
  // use getOutput()
  opts;
  constructor(t = {}) {
    const n = this.opts = Xk(t);
    n.lockTime !== Yr && (this.global.fallbackLocktime = n.lockTime), this.global.txVersion = n.version;
  }
  // Import
  static fromRaw(t, n = {}) {
    const r = Wi.decode(t), i = new Sa({ ...n, version: r.version, lockTime: r.lockTime });
    for (const s of r.outputs)
      i.addOutput(s);
    if (i.outputs = r.outputs, i.inputs = r.inputs, r.witnesses)
      for (let s = 0; s < r.witnesses.length; s++)
        i.inputs[s].finalScriptWitness = r.witnesses[s];
    return i;
  }
  // PSBT
  static fromPSBT(t, n = {}) {
    let r;
    try {
      r = Qp.decode(t);
    } catch (f) {
      try {
        r = Jp.decode(t);
      } catch {
        throw f;
      }
    }
    const i = r.global.version || 0;
    if (i !== 0 && i !== 2)
      throw new Error(`Wrong PSBT version=${i}`);
    const s = r.global.unsignedTx, o = i === 0 ? s?.version : r.global.txVersion, a = i === 0 ? s?.lockTime : r.global.fallbackLocktime, c = new Sa({ ...n, version: o, lockTime: a, PSBTVersion: i }), u = i === 0 ? s?.inputs.length : r.global.inputCount;
    c.inputs = r.inputs.slice(0, u).map((f, h) => rg({
      finalScriptSig: $t,
      ...r.global.unsignedTx?.inputs[h],
      ...f
    }));
    const l = i === 0 ? s?.outputs.length : r.global.outputCount;
    return c.outputs = r.outputs.slice(0, l).map((f, h) => ({
      ...f,
      ...r.global.unsignedTx?.outputs[h]
    })), c.global = { ...r.global, txVersion: o }, a !== Yr && (c.global.fallbackLocktime = a), c;
  }
  toPSBT(t = this.opts.PSBTVersion) {
    if (t !== 0 && t !== 2)
      throw new Error(`Wrong PSBT version=${t}`);
    const n = this.inputs.map((s) => rg(Xp(t, su, s)));
    for (const s of n)
      s.partialSig && !s.partialSig.length && delete s.partialSig, s.finalScriptSig && !s.finalScriptSig.length && delete s.finalScriptSig, s.finalScriptWitness && !s.finalScriptWitness.length && delete s.finalScriptWitness;
    const r = this.outputs.map((s) => Xp(t, go, s)), i = { ...this.global };
    return t === 0 ? (i.unsignedTx = Ms.decode(Ms.encode({
      version: this.version,
      lockTime: this.lockTime,
      inputs: this.inputs.map(Ps).map((s) => ({
        ...s,
        finalScriptSig: $t
      })),
      outputs: this.outputs.map(Zr)
    })), delete i.fallbackLocktime, delete i.txVersion) : (i.version = t, i.txVersion = this.version, i.inputCount = this.inputs.length, i.outputCount = this.outputs.length, i.fallbackLocktime && i.fallbackLocktime === Yr && delete i.fallbackLocktime), this.opts.bip174jsCompat && (n.length || n.push({}), r.length || r.push({})), (t === 0 ? Qp : Jp).encode({
      global: i,
      inputs: n,
      outputs: r
    });
  }
  // BIP370 lockTime (https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#determining-lock-time)
  get lockTime() {
    let t = Yr, n = 0, r = Yr, i = 0;
    for (const s of this.inputs)
      s.requiredHeightLocktime && (t = Math.max(t, s.requiredHeightLocktime), n++), s.requiredTimeLocktime && (r = Math.max(r, s.requiredTimeLocktime), i++);
    return n && n >= i ? t : r !== Yr ? r : this.global.fallbackLocktime || Yr;
  }
  get version() {
    if (this.global.txVersion === void 0)
      throw new Error("No global.txVersion");
    return this.global.txVersion;
  }
  inputStatus(t) {
    this.checkInputIdx(t);
    const n = this.inputs[t];
    return n.finalScriptSig && n.finalScriptSig.length || n.finalScriptWitness && n.finalScriptWitness.length ? "finalized" : n.tapKeySig || n.tapScriptSig && n.tapScriptSig.length || n.partialSig && n.partialSig.length ? "signed" : "unsigned";
  }
  // Cannot replace unpackSighash, tests rely on very generic implemenetation with signing inputs outside of range
  // We will lose some vectors -> smaller test coverage of preimages (very important!)
  inputSighash(t) {
    this.checkInputIdx(t);
    const n = this.inputs[t].sighashType, r = n === void 0 ? ct.DEFAULT : n, i = r === ct.DEFAULT ? ct.ALL : r & 3;
    return { sigInputs: r & ct.ANYONECANPAY, sigOutputs: i };
  }
  // Very nice for debug purposes, but slow. If there is too much inputs/outputs to add, will be quadratic.
  // Some cache will be nice, but there chance to have bugs with cache invalidation
  signStatus() {
    let t = !0, n = !0, r = [], i = [];
    for (let s = 0; s < this.inputs.length; s++) {
      if (this.inputStatus(s) === "unsigned")
        continue;
      const { sigInputs: a, sigOutputs: c } = this.inputSighash(s);
      if (a === ct.ANYONECANPAY ? r.push(s) : t = !1, c === ct.ALL)
        n = !1;
      else if (c === ct.SINGLE)
        i.push(s);
      else if (c !== ct.NONE) throw new Error(`Wrong signature hash output type: ${c}`);
    }
    return { addInput: t, addOutput: n, inputs: r, outputs: i };
  }
  get isFinal() {
    for (let t = 0; t < this.inputs.length; t++)
      if (this.inputStatus(t) !== "finalized")
        return !1;
    return !0;
  }
  // Info utils
  get hasWitnesses() {
    let t = !1;
    for (const n of this.inputs)
      n.finalScriptWitness && n.finalScriptWitness.length && (t = !0);
    return t;
  }
  // https://en.bitcoin.it/wiki/Weight_units
  get weight() {
    if (!this.isFinal)
      throw new Error("Transaction is not finalized");
    let t = 32;
    const n = this.outputs.map(Zr);
    t += 4 * Je.encode(this.outputs.length).length;
    for (const r of n)
      t += 32 + 4 * je.encode(r.script).length;
    this.hasWitnesses && (t += 2), t += 4 * Je.encode(this.inputs.length).length;
    for (const r of this.inputs)
      t += 160 + 4 * je.encode(r.finalScriptSig || $t).length, this.hasWitnesses && r.finalScriptWitness && (t += po.encode(r.finalScriptWitness).length);
    return t;
  }
  get vsize() {
    return jk(this.weight);
  }
  toBytes(t = !1, n = !1) {
    return Wi.encode({
      version: this.version,
      lockTime: this.lockTime,
      inputs: this.inputs.map(Ps).map((r) => ({
        ...r,
        finalScriptSig: t && r.finalScriptSig || $t
      })),
      outputs: this.outputs.map(Zr),
      witnesses: this.inputs.map((r) => r.finalScriptWitness || []),
      segwitFlag: n && this.hasWitnesses
    });
  }
  get unsignedTx() {
    return this.toBytes(!1, !1);
  }
  get hex() {
    return C.encode(this.toBytes(!0, this.hasWitnesses));
  }
  get hash() {
    return C.encode(cr(this.toBytes(!0)));
  }
  get id() {
    return C.encode(cr(this.toBytes(!0)).reverse());
  }
  // Input stuff
  checkInputIdx(t) {
    if (!Number.isSafeInteger(t) || 0 > t || t >= this.inputs.length)
      throw new Error(`Wrong input index=${t}`);
  }
  getInput(t) {
    return this.checkInputIdx(t), hc(this.inputs[t]);
  }
  get inputsLength() {
    return this.inputs.length;
  }
  // Modification
  addInput(t, n = !1) {
    if (!n && !this.signStatus().addInput)
      throw new Error("Tx has signed inputs, cannot add new one");
    return this.inputs.push(ig(t, void 0, void 0, this.opts.disableScriptCheck)), this.inputs.length - 1;
  }
  updateInput(t, n, r = !1) {
    this.checkInputIdx(t);
    let i;
    if (!r) {
      const s = this.signStatus();
      (!s.addInput || s.inputs.includes(t)) && (i = Sk);
    }
    this.inputs[t] = ig(n, this.inputs[t], i, this.opts.disableScriptCheck, this.opts.allowUnknown);
  }
  // Output stuff
  checkOutputIdx(t) {
    if (!Number.isSafeInteger(t) || 0 > t || t >= this.outputs.length)
      throw new Error(`Wrong output index=${t}`);
  }
  getOutput(t) {
    return this.checkOutputIdx(t), hc(this.outputs[t]);
  }
  getOutputAddress(t, n = cs) {
    const r = this.getOutput(t);
    if (r.script)
      return Gn(n).encode(It.decode(r.script));
  }
  get outputsLength() {
    return this.outputs.length;
  }
  normalizeOutput(t, n, r) {
    let { amount: i, script: s } = t;
    if (i === void 0 && (i = n?.amount), typeof i != "bigint")
      throw new Error(`Wrong amount type, should be of type bigint in sats, but got ${i} of type ${typeof i}`);
    typeof s == "string" && (s = C.decode(s)), s === void 0 && (s = n?.script);
    let o = { ...n, ...t, amount: i, script: s };
    if (o.amount === void 0 && delete o.amount, o = rf(go, o, n, r, this.opts.allowUnknown), Ld.encode(o), o.script && !this.opts.allowUnknownOutputs && It.decode(o.script).type === "unknown")
      throw new Error("Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure");
    return this.opts.disableScriptCheck || yb(o.script, o.redeemScript, o.witnessScript), o;
  }
  addOutput(t, n = !1) {
    if (!n && !this.signStatus().addOutput)
      throw new Error("Tx has signed outputs, cannot add new one");
    return this.outputs.push(this.normalizeOutput(t)), this.outputs.length - 1;
  }
  updateOutput(t, n, r = !1) {
    this.checkOutputIdx(t);
    let i;
    if (!r) {
      const s = this.signStatus();
      (!s.addOutput || s.outputs.includes(t)) && (i = vk);
    }
    this.outputs[t] = this.normalizeOutput(n, this.outputs[t], i);
  }
  addOutputAddress(t, n, r = cs) {
    return this.addOutput({ script: It.encode(Gn(r).decode(t)), amount: n });
  }
  // Utils
  get fee() {
    let t = 0n;
    for (const r of this.inputs) {
      const i = Ta(r);
      if (!i)
        throw new Error("Empty input amount");
      t += i.amount;
    }
    const n = this.outputs.map(Zr);
    for (const r of n)
      t -= r.amount;
    return t;
  }
  // Signing
  // Based on https://github.com/bitcoin/bitcoin/blob/5871b5b5ab57a0caf9b7514eb162c491c83281d5/test/functional/test_framework/script.py#L624
  // There is optimization opportunity to re-use hashes for multiple inputs for witness v0/v1,
  // but we are trying to be less complicated for audit purpose for now.
  preimageLegacy(t, n, r) {
    const { isAny: i, isNone: s, isSingle: o } = ng(r);
    if (t < 0 || !Number.isSafeInteger(t))
      throw new Error(`Invalid input idx=${t}`);
    if (o && t >= this.outputs.length || t >= this.inputs.length)
      return sb.encode(1n);
    n = et.encode(et.decode(n).filter((l) => l !== "CODESEPARATOR"));
    let a = this.inputs.map(Ps).map((l, f) => ({
      ...l,
      finalScriptSig: f === t ? n : $t
    }));
    i ? a = [a[t]] : (s || o) && (a = a.map((l, f) => ({
      ...l,
      sequence: f === t ? l.sequence : 0
    })));
    let c = this.outputs.map(Zr);
    s ? c = [] : o && (c = c.slice(0, t).fill(Kk).concat([c[t]]));
    const u = Wi.encode({
      lockTime: this.lockTime,
      version: this.version,
      segwitFlag: !1,
      inputs: a,
      outputs: c
    });
    return cr(u, Li.encode(r));
  }
  preimageWitnessV0(t, n, r, i) {
    const { isAny: s, isNone: o, isSingle: a } = ng(r);
    let c = zo, u = zo, l = zo;
    const f = this.inputs.map(Ps), h = this.outputs.map(Zr);
    s || (c = cr(...f.map(Zu.encode))), !s && !a && !o && (u = cr(...f.map((d) => ht.encode(d.sequence)))), !a && !o ? l = cr(...h.map(ai.encode)) : a && t < h.length && (l = cr(ai.encode(h[t])));
    const g = f[t];
    return cr(Li.encode(this.version), c, u, kt(32, !0).encode(g.txid), ht.encode(g.index), je.encode(n), xa.encode(i), ht.encode(g.sequence), l, ht.encode(this.lockTime), ht.encode(r));
  }
  preimageWitnessV1(t, n, r, i, s = -1, o, a = 192, c) {
    if (!Array.isArray(i) || this.inputs.length !== i.length)
      throw new Error(`Invalid amounts array=${i}`);
    if (!Array.isArray(n) || this.inputs.length !== n.length)
      throw new Error(`Invalid prevOutScript array=${n}`);
    const u = [
      kr.encode(0),
      kr.encode(r),
      // U8 sigHash
      Li.encode(this.version),
      ht.encode(this.lockTime)
    ], l = r === ct.DEFAULT ? ct.ALL : r & 3, f = r & ct.ANYONECANPAY, h = this.inputs.map(Ps), g = this.outputs.map(Zr);
    f !== ct.ANYONECANPAY && u.push(...[
      h.map(Zu.encode),
      i.map(xa.encode),
      n.map(je.encode),
      h.map((p) => ht.encode(p.sequence))
    ].map((p) => Bt(br(...p)))), l === ct.ALL && u.push(Bt(br(...g.map(ai.encode))));
    const d = (c ? 1 : 0) | (o ? 2 : 0);
    if (u.push(new Uint8Array([d])), f === ct.ANYONECANPAY) {
      const p = h[t];
      u.push(Zu.encode(p), xa.encode(i[t]), je.encode(n[t]), ht.encode(p.sequence));
    } else
      u.push(ht.encode(t));
    return d & 1 && u.push(Bt(je.encode(c || $t))), l === ct.SINGLE && u.push(t < g.length ? Bt(ai.encode(g[t])) : zo), o && u.push(Ki(o, a), kr.encode(0), Li.encode(s)), Od("TapSighash", ...u);
  }
  // Signer can be privateKey OR instance of bip32 HD stuff
  signIdx(t, n, r, i) {
    this.checkInputIdx(n);
    const s = this.inputs[n], o = sg(s, this.opts.allowLegacyWitnessUtxo);
    if (!xt(t)) {
      if (!s.bip32Derivation || !s.bip32Derivation.length)
        throw new Error("bip32Derivation: empty");
      const l = s.bip32Derivation.filter((h) => h[1].fingerprint == t.fingerprint).map(([h, { path: g }]) => {
        let d = t;
        for (const p of g)
          d = d.deriveChild(p);
        if (!Nt(d.publicKey, h))
          throw new Error("bip32Derivation: wrong pubKey");
        if (!d.privateKey)
          throw new Error("bip32Derivation: no privateKey");
        return d;
      });
      if (!l.length)
        throw new Error(`bip32Derivation: no items with fingerprint=${t.fingerprint}`);
      let f = !1;
      for (const h of l)
        this.signIdx(h.privateKey, n) && (f = !0);
      return f;
    }
    r ? r.forEach(Zk) : r = [o.defaultSighash];
    const a = o.sighash;
    if (!r.includes(a))
      throw new Error(`Input with not allowed sigHash=${a}. Allowed: ${r.join(", ")}`);
    const { sigOutputs: c } = this.inputSighash(n);
    if (c === ct.SINGLE && n >= this.outputs.length)
      throw new Error(`Input with sighash SINGLE, but there is no output with corresponding index=${n}`);
    const u = Ta(s);
    if (o.txType === "taproot") {
      const l = this.inputs.map(Ta), f = l.map((y) => y.script), h = l.map((y) => y.amount);
      let g = !1, d = Id(t), p = s.tapMerkleRoot || $t;
      if (s.tapInternalKey) {
        const { pubKey: y, privKey: x } = Yk(t, d, s.tapInternalKey, p), [S] = tf(s.tapInternalKey, p);
        if (Nt(S, y)) {
          const A = this.preimageWitnessV1(n, f, a, h), R = br(zp(A, x, i), a !== ct.DEFAULT ? new Uint8Array([a]) : $t);
          this.updateInput(n, { tapKeySig: R }, !0), g = !0;
        }
      }
      if (s.tapLeafScript) {
        s.tapScriptSig = s.tapScriptSig || [];
        for (const [y, x] of s.tapLeafScript) {
          const S = x.subarray(0, -1), A = et.decode(S), R = x[x.length - 1], N = Ki(S, R);
          if (A.findIndex((U) => xt(U) && Nt(U, d)) === -1)
            continue;
          const w = this.preimageWitnessV1(n, f, a, h, void 0, S, R), K = br(zp(w, t, i), a !== ct.DEFAULT ? new Uint8Array([a]) : $t);
          this.updateInput(n, { tapScriptSig: [[{ pubKey: d, leafHash: N }, K]] }, !0), g = !0;
        }
      }
      if (!g)
        throw new Error("No taproot scripts signed");
      return !0;
    } else {
      const l = ub(t);
      let f = !1;
      const h = cb(l);
      for (const p of et.decode(o.lastScript))
        xt(p) && (Nt(p, l) || Nt(p, h)) && (f = !0);
      if (!f)
        throw new Error(`Input script doesn't have pubKey: ${o.lastScript}`);
      let g;
      if (o.txType === "legacy")
        g = this.preimageLegacy(n, o.lastScript, a);
      else if (o.txType === "segwit") {
        let p = o.lastScript;
        o.last.type === "wpkh" && (p = It.encode({ type: "pkh", hash: o.last.hash })), g = this.preimageWitnessV0(n, p, a, u.amount);
      } else
        throw new Error(`Transaction/sign: unknown tx type: ${o.txType}`);
      const d = dk(g, t, this.opts.lowR);
      this.updateInput(n, {
        partialSig: [[l, br(d, new Uint8Array([a]))]]
      }, !0);
    }
    return !0;
  }
  // This is bad API. Will work if user creates and signs tx, but if
  // there is some complex workflow with exchanging PSBT and signing them,
  // then it is better to validate which output user signs. How could a better API look like?
  // Example: user adds input, sends to another party, then signs received input (mixer etc),
  // another user can add different input for same key and user will sign it.
  // Even worse: another user can add bip32 derivation, and spend money from different address.
  // Better api: signIdx
  sign(t, n, r) {
    let i = 0;
    for (let s = 0; s < this.inputs.length; s++)
      try {
        this.signIdx(t, s, n, r) && i++;
      } catch {
      }
    if (!i)
      throw new Error("No inputs signed");
    return i;
  }
  finalizeIdx(t) {
    if (this.checkInputIdx(t), this.fee < 0n)
      throw new Error("Outputs spends more than inputs amount");
    const n = this.inputs[t], r = sg(n, this.opts.allowLegacyWitnessUtxo);
    if (r.txType === "taproot") {
      if (n.tapKeySig)
        n.finalScriptWitness = [n.tapKeySig];
      else if (n.tapLeafScript && n.tapScriptSig) {
        const c = n.tapLeafScript.sort((u, l) => Tn.encode(u[0]).length - Tn.encode(l[0]).length);
        for (const [u, l] of c) {
          const f = l.slice(0, -1), h = l[l.length - 1], g = It.decode(f), d = Ki(f, h), p = n.tapScriptSig.filter((x) => Nt(x[0].leafHash, d));
          let y = [];
          if (g.type === "tr_ms") {
            const x = g.m, S = g.pubkeys;
            let A = 0;
            for (const R of S) {
              const N = p.findIndex((F) => Nt(F[0].pubKey, R));
              if (A === x || N === -1) {
                y.push($t);
                continue;
              }
              y.push(p[N][1]), A++;
            }
            if (A !== x)
              continue;
          } else if (g.type === "tr_ns") {
            for (const x of g.pubkeys) {
              const S = p.findIndex((A) => Nt(A[0].pubKey, x));
              S !== -1 && y.push(p[S][1]);
            }
            if (y.length !== g.pubkeys.length)
              continue;
          } else if (g.type === "unknown" && this.opts.allowUnknownInputs) {
            const x = et.decode(f);
            if (y = p.map(([{ pubKey: S }, A]) => {
              const R = x.findIndex((N) => xt(N) && Nt(N, S));
              if (R === -1)
                throw new Error("finalize/taproot: cannot find position of pubkey in script");
              return { signature: A, pos: R };
            }).sort((S, A) => S.pos - A.pos).map((S) => S.signature), !y.length)
              continue;
          } else {
            const x = this.opts.customScripts;
            if (x)
              for (const S of x) {
                if (!S.finalizeTaproot)
                  continue;
                const A = et.decode(f), R = S.encode(A);
                if (R === void 0)
                  continue;
                const N = S.finalizeTaproot(f, R, p);
                if (N) {
                  n.finalScriptWitness = N.concat(Tn.encode(u)), n.finalScriptSig = $t, Yu(n);
                  return;
                }
              }
            throw new Error("Finalize: Unknown tapLeafScript");
          }
          n.finalScriptWitness = y.reverse().concat([f, Tn.encode(u)]);
          break;
        }
        if (!n.finalScriptWitness)
          throw new Error("finalize/taproot: empty witness");
      } else
        throw new Error("finalize/taproot: unknown input");
      n.finalScriptSig = $t, Yu(n);
      return;
    }
    if (!n.partialSig || !n.partialSig.length)
      throw new Error("Not enough partial sign");
    let i = $t, s = [];
    if (r.last.type === "ms") {
      const c = r.last.m, u = r.last.pubkeys;
      let l = [];
      for (const f of u) {
        const h = n.partialSig.find((g) => Nt(f, g[0]));
        h && l.push(h[1]);
      }
      if (l = l.slice(0, c), l.length !== c)
        throw new Error(`Multisig: wrong signatures count, m=${c} n=${u.length} signatures=${l.length}`);
      i = et.encode([0, ...l]);
    } else if (r.last.type === "pk")
      i = et.encode([n.partialSig[0][1]]);
    else if (r.last.type === "pkh")
      i = et.encode([n.partialSig[0][1], n.partialSig[0][0]]);
    else if (r.last.type === "wpkh")
      i = $t, s = [n.partialSig[0][1], n.partialSig[0][0]];
    else if (r.last.type === "unknown" && !this.opts.allowUnknownInputs)
      throw new Error("Unknown inputs not allowed");
    let o, a;
    if (r.type.includes("wsh-") && (i.length && r.lastScript.length && (s = et.decode(i).map((c) => {
      if (c === 0)
        return $t;
      if (xt(c))
        return c;
      throw new Error(`Wrong witness op=${c}`);
    })), s = s.concat(r.lastScript)), r.txType === "segwit" && (a = s), r.type.startsWith("sh-wsh-") ? o = et.encode([et.encode([0, Bt(r.lastScript)])]) : r.type.startsWith("sh-") ? o = et.encode([...et.decode(i), r.lastScript]) : r.type.startsWith("wsh-") || r.txType !== "segwit" && (o = i), !o && !a)
      throw new Error("Unknown error finalizing input");
    o && (n.finalScriptSig = o), a && (n.finalScriptWitness = a), Yu(n);
  }
  finalize() {
    for (let t = 0; t < this.inputs.length; t++)
      this.finalizeIdx(t);
  }
  extract() {
    if (!this.isFinal)
      throw new Error("Transaction has unfinalized inputs");
    if (!this.outputs.length)
      throw new Error("Transaction has no outputs");
    if (this.fee < 0n)
      throw new Error("Outputs spends more than inputs amount");
    return this.toBytes(!0, !0);
  }
  combine(t) {
    for (const i of ["PSBTVersion", "version", "lockTime"])
      if (this.opts[i] !== t.opts[i])
        throw new Error(`Transaction/combine: different ${i} this=${this.opts[i]} other=${t.opts[i]}`);
    for (const i of ["inputs", "outputs"])
      if (this[i].length !== t[i].length)
        throw new Error(`Transaction/combine: different ${i} length this=${this[i].length} other=${t[i].length}`);
    const n = this.global.unsignedTx ? Ms.encode(this.global.unsignedTx) : $t, r = t.global.unsignedTx ? Ms.encode(t.global.unsignedTx) : $t;
    if (!Nt(n, r))
      throw new Error("Transaction/combine: different unsigned tx");
    this.global = rf(Rd, this.global, t.global, void 0, this.opts.allowUnknown);
    for (let i = 0; i < this.inputs.length; i++)
      this.updateInput(i, t.inputs[i], !0);
    for (let i = 0; i < this.outputs.length; i++)
      this.updateOutput(i, t.outputs[i], !0);
    return this;
  }
  clone() {
    return Sa.fromPSBT(this.toPSBT(this.opts.PSBTVersion), this.opts);
  }
};
var Xu = {}, og;
function Qk() {
  return og || (og = 1, (function(e) {
    /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    Object.defineProperty(e, "__esModule", { value: !0 }), e.bytes = e.stringToBytes = e.str = e.bytesToString = e.hex = e.utf8 = e.bech32m = e.bech32 = e.base58check = e.base58xmr = e.base58xrp = e.base58flickr = e.base58 = e.base64url = e.base64 = e.base32crockford = e.base32hex = e.base32 = e.base16 = e.utils = e.assertNumber = void 0;
    function t(B) {
      if (!Number.isSafeInteger(B))
        throw new Error(`Wrong integer: ${B}`);
    }
    e.assertNumber = t;
    function n(...B) {
      const v = (m, T) => (k) => m(T(k)), b = Array.from(B).reverse().reduce((m, T) => m ? v(m, T.encode) : T.encode, void 0), E = B.reduce((m, T) => m ? v(m, T.decode) : T.decode, void 0);
      return { encode: b, decode: E };
    }
    function r(B) {
      return {
        encode: (v) => {
          if (!Array.isArray(v) || v.length && typeof v[0] != "number")
            throw new Error("alphabet.encode input should be an array of numbers");
          return v.map((b) => {
            if (t(b), b < 0 || b >= B.length)
              throw new Error(`Digit index outside alphabet: ${b} (alphabet: ${B.length})`);
            return B[b];
          });
        },
        decode: (v) => {
          if (!Array.isArray(v) || v.length && typeof v[0] != "string")
            throw new Error("alphabet.decode input should be array of strings");
          return v.map((b) => {
            if (typeof b != "string")
              throw new Error(`alphabet.decode: not string element=${b}`);
            const E = B.indexOf(b);
            if (E === -1)
              throw new Error(`Unknown letter: "${b}". Allowed: ${B}`);
            return E;
          });
        }
      };
    }
    function i(B = "") {
      if (typeof B != "string")
        throw new Error("join separator should be string");
      return {
        encode: (v) => {
          if (!Array.isArray(v) || v.length && typeof v[0] != "string")
            throw new Error("join.encode input should be array of strings");
          for (let b of v)
            if (typeof b != "string")
              throw new Error(`join.encode: non-string input=${b}`);
          return v.join(B);
        },
        decode: (v) => {
          if (typeof v != "string")
            throw new Error("join.decode input should be string");
          return v.split(B);
        }
      };
    }
    function s(B, v = "=") {
      if (t(B), typeof v != "string")
        throw new Error("padding chr should be string");
      return {
        encode(b) {
          if (!Array.isArray(b) || b.length && typeof b[0] != "string")
            throw new Error("padding.encode input should be array of strings");
          for (let E of b)
            if (typeof E != "string")
              throw new Error(`padding.encode: non-string input=${E}`);
          for (; b.length * B % 8; )
            b.push(v);
          return b;
        },
        decode(b) {
          if (!Array.isArray(b) || b.length && typeof b[0] != "string")
            throw new Error("padding.encode input should be array of strings");
          for (let m of b)
            if (typeof m != "string")
              throw new Error(`padding.decode: non-string input=${m}`);
          let E = b.length;
          if (E * B % 8)
            throw new Error("Invalid padding: string should have whole number of bytes");
          for (; E > 0 && b[E - 1] === v; E--)
            if (!((E - 1) * B % 8))
              throw new Error("Invalid padding: string has too much padding");
          return b.slice(0, E);
        }
      };
    }
    function o(B) {
      if (typeof B != "function")
        throw new Error("normalize fn should be function");
      return { encode: (v) => v, decode: (v) => B(v) };
    }
    function a(B, v, b) {
      if (v < 2)
        throw new Error(`convertRadix: wrong from=${v}, base cannot be less than 2`);
      if (b < 2)
        throw new Error(`convertRadix: wrong to=${b}, base cannot be less than 2`);
      if (!Array.isArray(B))
        throw new Error("convertRadix: data should be array");
      if (!B.length)
        return [];
      let E = 0;
      const m = [], T = Array.from(B);
      for (T.forEach((k) => {
        if (t(k), k < 0 || k >= v)
          throw new Error(`Wrong integer: ${k}`);
      }); ; ) {
        let k = 0, P = !0;
        for (let O = E; O < T.length; O++) {
          const I = T[O], $ = v * k + I;
          if (!Number.isSafeInteger($) || v * k / v !== k || $ - I !== v * k)
            throw new Error("convertRadix: carry overflow");
          if (k = $ % b, T[O] = Math.floor($ / b), !Number.isSafeInteger(T[O]) || T[O] * b + k !== $)
            throw new Error("convertRadix: carry overflow");
          if (P)
            T[O] ? P = !1 : E = O;
          else continue;
        }
        if (m.push(k), P)
          break;
      }
      for (let k = 0; k < B.length - 1 && B[k] === 0; k++)
        m.push(0);
      return m.reverse();
    }
    const c = (B, v) => v ? c(v, B % v) : B, u = (B, v) => B + (v - c(B, v));
    function l(B, v, b, E) {
      if (!Array.isArray(B))
        throw new Error("convertRadix2: data should be array");
      if (v <= 0 || v > 32)
        throw new Error(`convertRadix2: wrong from=${v}`);
      if (b <= 0 || b > 32)
        throw new Error(`convertRadix2: wrong to=${b}`);
      if (u(v, b) > 32)
        throw new Error(`convertRadix2: carry overflow from=${v} to=${b} carryBits=${u(v, b)}`);
      let m = 0, T = 0;
      const k = 2 ** b - 1, P = [];
      for (const O of B) {
        if (t(O), O >= 2 ** v)
          throw new Error(`convertRadix2: invalid data word=${O} from=${v}`);
        if (m = m << v | O, T + v > 32)
          throw new Error(`convertRadix2: carry overflow pos=${T} from=${v}`);
        for (T += v; T >= b; T -= b)
          P.push((m >> T - b & k) >>> 0);
        m &= 2 ** T - 1;
      }
      if (m = m << b - T & k, !E && T >= v)
        throw new Error("Excess padding");
      if (!E && m)
        throw new Error(`Non-zero padding: ${m}`);
      return E && T > 0 && P.push(m >>> 0), P;
    }
    function f(B) {
      return t(B), {
        encode: (v) => {
          if (!(v instanceof Uint8Array))
            throw new Error("radix.encode input should be Uint8Array");
          return a(Array.from(v), 2 ** 8, B);
        },
        decode: (v) => {
          if (!Array.isArray(v) || v.length && typeof v[0] != "number")
            throw new Error("radix.decode input should be array of strings");
          return Uint8Array.from(a(v, B, 2 ** 8));
        }
      };
    }
    function h(B, v = !1) {
      if (t(B), B <= 0 || B > 32)
        throw new Error("radix2: bits should be in (0..32]");
      if (u(8, B) > 32 || u(B, 8) > 32)
        throw new Error("radix2: carry overflow");
      return {
        encode: (b) => {
          if (!(b instanceof Uint8Array))
            throw new Error("radix2.encode input should be Uint8Array");
          return l(Array.from(b), 8, B, !v);
        },
        decode: (b) => {
          if (!Array.isArray(b) || b.length && typeof b[0] != "number")
            throw new Error("radix2.decode input should be array of strings");
          return Uint8Array.from(l(b, B, 8, v));
        }
      };
    }
    function g(B) {
      if (typeof B != "function")
        throw new Error("unsafeWrapper fn should be function");
      return function(...v) {
        try {
          return B.apply(null, v);
        } catch {
        }
      };
    }
    function d(B, v) {
      if (t(B), typeof v != "function")
        throw new Error("checksum fn should be function");
      return {
        encode(b) {
          if (!(b instanceof Uint8Array))
            throw new Error("checksum.encode: input should be Uint8Array");
          const E = v(b).slice(0, B), m = new Uint8Array(b.length + B);
          return m.set(b), m.set(E, b.length), m;
        },
        decode(b) {
          if (!(b instanceof Uint8Array))
            throw new Error("checksum.decode: input should be Uint8Array");
          const E = b.slice(0, -B), m = v(E).slice(0, B), T = b.slice(-B);
          for (let k = 0; k < B; k++)
            if (m[k] !== T[k])
              throw new Error("Invalid checksum");
          return E;
        }
      };
    }
    e.utils = { alphabet: r, chain: n, checksum: d, radix: f, radix2: h, join: i, padding: s }, e.base16 = n(h(4), r("0123456789ABCDEF"), i("")), e.base32 = n(h(5), r("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), s(5), i("")), e.base32hex = n(h(5), r("0123456789ABCDEFGHIJKLMNOPQRSTUV"), s(5), i("")), e.base32crockford = n(h(5), r("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), i(""), o((B) => B.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), e.base64 = n(h(6), r("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), s(6), i("")), e.base64url = n(h(6), r("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), s(6), i(""));
    const p = (B) => n(f(58), r(B), i(""));
    e.base58 = p("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), e.base58flickr = p("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), e.base58xrp = p("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    const y = [0, 2, 3, 5, 6, 7, 9, 10, 11];
    e.base58xmr = {
      encode(B) {
        let v = "";
        for (let b = 0; b < B.length; b += 8) {
          const E = B.subarray(b, b + 8);
          v += e.base58.encode(E).padStart(y[E.length], "1");
        }
        return v;
      },
      decode(B) {
        let v = [];
        for (let b = 0; b < B.length; b += 11) {
          const E = B.slice(b, b + 11), m = y.indexOf(E.length), T = e.base58.decode(E);
          for (let k = 0; k < T.length - m; k++)
            if (T[k] !== 0)
              throw new Error("base58xmr: wrong padding");
          v = v.concat(Array.from(T.slice(T.length - m)));
        }
        return Uint8Array.from(v);
      }
    };
    const x = (B) => n(d(4, (v) => B(B(v))), e.base58);
    e.base58check = x;
    const S = n(r("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), i("")), A = [996825010, 642813549, 513874426, 1027748829, 705979059];
    function R(B) {
      const v = B >> 25;
      let b = (B & 33554431) << 5;
      for (let E = 0; E < A.length; E++)
        (v >> E & 1) === 1 && (b ^= A[E]);
      return b;
    }
    function N(B, v, b = 1) {
      const E = B.length;
      let m = 1;
      for (let T = 0; T < E; T++) {
        const k = B.charCodeAt(T);
        if (k < 33 || k > 126)
          throw new Error(`Invalid prefix (${B})`);
        m = R(m) ^ k >> 5;
      }
      m = R(m);
      for (let T = 0; T < E; T++)
        m = R(m) ^ B.charCodeAt(T) & 31;
      for (let T of v)
        m = R(m) ^ T;
      for (let T = 0; T < 6; T++)
        m = R(m);
      return m ^= b, S.encode(l([m % 2 ** 30], 30, 5, !1));
    }
    function F(B) {
      const v = B === "bech32" ? 1 : 734539939, b = h(5), E = b.decode, m = b.encode, T = g(E);
      function k($, L, z = 90) {
        if (typeof $ != "string")
          throw new Error(`bech32.encode prefix should be string, not ${typeof $}`);
        if (!Array.isArray(L) || L.length && typeof L[0] != "number")
          throw new Error(`bech32.encode words should be array of numbers, not ${typeof L}`);
        const H = $.length + 7 + L.length;
        if (z !== !1 && H > z)
          throw new TypeError(`Length ${H} exceeds limit ${z}`);
        return $ = $.toLowerCase(), `${$}1${S.encode(L)}${N($, L, v)}`;
      }
      function P($, L = 90) {
        if (typeof $ != "string")
          throw new Error(`bech32.decode input should be string, not ${typeof $}`);
        if ($.length < 8 || L !== !1 && $.length > L)
          throw new TypeError(`Wrong string length: ${$.length} (${$}). Expected (8..${L})`);
        const z = $.toLowerCase();
        if ($ !== z && $ !== $.toUpperCase())
          throw new Error("String must be lowercase or uppercase");
        $ = z;
        const H = $.lastIndexOf("1");
        if (H === 0 || H === -1)
          throw new Error('Letter "1" must be present between prefix and data only');
        const _ = $.slice(0, H), j = $.slice(H + 1);
        if (j.length < 6)
          throw new Error("Data must be at least 6 characters long");
        const Y = S.decode(j).slice(0, -6), ot = N(_, Y, v);
        if (!j.endsWith(ot))
          throw new Error(`Invalid checksum in ${$}: expected "${ot}"`);
        return { prefix: _, words: Y };
      }
      const O = g(P);
      function I($) {
        const { prefix: L, words: z } = P($, !1);
        return { prefix: L, words: z, bytes: E(z) };
      }
      return { encode: k, decode: P, decodeToBytes: I, decodeUnsafe: O, fromWords: E, fromWordsUnsafe: T, toWords: m };
    }
    e.bech32 = F("bech32"), e.bech32m = F("bech32m"), e.utf8 = {
      encode: (B) => new TextDecoder().decode(B),
      decode: (B) => new TextEncoder().encode(B)
    }, e.hex = n(h(4), r("0123456789abcdef"), i(""), o((B) => {
      if (typeof B != "string" || B.length % 2)
        throw new TypeError(`hex.decode: expected string, got ${typeof B} with length ${B.length}`);
      return B.toLowerCase();
    }));
    const w = {
      utf8: e.utf8,
      hex: e.hex,
      base16: e.base16,
      base32: e.base32,
      base64: e.base64,
      base64url: e.base64url,
      base58: e.base58,
      base58xmr: e.base58xmr
    }, K = `Invalid encoding type. Available types: ${Object.keys(w).join(", ")}`, U = (B, v) => {
      if (typeof B != "string" || !w.hasOwnProperty(B))
        throw new TypeError(K);
      if (!(v instanceof Uint8Array))
        throw new TypeError("bytesToString() expects Uint8Array");
      return w[B].encode(v);
    };
    e.bytesToString = U, e.str = e.bytesToString;
    const W = (B, v) => {
      if (!w.hasOwnProperty(B))
        throw new TypeError(K);
      if (typeof v != "string")
        throw new TypeError("stringToBytes() expects string");
      return w[B].decode(v);
    };
    e.stringToBytes = W, e.bytes = e.stringToBytes;
  })(Xu)), Xu;
}
var Qu, ag;
function Jk() {
  if (ag) return Qu;
  ag = 1;
  const { bech32: e, hex: t, utf8: n } = Qk(), r = {
    // default network is bitcoin
    bech32: "bc",
    pubKeyHash: 0,
    scriptHash: 5,
    validWitnessVersions: [0]
  }, i = {
    bech32: "tb",
    pubKeyHash: 111,
    scriptHash: 196,
    validWitnessVersions: [0]
  }, s = {
    bech32: "tbs",
    pubKeyHash: 111,
    scriptHash: 196,
    validWitnessVersions: [0]
  }, o = {
    bech32: "bcrt",
    pubKeyHash: 111,
    scriptHash: 196,
    validWitnessVersions: [0]
  }, a = {
    bech32: "sb",
    pubKeyHash: 63,
    scriptHash: 123,
    validWitnessVersions: [0]
  }, c = [
    "option_data_loss_protect",
    "initial_routing_sync",
    "option_upfront_shutdown_script",
    "gossip_queries",
    "var_onion_optin",
    "gossip_queries_ex",
    "option_static_remotekey",
    "payment_secret",
    "basic_mpp",
    "option_support_large_channel"
  ], u = {
    m: BigInt(1e3),
    u: BigInt(1e6),
    n: BigInt(1e9),
    p: BigInt(1e12)
  }, l = BigInt("2100000000000000000"), f = BigInt(1e11), h = {
    payment_hash: 1,
    payment_secret: 16,
    description: 13,
    payee: 19,
    description_hash: 23,
    // commit to longer descriptions (used by lnurl-pay)
    expiry: 6,
    // default: 3600 (1 hour)
    min_final_cltv_expiry: 24,
    // default: 9
    fallback_address: 9,
    route_hint: 3,
    // for extra routing info (private etc.)
    feature_bits: 5,
    metadata: 27
  }, g = {};
  for (let N = 0, F = Object.keys(h); N < F.length; N++) {
    const w = F[N], K = h[F[N]].toString();
    g[K] = w;
  }
  const d = {
    1: (N) => t.encode(e.fromWordsUnsafe(N)),
    // 256 bits
    16: (N) => t.encode(e.fromWordsUnsafe(N)),
    // 256 bits
    13: (N) => n.encode(e.fromWordsUnsafe(N)),
    // string variable length
    19: (N) => t.encode(e.fromWordsUnsafe(N)),
    // 264 bits
    23: (N) => t.encode(e.fromWordsUnsafe(N)),
    // 256 bits
    27: (N) => t.encode(e.fromWordsUnsafe(N)),
    // variable
    6: y,
    // default: 3600 (1 hour)
    24: y,
    // default: 9
    3: x,
    // for extra routing info (private etc.)
    5: S
    // keep feature bits as array of 5 bit words
  };
  function p(N) {
    return (F) => ({
      tagCode: parseInt(N),
      words: e.encode("unknown", F, Number.MAX_SAFE_INTEGER)
    });
  }
  function y(N) {
    return N.reverse().reduce((F, w, K) => F + w * Math.pow(32, K), 0);
  }
  function x(N) {
    const F = [];
    let w, K, U, W, B, v = e.fromWordsUnsafe(N);
    for (; v.length > 0; )
      w = t.encode(v.slice(0, 33)), K = t.encode(v.slice(33, 41)), U = parseInt(t.encode(v.slice(41, 45)), 16), W = parseInt(
        t.encode(v.slice(45, 49)),
        16
      ), B = parseInt(t.encode(v.slice(49, 51)), 16), v = v.slice(51), F.push({
        pubkey: w,
        short_channel_id: K,
        fee_base_msat: U,
        fee_proportional_millionths: W,
        cltv_expiry_delta: B
      });
    return F;
  }
  function S(N) {
    const F = N.slice().reverse().map((U) => [
      !!(U & 1),
      !!(U & 2),
      !!(U & 4),
      !!(U & 8),
      !!(U & 16)
    ]).reduce((U, W) => U.concat(W), []);
    for (; F.length < c.length * 2; )
      F.push(!1);
    const w = {};
    c.forEach((U, W) => {
      let B;
      F[W * 2] ? B = "required" : F[W * 2 + 1] ? B = "supported" : B = "unsupported", w[U] = B;
    });
    const K = F.slice(c.length * 2);
    return w.extra_bits = {
      start_bit: c.length * 2,
      bits: K,
      has_required: K.reduce(
        (U, W, B) => B % 2 !== 0 ? U || !1 : U || W,
        !1
      )
    }, w;
  }
  function A(N, F) {
    let w, K;
    if (N.slice(-1).match(/^[munp]$/))
      w = N.slice(-1), K = N.slice(0, -1);
    else {
      if (N.slice(-1).match(/^[^munp0-9]$/))
        throw new Error("Not a valid multiplier for the amount");
      K = N;
    }
    if (!K.match(/^\d+$/))
      throw new Error("Not a valid human readable amount");
    const U = BigInt(K), W = w ? U * f / u[w] : U * f;
    if (w === "p" && U % BigInt(10) !== BigInt(0) || W > l)
      throw new Error("Amount is outside of valid range");
    return F ? W.toString() : W;
  }
  function R(N, F) {
    if (typeof N != "string")
      throw new Error("Lightning Payment Request must be string");
    if (N.slice(0, 2).toLowerCase() !== "ln")
      throw new Error("Not a proper lightning payment request");
    const w = [], K = e.decode(N, Number.MAX_SAFE_INTEGER);
    N = N.toLowerCase();
    const U = K.prefix;
    let W = K.words, B = N.slice(U.length + 1), v = W.slice(-104);
    W = W.slice(0, -104);
    let b = U.match(/^ln(\S+?)(\d*)([a-zA-Z]?)$/);
    if (b && !b[2] && (b = U.match(/^ln(\S+)$/)), !b)
      throw new Error("Not a proper lightning payment request");
    w.push({
      name: "lightning_network",
      letters: "ln"
    });
    const E = b[1];
    let m;
    if (F) {
      if (F.bech32 === void 0 || F.pubKeyHash === void 0 || F.scriptHash === void 0 || !Array.isArray(F.validWitnessVersions))
        throw new Error("Invalid network");
      m = F;
    } else
      switch (E) {
        case r.bech32:
          m = r;
          break;
        case i.bech32:
          m = i;
          break;
        case s.bech32:
          m = s;
          break;
        case o.bech32:
          m = o;
          break;
        case a.bech32:
          m = a;
          break;
      }
    if (!m || m.bech32 !== E)
      throw new Error("Unknown coin bech32 prefix");
    w.push({
      name: "coin_network",
      letters: E,
      value: m
    });
    const T = b[2];
    let k;
    if (T) {
      const _ = b[3];
      k = A(T + _, !0), w.push({
        name: "amount",
        letters: b[2] + b[3],
        value: k
      });
    } else
      k = null;
    w.push({
      name: "separator",
      letters: "1"
    });
    const P = y(W.slice(0, 7));
    W = W.slice(7), w.push({
      name: "timestamp",
      letters: B.slice(0, 7),
      value: P
    }), B = B.slice(7);
    let O, I, $, L;
    for (; W.length > 0; ) {
      const _ = W[0].toString();
      O = g[_] || "unknown_tag", I = d[_] || p(_), W = W.slice(1), $ = y(W.slice(0, 2)), W = W.slice(2), L = W.slice(0, $), W = W.slice($), w.push({
        name: O,
        tag: B[0],
        letters: B.slice(0, 3 + $),
        value: I(L)
        // see: parsers for more comments
      }), B = B.slice(3 + $);
    }
    w.push({
      name: "signature",
      letters: B.slice(0, 104),
      value: t.encode(e.fromWordsUnsafe(v))
    }), B = B.slice(104), w.push({
      name: "checksum",
      letters: B
    });
    let z = {
      paymentRequest: N,
      sections: w,
      get expiry() {
        let _ = w.find((j) => j.name === "expiry");
        if (_) return H("timestamp") + _.value;
      },
      get route_hints() {
        return w.filter((_) => _.name === "route_hint").map((_) => _.value);
      }
    };
    for (let _ in h)
      _ !== "route_hint" && Object.defineProperty(z, _, {
        get() {
          return H(_);
        }
      });
    return z;
    function H(_) {
      let j = w.find((Y) => Y.name === _);
      return j ? j.value : void 0;
    }
  }
  return Qu = {
    decode: R,
    hrpToMillisat: A
  }, Qu;
}
var tA = Jk();
const eA = /* @__PURE__ */ Bw(tA);
var Ju, cg;
function nA() {
  if (cg) return Ju;
  cg = 1;
  const e = 4294967295, t = 1 << 31, n = 9, r = 65535, i = 1 << 22, s = r, o = 1 << n, a = r << n;
  function c(l) {
    return l & t ? {} : l & i ? {
      seconds: (l & r) << n
    } : {
      blocks: l & r
    };
  }
  function u({ blocks: l, seconds: f }) {
    if (l !== void 0 && f !== void 0) throw new TypeError("Cannot encode blocks AND seconds");
    if (l === void 0 && f === void 0) return e;
    if (f !== void 0) {
      if (!Number.isFinite(f)) throw new TypeError("Expected Number seconds");
      if (f > a) throw new TypeError("Expected Number seconds <= " + a);
      if (f % o !== 0) throw new TypeError("Expected Number seconds as a multiple of " + o);
      return i | f >> n;
    }
    if (!Number.isFinite(l)) throw new TypeError("Expected Number blocks");
    if (l > r) throw new TypeError("Expected Number blocks <= " + s);
    return l;
  }
  return Ju = { decode: c, encode: u }, Ju;
}
var us = nA();
const rA = /* @__PURE__ */ Bw(us);
var Gt = class extends Error {
  isClaimable;
  isRefundable;
  pendingSwap;
  constructor(e = {}) {
    super(e.message ?? "Error during swap."), this.name = "SwapError", this.isClaimable = e.isClaimable ?? !1, this.isRefundable = e.isRefundable ?? !1, this.pendingSwap = e.pendingSwap;
  }
}, iA = class extends Gt {
  constructor(e) {
    super({ message: "The invoice has expired.", ...e }), this.name = "InvoiceExpiredError";
  }
}, sA = class extends Gt {
  constructor(e) {
    super({
      message: "The provider failed to pay the invoice",
      ...e
    }), this.name = "InvoiceFailedToPayError";
  }
}, Xr = class extends Error {
  statusCode;
  errorData;
  constructor(e, t, n) {
    super(e), this.name = "NetworkError", this.statusCode = t, this.errorData = n;
  }
}, ln = class extends Gt {
  constructor(e = {}) {
    super({ message: "Invalid API response", ...e }), this.name = "SchemaError";
  }
}, ug = class extends Gt {
  constructor(e) {
    super({ message: "The swap has expired", ...e }), this.name = "SwapExpiredError";
  }
}, lg = class extends Gt {
  constructor(e = {}) {
    super({ message: "The transaction has failed.", ...e }), this.name = "TransactionFailedError";
  }
}, oA = class extends Gt {
  constructor(e = {}) {
    super({ message: "The transaction lockup has failed.", ...e }), this.name = "TransactionLockupFailedError";
  }
}, aA = class extends Gt {
  constructor(e = {}) {
    super({ message: "The transaction has been refunded.", ...e }), this.name = "TransactionRefundedError";
  }
}, Eb = (e) => [
  "invoice.failedToPay",
  "transaction.claimed",
  "swap.expired"
].includes(e), xb = (e) => [
  "transaction.refunded",
  "transaction.failed",
  "invoice.settled",
  // normal status for completed swaps
  "swap.expired"
].includes(e), fg = (e) => ["transaction.mempool", "transaction.confirmed"].includes(e), Fs = (e) => e.type === "reverse", va = (e) => e.type === "submarine", dg = (e) => [
  "invoice.failedToPay",
  "transaction.lockupFailed",
  "swap.expired"
].includes(e), cA = (e) => e && typeof e == "object" && typeof e.id == "string" && typeof e.timeoutBlockHeight == "number", uA = (e) => e && typeof e == "object" && typeof e.status == "string" && (e.zeroConfRejected === void 0 || typeof e.zeroConfRejected == "boolean") && (e.transaction === void 0 || e.transaction && typeof e.transaction == "object" && typeof e.transaction.id == "string" && (e.transaction.eta === void 0 || typeof e.transaction.eta == "number") && (e.transaction.hex === void 0 || typeof e.transaction.hex == "string") && (e.transaction.preimage === void 0 || typeof e.transaction.preimage == "string")), hg = (e) => e && typeof e == "object" && e.ARK && typeof e.ARK == "object" && e.ARK.BTC && typeof e.ARK.BTC == "object" && typeof e.ARK.BTC.hash == "string" && typeof e.ARK.BTC.rate == "number" && e.ARK.BTC.limits && typeof e.ARK.BTC.limits == "object" && typeof e.ARK.BTC.limits.maximal == "number" && typeof e.ARK.BTC.limits.minimal == "number" && typeof e.ARK.BTC.limits.maximalZeroConf == "number" && e.ARK.BTC.fees && typeof e.ARK.BTC.fees == "object" && typeof e.ARK.BTC.fees.percentage == "number" && typeof e.ARK.BTC.fees.minerFees == "number", lA = (e) => e && typeof e == "object" && e.BTC && typeof e.BTC == "object" && e.BTC.ARK && typeof e.BTC.ARK == "object" && e.BTC.ARK.hash && typeof e.BTC.ARK.hash == "string" && typeof e.BTC.ARK.rate == "number" && e.BTC.ARK.limits && typeof e.BTC.ARK.limits == "object" && typeof e.BTC.ARK.limits.maximal == "number" && typeof e.BTC.ARK.limits.minimal == "number" && e.BTC.ARK.fees && typeof e.BTC.ARK.fees == "object" && typeof e.BTC.ARK.fees.percentage == "number" && typeof e.BTC.ARK.fees.minerFees == "object" && typeof e.BTC.ARK.fees.minerFees.claim == "number" && typeof e.BTC.ARK.fees.minerFees.lockup == "number", fA = (e) => e && typeof e == "object" && typeof e.id == "string" && typeof e.address == "string" && typeof e.expectedAmount == "number" && typeof e.claimPublicKey == "string" && typeof e.acceptZeroConf == "boolean" && e.timeoutBlockHeights && typeof e.timeoutBlockHeights == "object" && typeof e.timeoutBlockHeights.unilateralClaim == "number" && typeof e.timeoutBlockHeights.unilateralRefund == "number" && typeof e.timeoutBlockHeights.unilateralRefundWithoutReceiver == "number", dA = (e) => e && typeof e == "object" && typeof e.preimage == "string", hA = (e) => e && typeof e == "object" && typeof e.id == "string" && typeof e.invoice == "string" && typeof e.onchainAmount == "number" && typeof e.lockupAddress == "string" && typeof e.refundPublicKey == "string" && e.timeoutBlockHeights && typeof e.timeoutBlockHeights == "object" && typeof e.timeoutBlockHeights.refund == "number" && typeof e.timeoutBlockHeights.unilateralClaim == "number" && typeof e.timeoutBlockHeights.unilateralRefund == "number" && typeof e.timeoutBlockHeights.unilateralRefundWithoutReceiver == "number", pA = (e) => e && typeof e == "object" && typeof e.transaction == "string" && typeof e.checkpoint == "string", $i = (e) => e && typeof e == "object" && typeof e.version == "number" && typeof e.output == "string", gA = (e) => e && typeof e == "object" && $i(e.claimLeaf) && $i(e.refundLeaf) && $i(e.refundWithoutBoltzLeaf) && $i(e.unilateralClaimLeaf) && $i(e.unilateralRefundLeaf) && $i(e.unilateralRefundWithoutBoltzLeaf), Tb = (e) => e && typeof e == "object" && gA(e.tree) && (e.amount === void 0 || typeof e.amount == "number") && typeof e.keyIndex == "number" && (e.transaction === void 0 || e.transaction && typeof e.transaction == "object" && typeof e.transaction.id == "string" && typeof e.transaction.vout == "number") && typeof e.lockupAddress == "string" && typeof e.serverPublicKey == "string" && typeof e.timeoutBlockHeight == "number" && (e.preimageHash === void 0 || typeof e.preimageHash == "string"), Sb = (e) => e && typeof e == "object" && e.to === "BTC" && typeof e.id == "string" && e.from === "ARK" && e.type === "submarine" && typeof e.createdAt == "number" && typeof e.preimageHash == "string" && typeof e.status == "string" && Tb(e.refundDetails), vb = (e) => e && typeof e == "object" && e.to === "ARK" && typeof e.id == "string" && e.from === "BTC" && e.type === "reverse" && typeof e.createdAt == "number" && typeof e.preimageHash == "string" && typeof e.status == "string" && Tb(e.claimDetails), yA = (e) => Array.isArray(e) && e.every(
  (t) => vb(t) || Sb(t)
), wA = {
  mutinynet: "https://api.boltz.mutinynet.arkade.sh",
  regtest: "http://localhost:9069"
}, mA = class {
  wsUrl;
  apiUrl;
  network;
  referralId;
  constructor(e) {
    this.network = e.network;
    const t = e.apiUrl || wA[e.network];
    if (!t)
      throw new Error(
        `API URL is required for network: ${e.network}`
      );
    this.apiUrl = t, this.wsUrl = this.apiUrl.replace(/^http(s)?:\/\//, "ws$1://").replace("9069", "9004") + "/v2/ws";
  }
  getApiUrl() {
    return this.apiUrl;
  }
  getWsUrl() {
    return this.wsUrl;
  }
  getNetwork() {
    return this.network;
  }
  async getFees() {
    const [e, t] = await Promise.all([
      this.request(
        "/v2/swap/submarine",
        "GET"
      ),
      this.request("/v2/swap/reverse", "GET")
    ]);
    if (!hg(e))
      throw new ln({ message: "error fetching submarine fees" });
    if (!lA(t))
      throw new ln({ message: "error fetching reverse fees" });
    return {
      submarine: {
        percentage: e.ARK.BTC.fees.percentage,
        minerFees: e.ARK.BTC.fees.minerFees
      },
      reverse: {
        percentage: t.BTC.ARK.fees.percentage,
        minerFees: t.BTC.ARK.fees.minerFees
      }
    };
  }
  async getLimits() {
    const e = await this.request(
      "/v2/swap/submarine",
      "GET"
    );
    if (!hg(e))
      throw new ln({ message: "error fetching limits" });
    return {
      min: e.ARK.BTC.limits.minimal,
      max: e.ARK.BTC.limits.maximal
    };
  }
  async getReverseSwapTxId(e) {
    const t = await this.request(
      `/v2/swap/reverse/${e}/transaction`,
      "GET"
    );
    if (!cA(t))
      throw new ln({
        message: `error fetching txid for swap: ${e}`
      });
    return t;
  }
  async getSwapStatus(e) {
    const t = await this.request(
      `/v2/swap/${e}`,
      "GET"
    );
    if (!uA(t))
      throw new ln({
        message: `error fetching status for swap: ${e}`
      });
    return t;
  }
  async getSwapPreimage(e) {
    const t = await this.request(
      `/v2/swap/submarine/${e}/preimage`,
      "GET"
    );
    if (!dA(t))
      throw new ln({
        message: `error fetching preimage for swap: ${e}`
      });
    return t;
  }
  async createSubmarineSwap({
    invoice: e,
    refundPublicKey: t
  }) {
    if (t.length != 66)
      throw new Gt({
        message: "refundPublicKey must be a compressed public key"
      });
    const n = {
      from: "ARK",
      to: "BTC",
      invoice: e,
      refundPublicKey: t,
      ...this.referralId ? { referralId: this.referralId } : {}
    }, r = await this.request(
      "/v2/swap/submarine",
      "POST",
      n
    );
    if (!fA(r))
      throw new ln({ message: "Error creating submarine swap" });
    return r;
  }
  async createReverseSwap({
    invoiceAmount: e,
    claimPublicKey: t,
    preimageHash: n,
    description: r
  }) {
    if (t.length != 66)
      throw new Gt({
        message: "claimPublicKey must be a compressed public key"
      });
    const i = {
      from: "BTC",
      to: "ARK",
      invoiceAmount: e,
      claimPublicKey: t,
      preimageHash: n,
      ...r?.trim() ? { description: r.trim() } : {},
      ...this.referralId ? { referralId: this.referralId } : {}
    }, s = await this.request(
      "/v2/swap/reverse",
      "POST",
      i
    );
    if (!hA(s))
      throw new ln({ message: "Error creating reverse swap" });
    return s;
  }
  async refundSubmarineSwap(e, t, n) {
    const r = {
      checkpoint: ut.encode(n.toPSBT()),
      transaction: ut.encode(t.toPSBT())
    }, i = await this.request(
      `/v2/swap/submarine/${e}/refund/ark`,
      "POST",
      r
    );
    if (!pA(i))
      throw new ln({
        message: "Error refunding submarine swap"
      });
    return {
      transaction: Re.fromPSBT(
        ut.decode(i.transaction)
      ),
      checkpoint: Re.fromPSBT(
        ut.decode(i.checkpoint)
      )
    };
  }
  async monitorSwap(e, t) {
    return new Promise((n, r) => {
      const i = new globalThis.WebSocket(this.wsUrl), s = setTimeout(() => {
        i.close(), r(new Xr("WebSocket connection timeout"));
      }, 3e4);
      i.onerror = (o) => {
        clearTimeout(s), r(
          new Xr(
            `WebSocket error: ${o.message}`
          )
        );
      }, i.onopen = () => {
        clearTimeout(s), i.send(
          JSON.stringify({
            op: "subscribe",
            channel: "swap.update",
            args: [e]
          })
        );
      }, i.onclose = () => {
        clearTimeout(s), n();
      }, i.onmessage = async (o) => {
        const a = JSON.parse(o.data);
        if (a.event !== "update" || a.args[0].id !== e) return;
        a.args[0].error && (i.close(), r(new Gt({ message: a.args[0].error })));
        const c = a.args[0].status;
        switch (c) {
          case "invoice.settled":
          case "transaction.claimed":
          case "transaction.refunded":
          case "invoice.expired":
          case "invoice.failedToPay":
          case "transaction.failed":
          case "transaction.lockupFailed":
          case "swap.expired":
            i.close(), t(c);
            break;
          case "invoice.paid":
          case "invoice.pending":
          case "invoice.set":
          case "swap.created":
          case "transaction.claim.pending":
          case "transaction.confirmed":
          case "transaction.mempool":
            t(c);
        }
      };
    });
  }
  async restoreSwaps(e) {
    const t = {
      publicKey: e
    }, n = await this.request(
      "/v2/swap/restore",
      "POST",
      t
    );
    if (!yA(n))
      throw new ln({
        message: "Invalid schema in response for swap restoration"
      });
    return n;
  }
  async request(e, t, n) {
    const r = `${this.apiUrl}${e}`;
    try {
      const i = await globalThis.fetch(r, {
        method: t,
        headers: { "Content-Type": "application/json" },
        body: n ? JSON.stringify(n) : void 0
      });
      if (!i.ok) {
        const s = await i.text();
        let o;
        try {
          o = JSON.parse(s);
        } catch {
        }
        const a = `Boltz API error: ${i.status} ${s}`;
        throw new Xr(a, i.status, o);
      }
      if (i.headers.get("content-length") === "0")
        throw new Xr("Empty response from Boltz API");
      return await i.json();
    } catch (i) {
      throw i instanceof Xr ? i : new Xr(
        `Request to ${r} failed: ${i.message}`
      );
    }
  }
}, cf = (e) => {
  const t = eA.decode(e), n = Number(
    t.sections.find((r) => r.name === "amount")?.value ?? "0"
  );
  return {
    expiry: t.expiry ?? 3600,
    amountSats: Math.floor(n / 1e3),
    description: t.sections.find((r) => r.name === "description")?.value ?? "",
    paymentHash: t.sections.find((r) => r.name === "payment_hash")?.value ?? ""
  };
}, bA = (e) => cf(e).paymentHash, tl = (e, t, n) => {
  try {
    return TS(e, t, n), !0;
  } catch {
    return !1;
  }
};
function ur(e) {
  if (!e) return 0;
  try {
    const t = et.decode(C.decode(e)), n = t.findIndex((i) => i === "CHECKLOCKTIMEVERIFY");
    if (n > 0) {
      const i = t[n - 1];
      if (i instanceof Uint8Array) {
        const s = new Uint8Array(i).reverse();
        return parseInt(C.encode(s), 16);
      }
    }
    const r = t.findIndex((i) => i === "CHECKSEQUENCEVERIFY");
    if (r > 0) {
      const i = t[r - 1];
      if (i instanceof Uint8Array) {
        const s = new Uint8Array(i).reverse(), {
          blocks: o,
          seconds: a
        } = rA.decode(
          parseInt(C.encode(s), 16)
        );
        return o ?? a ?? 0;
      }
    }
  } catch {
    return 0;
  }
  return 0;
}
function EA(e, t) {
  if (!e) return 0;
  const { percentage: n, minerFees: r } = t.reverse, i = r.lockup + r.claim;
  return n >= 100 || n < 0 || i >= e ? 0 : Math.ceil((e - i) / (1 - n / 100));
}
var rt = console, xA = class {
  swapProvider;
  config;
  // Event listeners storage (supports multiple listeners per event)
  swapUpdateListeners = /* @__PURE__ */ new Set();
  swapCompletedListeners = /* @__PURE__ */ new Set();
  swapFailedListeners = /* @__PURE__ */ new Set();
  actionExecutedListeners = /* @__PURE__ */ new Set();
  wsConnectedListeners = /* @__PURE__ */ new Set();
  wsDisconnectedListeners = /* @__PURE__ */ new Set();
  // State
  websocket = null;
  monitoredSwaps = /* @__PURE__ */ new Map();
  initialSwaps = /* @__PURE__ */ new Map();
  // All swaps passed to start(), including completed ones
  pollTimer = null;
  reconnectTimer = null;
  isRunning = !1;
  currentReconnectDelay;
  currentPollRetryDelay;
  usePollingFallback = !1;
  isReconnecting = !1;
  // Race condition prevention
  swapsInProgress = /* @__PURE__ */ new Set();
  // Per-swap subscriptions for UI hooks
  swapSubscriptions = /* @__PURE__ */ new Map();
  // Callbacks for actions (injected by ArkadeLightning)
  claimCallback = null;
  refundCallback = null;
  saveSwapCallback = null;
  constructor(e, t = {}) {
    this.swapProvider = e, this.config = {
      enableAutoActions: t.enableAutoActions ?? !0,
      pollInterval: t.pollInterval ?? 3e4,
      reconnectDelayMs: t.reconnectDelayMs ?? 1e3,
      maxReconnectDelayMs: t.maxReconnectDelayMs ?? 6e4,
      pollRetryDelayMs: t.pollRetryDelayMs ?? 5e3,
      maxPollRetryDelayMs: t.maxPollRetryDelayMs ?? 3e5,
      events: t.events ?? {}
    }, t.events?.onSwapUpdate && this.swapUpdateListeners.add(t.events.onSwapUpdate), t.events?.onSwapCompleted && this.swapCompletedListeners.add(t.events.onSwapCompleted), t.events?.onSwapFailed && this.swapFailedListeners.add(t.events.onSwapFailed), t.events?.onActionExecuted && this.actionExecutedListeners.add(t.events.onActionExecuted), t.events?.onWebSocketConnected && this.wsConnectedListeners.add(t.events.onWebSocketConnected), t.events?.onWebSocketDisconnected && this.wsDisconnectedListeners.add(
      t.events.onWebSocketDisconnected
    ), this.currentReconnectDelay = this.config.reconnectDelayMs, this.currentPollRetryDelay = this.config.pollRetryDelayMs;
  }
  /**
   * Set callbacks for claim, refund, and save operations
   * These are called by the manager when autonomous actions are needed
   */
  setCallbacks(e) {
    this.claimCallback = e.claim, this.refundCallback = e.refund, this.saveSwapCallback = e.saveSwap;
  }
  /**
   * Add an event listener for swap updates
   * @returns Unsubscribe function
   */
  async onSwapUpdate(e) {
    return this.swapUpdateListeners.add(e), () => this.swapUpdateListeners.delete(e);
  }
  /**
   * Add an event listener for swap completion
   * @returns Unsubscribe function
   */
  async onSwapCompleted(e) {
    return this.swapCompletedListeners.add(e), () => this.swapCompletedListeners.delete(e);
  }
  /**
   * Add an event listener for swap failures
   * @returns Unsubscribe function
   */
  async onSwapFailed(e) {
    return this.swapFailedListeners.add(e), () => this.swapFailedListeners.delete(e);
  }
  /**
   * Add an event listener for executed actions (claim/refund)
   * @returns Unsubscribe function
   */
  async onActionExecuted(e) {
    return this.actionExecutedListeners.add(e), () => this.actionExecutedListeners.delete(e);
  }
  /**
   * Add an event listener for WebSocket connection
   * @returns Unsubscribe function
   */
  async onWebSocketConnected(e) {
    return this.wsConnectedListeners.add(e), () => this.wsConnectedListeners.delete(e);
  }
  /**
   * Add an event listener for WebSocket disconnection
   * @returns Unsubscribe function
   */
  async onWebSocketDisconnected(e) {
    return this.wsDisconnectedListeners.add(e), () => this.wsDisconnectedListeners.delete(e);
  }
  /**
   * Start the swap manager
   * This will:
   * 1. Load pending swaps
   * 2. Connect WebSocket (with fallback to polling)
   * 3. Poll all swaps after connection
   * 4. Resume any actionable swaps
   */
  async start(e) {
    if (this.isRunning) {
      rt.warn("SwapManager is already running");
      return;
    }
    this.isRunning = !0, this.initialSwaps.clear();
    for (const t of e)
      this.initialSwaps.set(t.id, t);
    for (const t of e)
      this.isFinalStatus(t.status) || this.monitoredSwaps.set(t.id, t);
    rt.log(
      `SwapManager started with ${this.monitoredSwaps.size} pending swaps`
    ), await this.connectWebSocket(), await this.resumeActionableSwaps();
  }
  /**
   * Stop the swap manager
   * Cleanup: close WebSocket, stop all timers
   */
  async stop() {
    this.isRunning && (this.isRunning = !1, this.websocket && (this.websocket.close(), this.websocket = null), this.pollTimer && (clearTimeout(this.pollTimer), this.pollTimer = null), this.reconnectTimer && (clearTimeout(this.reconnectTimer), this.reconnectTimer = null), rt.log("SwapManager stopped"));
  }
  /**
   * Add a new swap to monitoring
   */
  async addSwap(e) {
    this.monitoredSwaps.set(e.id, e), this.websocket && this.websocket.readyState === WebSocket.OPEN && this.subscribeToSwap(e.id), rt.log(`Added swap ${e.id} to monitoring`);
  }
  /**
   * Remove a swap from monitoring
   */
  async removeSwap(e) {
    this.monitoredSwaps.delete(e), this.swapSubscriptions.delete(e), rt.log(`Removed swap ${e} from monitoring`);
  }
  /**
   * Get all currently monitored swaps
   */
  async getPendingSwaps() {
    return Array.from(this.monitoredSwaps.values());
  }
  /**
   * Subscribe to updates for a specific swap
   * Returns an unsubscribe function
   * Useful for UI components that need to track specific swap progress
   */
  async subscribeToSwapUpdates(e, t) {
    this.swapSubscriptions.has(e) || this.swapSubscriptions.set(e, /* @__PURE__ */ new Set());
    const n = this.swapSubscriptions.get(e);
    return n.add(t), () => {
      n.delete(t), n.size === 0 && this.swapSubscriptions.delete(e);
    };
  }
  /**
   * Wait for a specific swap to complete
   * This blocks until the swap reaches a final status or fails
   * Useful when you want blocking behavior even with SwapManager enabled
   */
  async waitForSwapCompletion(e) {
    let t = this.monitoredSwaps.get(e);
    if (!t && (t = this.initialSwaps.get(e), !t))
      throw new Error(`Swap ${e} not found in manager`);
    if (this.isFinalStatus(t.status)) {
      if (Fs(t))
        return { txid: (await this.swapProvider.getReverseSwapTxId(
          t.id
        )).id };
      throw new Error("Submarine swap already completed");
    }
    return new Promise((n, r) => {
      let i = null;
      const s = (o, a) => {
        this.isFinalStatus(o.status) && (i?.(), Fs(o) ? o.status === "invoice.settled" ? this.swapProvider.getReverseSwapTxId(o.id).then((c) => n({ txid: c.id })).catch((c) => r(c)) : r(
          new Error(
            `Swap failed with status: ${o.status}`
          )
        ) : va(o) && (o.status === "transaction.claimed" ? n({ txid: o.id }) : r(
          new Error(
            `Swap failed with status: ${o.status}`
          )
        )));
      };
      this.subscribeToSwapUpdates(e, s).then((o) => {
        i = o;
      }).catch(r);
    });
  }
  /**
   * Check if a swap is currently being processed
   * Useful for preventing race conditions
   */
  async isProcessing(e) {
    return this.swapsInProgress.has(e);
  }
  /**
   * Check if manager has a specific swap
   */
  async hasSwap(e) {
    return this.monitoredSwaps.has(e);
  }
  /**
   * Connect to WebSocket for real-time swap updates
   * Falls back to polling if connection fails
   */
  async connectWebSocket() {
    if (!this.isReconnecting) {
      this.isReconnecting = !0;
      try {
        const e = this.swapProvider.getWsUrl();
        this.websocket = new globalThis.WebSocket(e);
        const t = setTimeout(() => {
          rt.error("WebSocket connection timeout"), this.websocket?.close(), this.handleWebSocketFailure();
        }, 1e4);
        this.websocket.onerror = (n) => {
          clearTimeout(t), rt.error("WebSocket error:", n), this.handleWebSocketFailure();
        }, this.websocket.onopen = () => {
          clearTimeout(t), rt.log("WebSocket connected"), this.currentReconnectDelay = this.config.reconnectDelayMs, this.usePollingFallback = !1, this.isReconnecting = !1;
          for (const n of this.monitoredSwaps.keys())
            this.subscribeToSwap(n);
          this.pollAllSwaps(), this.startPolling(), this.wsConnectedListeners.forEach((n) => n());
        }, this.websocket.onclose = () => {
          clearTimeout(t), rt.log("WebSocket disconnected"), this.websocket = null, this.isRunning && this.scheduleReconnect(), this.wsDisconnectedListeners.forEach((n) => n());
        }, this.websocket.onmessage = async (n) => {
          await this.handleWebSocketMessage(n);
        };
      } catch (e) {
        rt.error("Failed to create WebSocket:", e), this.handleWebSocketFailure();
      }
    }
  }
  /**
   * Handle WebSocket connection failure
   * Falls back to polling-only mode with exponential backoff
   */
  handleWebSocketFailure() {
    this.isReconnecting = !1, this.websocket = null, this.usePollingFallback = !0, rt.warn(
      "WebSocket unavailable, using polling fallback with increasing interval"
    ), this.startPollingFallback();
    const e = new Xr("WebSocket connection failed");
    this.wsDisconnectedListeners.forEach((t) => t(e));
  }
  /**
   * Schedule WebSocket reconnection with exponential backoff
   */
  scheduleReconnect() {
    this.reconnectTimer || (rt.log(
      `Scheduling WebSocket reconnect in ${this.currentReconnectDelay}ms`
    ), this.reconnectTimer = setTimeout(() => {
      this.reconnectTimer = null, this.isReconnecting = !1, this.connectWebSocket();
    }, this.currentReconnectDelay), this.currentReconnectDelay = Math.min(
      this.currentReconnectDelay * 2,
      this.config.maxReconnectDelayMs
    ));
  }
  /**
   * Subscribe to a specific swap ID on the WebSocket
   */
  subscribeToSwap(e) {
    !this.websocket || this.websocket.readyState !== WebSocket.OPEN || this.websocket.send(
      JSON.stringify({
        op: "subscribe",
        channel: "swap.update",
        args: [e]
      })
    );
  }
  /**
   * Handle incoming WebSocket message
   */
  async handleWebSocketMessage(e) {
    try {
      const t = JSON.parse(e.data);
      if (t.event !== "update") return;
      const n = t.args[0]?.id;
      if (!n) return;
      const r = this.monitoredSwaps.get(n);
      if (!r) return;
      if (t.args[0].error) {
        rt.error(`Swap ${n} error:`, t.args[0].error);
        const s = new Error(t.args[0].error);
        this.swapFailedListeners.forEach(
          (o) => o(r, s)
        );
        return;
      }
      const i = t.args[0].status;
      await this.handleSwapStatusUpdate(r, i);
    } catch (t) {
      rt.error("Error handling WebSocket message:", t);
    }
  }
  /**
   * Handle status update for a swap
   * This is the core logic that determines what actions to take
   */
  async handleSwapStatusUpdate(e, t) {
    const n = e.status;
    if (n === t) return;
    e.status = t, rt.log(`Swap ${e.id} status: ${n} ‚Üí ${t}`), this.swapUpdateListeners.forEach(
      (i) => i(e, n)
    );
    const r = this.swapSubscriptions.get(e.id);
    r && r.forEach((i) => {
      try {
        i(e, n);
      } catch (s) {
        rt.error(
          `Error in swap subscription callback for ${e.id}:`,
          s
        );
      }
    }), await this.saveSwap(e), this.config.enableAutoActions && await this.executeAutonomousAction(e), this.isFinalStatus(t) && (this.monitoredSwaps.delete(e.id), this.swapSubscriptions.delete(e.id), this.swapCompletedListeners.forEach((i) => i(e)), rt.log(`Swap ${e.id} completed with status: ${t}`));
  }
  /**
   * Execute autonomous action based on swap status
   * Uses locking to prevent race conditions with manual operations
   */
  async executeAutonomousAction(e) {
    if (this.swapsInProgress.has(e.id)) {
      rt.log(
        `Swap ${e.id} is already being processed, skipping autonomous action`
      );
      return;
    }
    try {
      if (this.swapsInProgress.add(e.id), Fs(e)) {
        if (!e.preimage || e.preimage.length === 0) {
          rt.log(
            `Skipping claim for swap ${e.id}: missing preimage (restored swap)`
          );
          return;
        }
        fg(e.status) && (rt.log(`Auto-claiming reverse swap ${e.id}`), await this.executeClaimAction(e), this.actionExecutedListeners.forEach(
          (t) => t(e, "claim")
        ));
      } else if (va(e)) {
        if (!e.request?.invoice || e.request.invoice.length === 0) {
          rt.log(
            `Skipping refund for swap ${e.id}: missing invoice (restored swap)`
          );
          return;
        }
        dg(e.status) && (rt.log(`Auto-refunding submarine swap ${e.id}`), await this.executeRefundAction(e), this.actionExecutedListeners.forEach(
          (t) => t(e, "refund")
        ));
      }
    } catch (t) {
      rt.error(
        `Failed to execute autonomous action for swap ${e.id}:`,
        t
      ), this.swapFailedListeners.forEach(
        (n) => n(e, t)
      );
    } finally {
      this.swapsInProgress.delete(e.id);
    }
  }
  /**
   * Execute claim action for reverse swap
   */
  async executeClaimAction(e) {
    if (!this.claimCallback) {
      rt.error("Claim callback not set");
      return;
    }
    await this.claimCallback(e);
  }
  /**
   * Execute refund action for submarine swap
   */
  async executeRefundAction(e) {
    if (!this.refundCallback) {
      rt.error("Refund callback not set");
      return;
    }
    await this.refundCallback(e);
  }
  /**
   * Save swap to storage
   */
  async saveSwap(e) {
    if (!this.saveSwapCallback) {
      rt.error("Save swap callback not set");
      return;
    }
    await this.saveSwapCallback(e);
  }
  /**
   * Resume actionable swaps on startup
   * This checks all pending swaps and executes actions if needed
   */
  async resumeActionableSwaps() {
    if (this.config.enableAutoActions) {
      rt.log("Resuming actionable swaps...");
      for (const e of this.monitoredSwaps.values())
        try {
          Fs(e) && fg(e.status) ? (rt.log(`Resuming claim for swap ${e.id}`), await this.executeAutonomousAction(e)) : va(e) && dg(e.status) && (rt.log(`Resuming refund for swap ${e.id}`), await this.executeAutonomousAction(e));
        } catch (t) {
          rt.error(`Failed to resume swap ${e.id}:`, t);
        }
    }
  }
  /**
   * Start regular polling
   * Polls all swaps at configured interval when WebSocket is active
   */
  startPolling() {
    this.pollTimer && clearTimeout(this.pollTimer), this.pollTimer = setTimeout(async () => {
      await this.pollAllSwaps(), this.isRunning && this.startPolling();
    }, this.config.pollInterval);
  }
  /**
   * Start polling fallback when WebSocket is unavailable
   * Uses exponential backoff for retry delay
   */
  startPollingFallback() {
    this.pollTimer && clearTimeout(this.pollTimer), this.pollTimer = setTimeout(async () => {
      await this.pollAllSwaps(), this.currentPollRetryDelay = Math.min(
        this.currentPollRetryDelay * 2,
        this.config.maxPollRetryDelayMs
      ), this.isRunning && this.usePollingFallback && this.startPollingFallback();
    }, this.currentPollRetryDelay), rt.log(`Next polling fallback in ${this.currentPollRetryDelay}ms`);
  }
  /**
   * Poll all monitored swaps for status updates
   * This is called:
   * 1. After WebSocket connects
   * 2. After WebSocket reconnects
   * 3. Periodically while WebSocket is active
   * 4. As fallback when WebSocket is unavailable
   */
  async pollAllSwaps() {
    if (this.monitoredSwaps.size === 0) return;
    rt.log(`Polling ${this.monitoredSwaps.size} swaps...`);
    const e = Array.from(this.monitoredSwaps.values()).map(
      async (t) => {
        try {
          const n = await this.swapProvider.getSwapStatus(t.id);
          n.status !== t.status && await this.handleSwapStatusUpdate(
            t,
            n.status
          );
        } catch (n) {
          rt.error(`Failed to poll swap ${t.id}:`, n);
        }
      }
    );
    await Promise.allSettled(e);
  }
  /**
   * Check if a status is final (no more updates expected)
   */
  isFinalStatus(e) {
    return xb(e) || Eb(e);
  }
  /**
   * Get current manager statistics (for debugging/monitoring)
   */
  async getStats() {
    return {
      isRunning: this.isRunning,
      monitoredSwaps: this.monitoredSwaps.size,
      websocketConnected: this.websocket !== null && this.websocket.readyState === WebSocket.OPEN,
      usePollingFallback: this.usePollingFallback,
      currentReconnectDelay: this.currentReconnectDelay,
      currentPollRetryDelay: this.currentPollRetryDelay
    };
  }
};
function TA(e, t) {
  return {
    ...e,
    sign: async (n, r) => {
      const i = n.clone();
      let s = await e.sign(i, r);
      if (s = Re.fromPSBT(s.toPSBT()), t)
        for (const o of r || Array.from(
          { length: s.inputsLength },
          (a, c) => c
        ))
          Cw(s, o, Rw, [
            t
          ]);
      return s;
    }
  };
}
function SA(e, t, n, r, i, s, o, a = 0) {
  const c = new TextEncoder().encode(e), u = Bt(c), l = C.encode(u);
  let f;
  return {
    onBatchStarted: async (h) => {
      let g = !0;
      for (const p of h.intentIdHashes)
        if (p === l) {
          if (!n)
            throw new Error("Ark provider not configured");
          await n.confirmRegistration(e), g = !1;
        }
      if (g)
        return { skip: g };
      const d = Yt.encode({
        timelock: {
          value: h.batchExpiry,
          type: h.batchExpiry >= 512n ? "seconds" : "blocks"
        },
        pubkeys: [s]
      }).script;
      return f = Ki(d), { skip: !1 };
    },
    onTreeSigningStarted: async (h, g) => {
      if (!i)
        return { skip: !0 };
      if (!f)
        throw new Error("Sweep tap tree root not set");
      const d = h.cosignersPublicKeys.map(
        (N) => N.slice(2)
      ), y = (await i.getPublicKey()).subarray(1);
      if (!d.includes(C.encode(y)))
        return { skip: !0 };
      const x = Re.fromPSBT(
        ut.decode(h.unsignedCommitmentTx)
      );
      Mw(g, x, f);
      const S = x.getOutput(0);
      if (!S?.amount)
        throw new Error("Shared output not found");
      await i.init(g, f, S.amount);
      const A = C.encode(await i.getPublicKey()), R = await i.getNonces();
      return await n.submitTreeNonces(h.id, A, R), { skip: !1 };
    },
    onTreeNonces: async (h) => {
      if (!i)
        return { fullySigned: !0 };
      const { hasAllNonces: g } = await i.aggregatedNonces(
        h.txid,
        h.nonces
      );
      if (!g) return { fullySigned: !1 };
      const d = await i.sign(), p = C.encode(await i.getPublicKey());
      return await n.submitTreeSignatures(
        h.id,
        p,
        d
      ), { fullySigned: !0 };
    },
    onBatchFinalization: async (h, g, d) => {
      if (!o)
        return;
      if (!d)
        throw new Error(
          "BatchFinalizationEvent: expected connector tree to be defined"
        );
      Vw(h.commitmentTx, d);
      const p = d.leaves();
      if (p.length <= a)
        throw new Error(
          `BatchFinalizationEvent: expected connector tree has ${p.length} leaves, expected at least ${a + 1}`
        );
      const y = vA(
        t,
        o,
        p[a]
      ), x = await r.sign(y);
      await n.submitSignedForfeitTxs([
        ut.encode(x.toPSBT())
      ]);
    }
  };
}
function vA(e, t, n) {
  const r = n.id, i = n.getOutput(0);
  if (!i)
    throw new Error("connector output not found");
  const s = i.amount, o = i.script;
  if (!s || !o)
    throw new Error("invalid connector output");
  const a = dd(e.tapLeafScript);
  return Dw(
    [
      {
        txid: e.txid,
        index: e.vout,
        witnessUtxo: {
          amount: BigInt(e.value),
          script: Pe.decode(e.tapTree).pkScript
        },
        sighashType: _r.DEFAULT,
        tapLeafScript: [e.tapLeafScript],
        sequence: a
      },
      {
        txid: r,
        index: 0,
        witnessUtxo: {
          amount: s,
          script: o
        }
      }
    ],
    t,
    a
  );
}
var kA = "arkade-boltz-swap", AA = 2, yn = "swaps";
function $A(e) {
  if (!e.objectStoreNames.contains(yn)) {
    const t = e.createObjectStore(yn, {
      keyPath: "id"
    });
    t.createIndex("status", "status", { unique: !1 }), t.createIndex("type", "type", { unique: !1 }), t.createIndex("createdAt", "createdAt", { unique: !1 });
  }
}
var kb = class {
  constructor(e = kA) {
    this.dbName = e;
  }
  db = null;
  async getDB() {
    return this.db ? this.db : (this.db = await ld(this.dbName, AA, $A), this.db);
  }
  async saveSwap(e) {
    const t = await this.getDB();
    return new Promise((n, r) => {
      const o = t.transaction(
        [yn],
        "readwrite"
      ).objectStore(yn).put(e);
      o.onsuccess = () => n(), o.onerror = () => r(o.error);
    });
  }
  async deleteSwap(e) {
    const t = await this.getDB();
    return new Promise((n, r) => {
      const o = t.transaction(
        [yn],
        "readwrite"
      ).objectStore(yn).delete(e);
      o.onsuccess = () => n(), o.onerror = () => r(o.error);
    });
  }
  async getAllSwaps(e) {
    return this.getAllSwapsFromStore(e);
  }
  async clear() {
    const e = await this.getDB();
    return new Promise((t, n) => {
      const s = e.transaction(
        [yn],
        "readwrite"
      ).objectStore(yn).clear();
      s.onsuccess = () => t(), s.onerror = () => n(s.error);
    });
  }
  getSwapsByIndexValues(e, t, n) {
    if (n.length === 0) return Promise.resolve([]);
    const r = e.index(t), i = n.map(
      (s) => new Promise((o, a) => {
        const c = r.getAll(s);
        c.onerror = () => a(c.error), c.onsuccess = () => o(c.result ?? []);
      })
    );
    return Promise.all(i).then(
      (s) => s.flatMap((o) => o)
    );
  }
  async getAllSwapsFromStore(e) {
    const n = (await this.getDB()).transaction([yn], "readonly").objectStore(yn);
    if (!e || Object.keys(e).length === 0)
      return new Promise((s, o) => {
        const a = n.getAll();
        a.onsuccess = () => s(a.result ?? []), a.onerror = () => o(a.error);
      });
    const r = OA(e);
    if (r.has("id")) {
      const s = r.get("id"), o = await Promise.all(
        s.map(
          (a) => new Promise((c, u) => {
            const l = n.get(a);
            l.onsuccess = () => c(l.result), l.onerror = () => u(l.error);
          })
        )
      );
      return this.sortIfNeeded(
        this.applySwapsFilter(o, r),
        e
      );
    }
    if (r.has("type")) {
      const s = r.get("type"), o = await this.getSwapsByIndexValues(
        n,
        "type",
        s
      );
      return this.sortIfNeeded(
        this.applySwapsFilter(o, r),
        e
      );
    }
    if (r.has("status")) {
      const s = r.get("status"), o = await this.getSwapsByIndexValues(
        n,
        "status",
        s
      );
      return this.sortIfNeeded(
        this.applySwapsFilter(o, r),
        e
      );
    }
    if (e.orderBy === "createdAt")
      return this.getAllSwapsByCreatedAt(n, e.orderDirection);
    const i = await new Promise((s, o) => {
      const a = n.getAll();
      a.onsuccess = () => s(a.result ?? []), a.onerror = () => o(a.error);
    });
    return this.sortIfNeeded(
      this.applySwapsFilter(i, r),
      e
    );
  }
  applySwapsFilter(e, t) {
    return e.filter((n) => !(n === void 0 || t.has("id") && !t.get("id")?.includes(n.id) || t.has("status") && !t.get("status")?.includes(n.status) || t.has("type") && !t.get("type")?.includes(n.type)));
  }
  async getAllSwapsByCreatedAt(e, t) {
    const n = e.index("createdAt"), r = t === "desc" ? "prev" : "next";
    return new Promise((i, s) => {
      const o = [], a = n.openCursor(null, r);
      a.onerror = () => s(a.error), a.onsuccess = () => {
        const c = a.result;
        if (!c) {
          i(o);
          return;
        }
        o.push(c.value), c.continue();
      };
    });
  }
  sortIfNeeded(e, t) {
    if (t?.orderBy !== "createdAt") return e;
    const n = t.orderDirection === "asc" ? 1 : -1;
    return e.slice().sort((r, i) => (r.createdAt - i.createdAt) * n);
  }
  async [Symbol.asyncDispose]() {
    this.db && (await fd(this.dbName), this.db = null);
  }
}, IA = ["id", "status", "type"];
function OA(e) {
  const t = /* @__PURE__ */ new Map();
  return IA.forEach((n) => {
    e?.[n] && (Array.isArray(e[n]) ? t.set(n, e[n]) : t.set(n, [e[n]]));
  }), t;
}
function Nn(e, t, n) {
  if (e.length === 33)
    return e.slice(1);
  if (e.length !== 32)
    throw new Error(
      `Invalid ${t} public key length: ${e.length} ${n ? "for swap " + n : ""}`
    );
  return e;
}
var BA = class {
  wallet;
  arkProvider;
  swapProvider;
  indexerProvider;
  swapManager = null;
  swapRepository;
  constructor(e) {
    if (!e.wallet) throw new Error("Wallet is required.");
    if (!e.swapProvider) throw new Error("Swap provider is required.");
    this.wallet = e.wallet;
    const t = e.wallet.arkProvider ?? e.arkProvider;
    if (!t)
      throw new Error(
        "Ark provider is required either in wallet or config."
      );
    this.arkProvider = t;
    const n = e.wallet.indexerProvider ?? e.indexerProvider;
    if (!n)
      throw new Error(
        "Indexer provider is required either in wallet or config."
      );
    if (this.indexerProvider = n, this.swapProvider = e.swapProvider, e.swapRepository ? this.swapRepository = e.swapRepository : this.swapRepository = new kb(), e.swapManager) {
      const r = e.swapManager === !0 ? {} : e.swapManager, i = r.autoStart ?? !0;
      this.swapManager = new xA(
        this.swapProvider,
        r
      ), this.swapManager.setCallbacks({
        claim: async (s) => {
          await this.claimVHTLC(s);
        },
        refund: async (s) => {
          await this.refundVHTLC(s);
        },
        saveSwap: async (s) => this.swapRepository.saveSwap(s)
      }), i && this.startSwapManager().catch((s) => {
        rt.error("Failed to autostart SwapManager:", s);
      });
    }
  }
  // SwapManager methods
  /**
   * Start the background swap manager
   * This will load all pending swaps and begin monitoring them
   * Automatically called when SwapManager is enabled
   */
  async startSwapManager() {
    if (!this.swapManager)
      throw new Error(
        "SwapManager is not enabled. Provide 'swapManager' config in ArkadeLightningConfig."
      );
    const e = await this.swapRepository.getAllSwaps();
    await this.swapManager.start(e);
  }
  /**
   * Stop the background swap manager
   */
  async stopSwapManager() {
    this.swapManager && await this.swapManager.stop();
  }
  /**
   * Get the SwapManager instance
   * Useful for accessing manager stats or manually controlling swaps
   */
  getSwapManager() {
    return this.swapManager;
  }
  // receive from lightning = reverse submarine swap
  //
  // 1. create invoice by creating a reverse swap
  // 2. monitor incoming payment by waiting for the hold invoice to be paid
  // 3. claim the VHTLC by creating a virtual transaction that spends the VHTLC output
  // 4. return the preimage and the swap info
  /**
   * Creates a Lightning invoice.
   * @param args - The arguments for creating a Lightning invoice.
   * @returns The response containing the created Lightning invoice.
   */
  async createLightningInvoice(e) {
    return this.createReverseSwap(e).then((t) => {
      const n = cf(t.response.invoice);
      return {
        amount: t.response.onchainAmount,
        expiry: n.expiry,
        invoice: t.response.invoice,
        paymentHash: n.paymentHash,
        pendingSwap: t,
        preimage: t.preimage
      };
    });
  }
  /**
   * Sends a Lightning payment.
   * 1. decode the invoice to get the amount and destination
   * 2. create submarine swap with the decoded invoice
   * 3. send the swap address and expected amount to the wallet to create a transaction
   * 4. wait for the swap settlement and return the preimage and txid
   * @param args - The arguments for sending a Lightning payment.
   * @returns The result of the payment.
   */
  async sendLightningPayment(e) {
    const t = await this.createSubmarineSwap(e);
    await this.swapRepository.saveSwap(t);
    const n = await this.wallet.sendBitcoin({
      address: t.response.address,
      amount: t.response.expectedAmount
    });
    try {
      const { preimage: r } = await this.waitForSwapSettlement(t);
      return {
        amount: t.response.expectedAmount,
        preimage: r,
        txid: n
      };
    } catch (r) {
      if (r.isRefundable) {
        await this.refundVHTLC(t);
        const i = await this.getSwapStatus(t.id);
        await this.swapRepository.saveSwap({
          ...t,
          status: i.status
        });
      }
      throw new lg();
    }
  }
  /**
   * Creates a submarine swap.
   * @param args - The arguments for creating a submarine swap.
   * @returns The created pending submarine swap.
   */
  async createSubmarineSwap(e) {
    const t = C.encode(
      await this.wallet.identity.compressedPublicKey()
    );
    if (!t)
      throw new Gt({
        message: "Failed to get refund public key from wallet"
      });
    const n = e.invoice;
    if (!n) throw new Gt({ message: "Invoice is required" });
    const r = {
      invoice: n,
      refundPublicKey: t
    }, i = await this.swapProvider.createSubmarineSwap(r), s = {
      id: i.id,
      type: "submarine",
      createdAt: Math.floor(Date.now() / 1e3),
      request: r,
      response: i,
      status: "invoice.set"
    };
    return await this.swapRepository.saveSwap(s), this.swapManager && await this.swapManager.addSwap(s), s;
  }
  /**
   * Creates a reverse swap.
   * @param args - The arguments for creating a reverse swap.
   * @returns The created pending reverse swap.
   */
  async createReverseSwap(e) {
    if (e.amount <= 0)
      throw new Gt({ message: "Amount must be greater than 0" });
    const t = C.encode(
      await this.wallet.identity.compressedPublicKey()
    );
    if (!t)
      throw new Gt({
        message: "Failed to get claim public key from wallet"
      });
    const n = Es(32), r = C.encode(Bt(n));
    if (!r)
      throw new Gt({ message: "Failed to get preimage hash" });
    const i = {
      invoiceAmount: e.amount,
      claimPublicKey: t,
      preimageHash: r,
      ...e.description?.trim() ? { description: e.description.trim() } : {}
    }, s = await this.swapProvider.createReverseSwap(i), o = {
      id: s.id,
      type: "reverse",
      createdAt: Math.floor(Date.now() / 1e3),
      preimage: C.encode(n),
      request: i,
      response: s,
      status: "swap.created"
    };
    return await this.swapRepository.saveSwap(o), this.swapManager && await this.swapManager.addSwap(o), o;
  }
  /**
   * Claims the VHTLC for a pending reverse swap.
   * If the VHTLC is recoverable, it joins a batch to spend the vtxo via commitment transaction.
   * @param pendingSwap - The pending reverse swap to claim the VHTLC.
   */
  async claimVHTLC(e) {
    if (!e.preimage)
      throw new Error("Preimage is required to claim VHTLC");
    const t = C.decode(e.preimage), n = await this.arkProvider.getInfo(), r = await this.wallet.getAddress(), i = Nn(
      await this.wallet.identity.xOnlyPublicKey(),
      "our",
      e.id
    ), s = Nn(
      C.decode(e.response.refundPublicKey),
      "boltz",
      e.id
    ), o = Nn(
      C.decode(n.signerPubkey),
      "server",
      e.id
    ), { vhtlcScript: a, vhtlcAddress: c } = this.createVHTLCScript({
      network: n.network,
      preimageHash: Bt(t),
      receiverPubkey: C.encode(i),
      senderPubkey: C.encode(s),
      serverPubkey: C.encode(o),
      timeoutBlockHeights: e.response.timeoutBlockHeights
    });
    if (!a)
      throw new Error("Failed to create VHTLC script for reverse swap");
    if (c !== e.response.lockupAddress)
      throw new Error("Boltz is trying to scam us");
    const { vtxos: u } = await this.indexerProvider.getVtxos({
      scripts: [C.encode(a.pkScript)]
    });
    if (u.length === 0)
      throw new Error("No spendable virtual coins found");
    const l = u[0];
    if (l.isSpent)
      throw new Error("VHTLC is already spent");
    const f = {
      ...l,
      tapLeafScript: a.claim(),
      tapTree: a.encode()
    }, h = {
      amount: BigInt(l.value),
      script: Sr.decode(r).pkScript
    }, g = TA(
      this.wallet.identity,
      t
    );
    var d;
    Ya(l) ? (await this.joinBatch(g, f, h, n), d = "transaction.claimed") : (await this.claimVHTLCwithOffchainTx(
      g,
      a,
      o,
      f,
      h,
      n
    ), d = (await this.getSwapStatus(e.id)).status), await this.swapRepository.saveSwap({
      ...e,
      status: d
    });
  }
  /**
   * Claims the VHTLC for a pending submarine swap (aka refund).
   * If the VHTLC is recoverable, it joins a batch to spend the vtxo via commitment transaction.
   * @param pendingSwap - The pending submarine swap to refund the VHTLC.
   */
  async refundVHTLC(e) {
    const t = e.request.invoice ? bA(e.request.invoice) : e.preimageHash;
    if (!t)
      throw new Error("Preimage hash is required to refund VHTLC");
    const n = Sr.decode(
      e.response.address
    ).pkScript, { vtxos: r } = await this.indexerProvider.getVtxos({
      scripts: [C.encode(n)]
    });
    if (r.length === 0)
      throw new Error(
        `VHTLC not found for address ${e.response.address}`
      );
    const i = r[0];
    if (i.isSpent)
      throw new Error("VHTLC is already spent");
    const s = await this.arkProvider.getInfo(), o = await this.wallet.getAddress();
    if (!o) throw new Error("Failed to get ark address from wallet");
    const a = Nn(
      await this.wallet.identity.xOnlyPublicKey(),
      "our",
      e.id
    ), c = Nn(
      C.decode(s.signerPubkey),
      "server",
      e.id
    ), u = Nn(
      C.decode(e.response.claimPublicKey),
      "boltz",
      e.id
    ), { vhtlcScript: l } = this.createVHTLCScript({
      network: s.network,
      preimageHash: C.decode(t),
      receiverPubkey: C.encode(u),
      senderPubkey: C.encode(a),
      serverPubkey: C.encode(c),
      timeoutBlockHeights: e.response.timeoutBlockHeights
    });
    if (!l)
      throw new Error("Failed to create VHTLC script for reverse swap");
    const f = Ya(i), h = {
      ...i,
      tapLeafScript: f ? l.refundWithoutReceiver() : l.refund(),
      tapTree: l.encode()
    }, g = {
      amount: BigInt(i.value),
      script: Sr.decode(o).pkScript
    };
    f ? await this.joinBatch(this.wallet.identity, h, g, s) : await this.refundVHTLCwithOffchainTx(
      e,
      u,
      a,
      c,
      h,
      g,
      s
    ), await this.swapRepository.saveSwap({
      ...e,
      refundable: !0,
      refunded: !0
    });
  }
  /**
   * Joins a batch to spend the vtxo via commitment transaction
   * @param identity - The identity to use for signing the forfeit transaction.
   * @param input - The input vtxo.
   * @param output - The output script.
   * @param isRecoverable
   * @param forfeitPublicKey - The forfeit public key.
   * @returns The commitment transaction ID.
   */
  async joinBatch(e, t, n, {
    forfeitPubkey: r,
    forfeitAddress: i,
    network: s
  }, o = !0) {
    const a = e.signerSession(), c = await a.getPublicKey(), u = {
      type: "register",
      onchain_output_indexes: [],
      valid_at: 0,
      expire_at: 0,
      cosigners_public_keys: [C.encode(c)]
    }, l = {
      type: "delete",
      expire_at: 0
    }, f = {
      txid: C.decode(t.txid),
      index: t.vout,
      witnessUtxo: {
        amount: BigInt(t.value),
        script: Pe.decode(t.tapTree).pkScript
      },
      tapLeafScript: [t.tapLeafScript],
      unknown: [ed.encode(t.tapTree)],
      sequence: dd(t.tapLeafScript)
    }, h = vn.create(
      u,
      [f],
      [n]
    ), g = vn.create(l, [f]), [d, p] = await Promise.all([
      e.sign(h),
      e.sign(g)
    ]), y = new AbortController(), x = await this.arkProvider.registerIntent({
      message: u,
      proof: ut.encode(d.toPSBT())
    }), S = Gn(
      s in la ? la[s] : la.bitcoin
    ).decode(i);
    try {
      const A = SA(
        x,
        t,
        this.arkProvider,
        e,
        a,
        C.decode(r).slice(1),
        o ? void 0 : It.encode(S)
      ), R = [
        C.encode(c),
        `${t.txid}:${t.vout}`
      ], N = this.arkProvider.getEventStream(
        y.signal,
        R
      ), F = await Za.join(N, A, {
        abortController: y
      });
      return rt.log(
        "Batch joined with commitment transaction:",
        F
      ), F;
    } catch (A) {
      y.abort(), rt.error("Failed to join batch:", A);
      try {
        await this.arkProvider.deleteIntent({
          message: l,
          proof: ut.encode(p.toPSBT())
        });
      } catch (R) {
        rt.error("Failed to delete intent:", R);
      }
      throw A;
    }
  }
  /**
   * Waits for the swap to be confirmed and claims the VHTLC.
   * If SwapManager is enabled, this delegates to the manager for coordinated processing.
   * @param pendingSwap - The pending reverse swap.
   * @returns The transaction ID of the claimed VHTLC.
   */
  async waitAndClaim(e) {
    return this.swapManager && await this.swapManager.hasSwap(e.id) ? this.swapManager.waitForSwapCompletion(e.id) : new Promise((t, n) => {
      const r = async (i) => {
        const s = (o) => this.swapRepository.saveSwap({
          ...e,
          status: i,
          ...o
        });
        switch (i) {
          case "transaction.mempool":
          case "transaction.confirmed":
            await s(), this.claimVHTLC(e).catch(n);
            break;
          case "invoice.settled": {
            await s();
            const a = (await this.swapProvider.getReverseSwapTxId(
              e.id
            )).id;
            if (!a || a.trim() === "") {
              n(
                new Gt({
                  message: `Transaction ID not available for settled swap ${e.id}.`
                })
              );
              break;
            }
            t({ txid: a });
            break;
          }
          case "invoice.expired":
            await s(), n(
              new iA({
                isRefundable: !0,
                pendingSwap: e
              })
            );
            break;
          case "swap.expired":
            await s(), n(
              new ug({
                isRefundable: !0,
                pendingSwap: e
              })
            );
            break;
          case "transaction.failed":
            await s(), n(new lg());
            break;
          case "transaction.refunded":
            await s(), n(new aA());
            break;
          default:
            await s();
            break;
        }
      };
      this.swapProvider.monitorSwap(e.id, r);
    });
  }
  /**
   * Waits for the swap settlement.
   * @param pendingSwap - The pending submarine swap.
   * @returns The status of the swap settlement.
   */
  async waitForSwapSettlement(e) {
    return new Promise((t, n) => {
      let r = !1;
      const i = async (s) => {
        if (r) return;
        const o = (a) => this.swapRepository.saveSwap({
          ...e,
          status: s,
          ...a
        });
        switch (s) {
          case "swap.expired":
            r = !0, await o({ refundable: !0 }), n(
              new ug({
                isRefundable: !0,
                pendingSwap: e
              })
            );
            break;
          case "invoice.failedToPay":
            r = !0, await o({ refundable: !0 }), n(
              new sA({
                isRefundable: !0,
                pendingSwap: e
              })
            );
            break;
          case "transaction.lockupFailed":
            r = !0, await o({ refundable: !0 }), n(
              new oA({
                isRefundable: !0,
                pendingSwap: e
              })
            );
            break;
          case "transaction.claimed": {
            r = !0;
            const { preimage: a } = await this.swapProvider.getSwapPreimage(
              e.id
            );
            await o({ preimage: a }), t({ preimage: a });
            break;
          }
          default:
            await o();
            break;
        }
      };
      this.swapProvider.monitorSwap(e.id, i).catch((s) => {
        r || (r = !0, n(s));
      });
    });
  }
  /**
   * Restore swaps from Boltz API.
   *
   * Note: restored swaps may lack local-only data such as the original
   * Lightning invoice or preimage. They are intended primarily for
   * display/monitoring and are not automatically wired into the SwapManager.
   * Do not call `claimVHTLC` / `refundVHTLC` on them unless you have
   * enriched the objects with the missing fields.
   *
   * @param boltzFees - Optional fees response to use for restoration.
   * @returns An object containing arrays of restored reverse and submarine swaps.
   */
  async restoreSwaps(e) {
    const t = C.encode(
      await this.wallet.identity.compressedPublicKey()
    );
    if (!t) throw new Error("Failed to get public key from wallet");
    const n = e ?? await this.swapProvider.getFees(), r = [], i = [], s = await this.swapProvider.restoreSwaps(t);
    for (const o of s) {
      const { id: a, createdAt: c, status: u } = o;
      if (vb(o)) {
        const {
          amount: l,
          lockupAddress: f,
          preimageHash: h,
          serverPublicKey: g,
          tree: d
        } = o.claimDetails;
        r.push({
          id: a,
          createdAt: c,
          request: {
            invoiceAmount: EA(l, n),
            claimPublicKey: t,
            preimageHash: h
          },
          response: {
            id: a,
            invoice: "",
            // TODO check if we can get the invoice from boltz
            onchainAmount: l,
            lockupAddress: f,
            refundPublicKey: g,
            timeoutBlockHeights: {
              refund: ur(
                d.refundWithoutBoltzLeaf.output
              ),
              unilateralClaim: ur(
                d.unilateralClaimLeaf.output
              ),
              unilateralRefund: ur(
                d.unilateralRefundLeaf.output
              ),
              unilateralRefundWithoutReceiver: ur(
                d.unilateralRefundWithoutBoltzLeaf.output
              )
            }
          },
          status: u,
          type: "reverse",
          preimage: ""
        });
      } else if (Sb(o)) {
        const { amount: l, lockupAddress: f, serverPublicKey: h, tree: g } = o.refundDetails;
        let d = "";
        try {
          d = (await this.swapProvider.getSwapPreimage(
            o.id
          )).preimage;
        } catch (p) {
          rt.warn(
            `Failed to restore preimage for submarine swap ${a}`,
            p
          );
        }
        i.push({
          id: a,
          type: "submarine",
          createdAt: c,
          preimage: d,
          preimageHash: o.preimageHash,
          status: u,
          request: {
            invoice: "",
            // TODO check if we can get the invoice from boltz
            refundPublicKey: t
          },
          response: {
            id: a,
            address: f,
            expectedAmount: l,
            claimPublicKey: h,
            timeoutBlockHeights: {
              refund: ur(
                g.refundWithoutBoltzLeaf.output
              ),
              unilateralClaim: ur(
                g.unilateralClaimLeaf.output
              ),
              unilateralRefund: ur(
                g.unilateralRefundLeaf.output
              ),
              unilateralRefundWithoutReceiver: ur(
                g.unilateralRefundWithoutBoltzLeaf.output
              )
            }
          }
        });
      }
    }
    return { reverseSwaps: r, submarineSwaps: i };
  }
  // Swap enrichment and validation helpers
  /**
   * Enrich a restored reverse swap with its preimage.
   * This makes the swap claimable via `claimVHTLC`.
   * Validates that the preimage hash matches the swap's expected preimageHash.
   *
   * @param swap - The restored reverse swap to enrich.
   * @param preimage - The preimage (hex-encoded) for the swap.
   * @returns The enriched swap object (same reference, mutated).
   * @throws Error if the preimage does not match the swap's preimageHash.
   */
  enrichReverseSwapPreimage(e, t) {
    const n = C.encode(Bt(C.decode(t)));
    if (n !== e.request.preimageHash)
      throw new Error(
        `Preimage does not match swap: expected hash ${e.request.preimageHash}, got ${n}`
      );
    return e.preimage = t, e;
  }
  /**
   * Enrich a restored submarine swap with its invoice.
   * This makes the swap refundable via `refundVHTLC`.
   * Validates that the invoice is well-formed and its payment hash can be extracted.
   * If the swap has a preimageHash (from restoration), validates that the invoice's
   * payment hash matches.
   *
   * @param swap - The restored submarine swap to enrich.
   * @param invoice - The Lightning invoice for the swap.
   * @returns The enriched swap object (same reference, mutated).
   * @throws Error if the invoice is invalid, cannot be decoded, or payment hash doesn't match.
   */
  enrichSubmarineSwapInvoice(e, t) {
    let n;
    try {
      const r = cf(t);
      if (!r.paymentHash)
        throw new Error("Invoice missing payment hash");
      n = r.paymentHash;
    } catch (r) {
      throw r instanceof Error ? new Error(`Invalid Lightning invoice: ${r.message}`) : new Error("Invalid Lightning invoice format");
    }
    if (e.preimageHash && n !== e.preimageHash)
      throw new Error(
        `Invoice payment hash does not match swap: expected ${e.preimageHash}, got ${n}`
      );
    return e.request.invoice = t, e;
  }
  async claimVHTLCwithOffchainTx(e, t, n, r, i, s) {
    const o = C.decode(s.checkpointTapscript), a = Yt.decode(
      o
    ), { arkTx: c, checkpoints: u } = Ul(
      [r],
      [i],
      a
    ), l = await e.sign(c), { arkTxid: f, finalArkTx: h, signedCheckpointTxs: g } = await this.arkProvider.submitTx(
      ut.encode(l.toPSBT()),
      u.map((p) => ut.encode(p.toPSBT()))
    );
    if (!this.validFinalArkTx(
      h,
      n,
      t.leaves
    ))
      throw new Error("Invalid final Ark transaction");
    const d = await Promise.all(
      g.map(async (p) => {
        const y = Xt.fromPSBT(ut.decode(p), {
          allowUnknown: !0
        }), x = await e.sign(y, [0]);
        return ut.encode(x.toPSBT());
      })
    );
    await this.arkProvider.finalizeTx(f, d);
  }
  async refundVHTLCwithOffchainTx(e, t, n, r, i, s, o) {
    const a = C.decode(o.checkpointTapscript), c = Yt.decode(
      a
    ), { arkTx: u, checkpoints: l } = Ul([i], [s], c);
    if (l.length !== 1)
      throw new Error(
        `Expected one checkpoint transaction, got ${l.length}`
      );
    const f = l[0], {
      transaction: h,
      checkpoint: g
    } = await this.swapProvider.refundSubmarineSwap(
      e.id,
      u,
      f
    ), d = C.encode(t);
    if (!tl(h, 0, [d]))
      throw new Error("Invalid Boltz signature in refund transaction");
    if (!tl(g, 0, [
      d
    ]))
      throw new Error(
        "Invalid Boltz signature in checkpoint transaction"
      );
    const p = await this.wallet.identity.sign(u), y = await this.wallet.identity.sign(f), x = Nu(
      h,
      p
    ), S = Nu(
      g,
      y
    ), { arkTxid: A, finalArkTx: R, signedCheckpointTxs: N } = await this.arkProvider.submitTx(
      ut.encode(x.toPSBT()),
      [ut.encode(f.toPSBT())]
    ), F = Xt.fromPSBT(ut.decode(R)), w = 0, K = [
      C.encode(n),
      C.encode(t),
      C.encode(r)
    ];
    if (!tl(F, w, K))
      throw new Error("Invalid refund transaction");
    if (N.length !== 1)
      throw new Error(
        `Expected one signed checkpoint transaction, got ${N.length}`
      );
    const U = Xt.fromPSBT(
      ut.decode(N[0])
    ), W = Nu(
      S,
      U
    );
    await this.arkProvider.finalizeTx(A, [
      ut.encode(W.toPSBT())
    ]);
  }
  // validators
  /**
   * Validates the final Ark transaction.
   * checks that all inputs have a signature for the given pubkey
   * and the signature is correct for the given tapscript leaf
   * TODO: This is a simplified check, we should verify the actual signatures
   * @param finalArkTx The final Ark transaction in PSBT format.
   * @param _pubkey The public key of the user.
   * @param _tapLeaves The taproot script leaves.
   * @returns True if the final Ark transaction is valid, false otherwise.
   */
  validFinalArkTx = (e, t, n) => {
    const r = Xt.fromPSBT(ut.decode(e), {
      allowUnknown: !0
    });
    if (!r) return !1;
    const i = [];
    for (let s = 0; s < r.inputsLength; s++)
      i.push(r.getInput(s));
    return i.every((s) => s.witnessUtxo);
  };
  /**
   * Creates a VHTLC script for the swap.
   * works for submarine swaps and reverse swaps
   * it creates a VHTLC script that can be used to claim or refund the swap
   * it validates the receiver, sender and server public keys are x-only
   * it validates the VHTLC script matches the expected lockup address
   * @param param0 - The parameters for creating the VHTLC script.
   * @returns The created VHTLC script.
   */
  createVHTLCScript({
    network: e,
    preimageHash: t,
    receiverPubkey: n,
    senderPubkey: r,
    serverPubkey: i,
    timeoutBlockHeights: s
  }) {
    const o = Nn(
      C.decode(n),
      "receiver"
    ), a = Nn(
      C.decode(r),
      "sender"
    ), c = Nn(
      C.decode(i),
      "server"
    ), u = (g) => g < 512 ? "blocks" : "seconds", l = new Ga.Script({
      preimageHash: Jm(t),
      sender: a,
      receiver: o,
      server: c,
      refundLocktime: BigInt(s.refund),
      unilateralClaimDelay: {
        type: u(s.unilateralClaim),
        value: BigInt(s.unilateralClaim)
      },
      unilateralRefundDelay: {
        type: u(s.unilateralRefund),
        value: BigInt(s.unilateralRefund)
      },
      unilateralRefundWithoutReceiverDelay: {
        type: u(
          s.unilateralRefundWithoutReceiver
        ),
        value: BigInt(
          s.unilateralRefundWithoutReceiver
        )
      }
    });
    if (!l) throw new Error("Failed to create VHTLC script");
    const f = e === "bitcoin" ? "ark" : "tark", h = l.address(f, c).encode();
    return { vhtlcScript: l, vhtlcAddress: h };
  }
  /**
   * Retrieves fees for swaps (in sats and percentage).
   * @returns The fees for swaps.
   */
  async getFees() {
    return this.swapProvider.getFees();
  }
  /**
   * Retrieves max and min limits for swaps (in sats).
   * @returns The limits for swaps.
   */
  async getLimits() {
    return this.swapProvider.getLimits();
  }
  /**
   * Retrieves swap status by ID.
   * @param swapId - The ID of the swap.
   * @returns The status of the swap.
   */
  async getSwapStatus(e) {
    return this.swapProvider.getSwapStatus(e);
  }
  /**
   * Retrieves all pending submarine swaps from storage.
   * This method filters the pending swaps to return only those with a status of 'invoice.set'.
   * It is useful for checking the status of all pending submarine swaps in the system.
   *
   * @returns PendingSubmarineSwap[]. If no swaps are found, it returns an empty array.
   */
  async getPendingSubmarineSwaps() {
    return (await this.swapRepository.getAllSwaps({
      status: "invoice.set",
      type: "submarine"
    })).filter(va);
  }
  /**
   * Retrieves all pending reverse swaps from storage.
   * This method filters the pending swaps to return only those with a status of 'swap.created'.
   * It is useful for checking the status of all pending reverse swaps in the system.
   *
   * @returns PendingReverseSwap[]. If no swaps are found, it returns an empty array.
   */
  async getPendingReverseSwaps() {
    return (await this.swapRepository.getAllSwaps({
      status: "swap.created",
      type: "reverse"
    })).filter(Fs);
  }
  /**
   * Retrieves swap history from storage.
   * @returns Array of all swaps sorted by creation date (newest first). If no swaps are found, it returns an empty array.
   */
  async getSwapHistory() {
    return this.swapRepository.getAllSwaps({
      orderBy: "createdAt",
      orderDirection: "desc"
    });
  }
  /**
   * Refreshes the status of all pending swaps in the storage provider.
   * This method iterates through all pending reverse and submarine swaps,
   * checks their current status using the swap provider, and updates the storage provider accordingly.
   * It skips swaps that are already in a final status to avoid unnecessary API calls.
   * If no storage provider is set, the method exits early.
   * Errors during status refresh are logged to the console but do not interrupt the process.
   * @returns void
   * Important: a submarine swap with status payment.failedToPay is considered final and won't be refreshed.
   * User should manually retry or delete it if refund fails.
   */
  async refreshSwapsStatus() {
    const e = await this.swapRepository.getAllSwaps();
    for (const t of e)
      xb(t.status) || Eb(t.status) || await this.getSwapStatus(t.id).then(
        ({ status: n }) => this.swapRepository.saveSwap({ ...t, status: n })
      ).catch((n) => {
        rt.error(
          `Failed to refresh swap status for ${t.id}:`,
          n
        );
      });
  }
  /**
   * Dispose of resources (stops SwapManager and cleans up)
   * Can be called manually or automatically with `await using` syntax (TypeScript 5.2+)
   */
  async dispose() {
    this.swapManager && await this.stopSwapManager();
  }
  /**
   * Symbol.asyncDispose for automatic cleanup with `await using` syntax
   * Example:
   * ```typescript
   * await using arkadeLightning = new ArkadeLightning({ ... });
   * // SwapManager automatically stopped when scope exits
   * ```
   */
  async [Symbol.asyncDispose]() {
    await this.dispose();
  }
}, CA = "ARKADE_LIGHTNING_UPDATER", RA = class Ab {
  constructor(t) {
    this.swapRepository = t;
  }
  static messageTag = CA;
  messageTag = Ab.messageTag;
  arkProvider;
  indexerProvider;
  swapProvider;
  wallet;
  handler;
  swapManager;
  async start(t) {
    if (!t.wallet) throw new Error("Wallet is required");
    this.wallet = t.wallet;
  }
  async stop() {
    const t = this.handler;
    if (!t) return;
    const n = this.swapManager ?? t.getSwapManager();
    n && await n.stop(), typeof t.dispose == "function" && await t.dispose(), this.swapManager = null, this.handler = void 0, this.wallet = void 0, this.arkProvider = void 0, this.indexerProvider = void 0, this.swapProvider = void 0;
  }
  async tick(t) {
    return [];
  }
  tagged(t) {
    return {
      ...t,
      tag: this.messageTag
    };
  }
  async broadcastEvent(t) {
    const n = self;
    if (!n?.clients?.matchAll) return;
    const r = await n.clients.matchAll();
    for (const i of r)
      try {
        i.postMessage(t);
      } catch {
      }
  }
  async handleMessage(t) {
    const n = t.id;
    if (t.type === "INIT_ARKADE_LIGHTNING")
      try {
        return await this.handleInit(t), this.tagged({
          id: n,
          type: "ARKADE_LIGHTNING_INITIALIZED"
        });
      } catch (r) {
        return this.tagged({ id: n, error: r });
      }
    if (!this.handler || !this.wallet)
      return this.tagged({
        id: n,
        error: new Error("handler not initialized")
      });
    try {
      switch (t.type) {
        case "CREATE_LIGHTNING_INVOICE": {
          const r = await this.handler.createLightningInvoice(
            t.payload
          );
          return this.tagged({
            id: n,
            type: "LIGHTNING_INVOICE_CREATED",
            payload: r
          });
        }
        case "SEND_LIGHTNING_PAYMENT": {
          const r = await this.handler.sendLightningPayment(
            t.payload
          );
          return this.tagged({
            id: n,
            type: "LIGHTNING_PAYMENT_SENT",
            payload: r
          });
        }
        case "CREATE_SUBMARINE_SWAP": {
          const r = await this.handler.createSubmarineSwap(
            t.payload
          );
          return this.tagged({
            id: n,
            type: "SUBMARINE_SWAP_CREATED",
            payload: r
          });
        }
        case "CREATE_REVERSE_SWAP": {
          const r = await this.handler.createReverseSwap(
            t.payload
          );
          return this.tagged({
            id: n,
            type: "REVERSE_SWAP_CREATED",
            payload: r
          });
        }
        case "CLAIM_VHTLC":
          return await this.handler.claimVHTLC(t.payload), this.tagged({ id: n, type: "VHTLC_CLAIMED" });
        case "REFUND_VHTLC":
          return await this.handler.refundVHTLC(t.payload), this.tagged({ id: n, type: "VHTLC_REFUNDED" });
        case "WAIT_AND_CLAIM": {
          const r = await this.handler.waitAndClaim(
            t.payload
          );
          return this.tagged({
            id: n,
            type: "WAIT_AND_CLAIMED",
            payload: r
          });
        }
        case "WAIT_FOR_SWAP_SETTLEMENT": {
          const r = await this.handler.waitForSwapSettlement(
            t.payload
          );
          return this.tagged({
            id: n,
            type: "SWAP_SETTLED",
            payload: r
          });
        }
        case "RESTORE_SWAPS": {
          const r = await this.handler.restoreSwaps(
            t.payload
          );
          return this.tagged({
            id: n,
            type: "SWAPS_RESTORED",
            payload: r
          });
        }
        case "ENRICH_REVERSE_SWAP_PREIMAGE": {
          const r = this.handler.enrichReverseSwapPreimage(
            t.payload.swap,
            t.payload.preimage
          );
          return this.tagged({
            id: n,
            type: "REVERSE_SWAP_PREIMAGE_ENRICHED",
            payload: r
          });
        }
        case "ENRICH_SUBMARINE_SWAP_INVOICE": {
          const r = this.handler.enrichSubmarineSwapInvoice(
            t.payload.swap,
            t.payload.invoice
          );
          return this.tagged({
            id: n,
            type: "SUBMARINE_SWAP_INVOICE_ENRICHED",
            payload: r
          });
        }
        case "GET_FEES": {
          const r = await this.handler.getFees();
          return this.tagged({ id: n, type: "FEES", payload: r });
        }
        case "GET_LIMITS": {
          const r = await this.handler.getLimits();
          return this.tagged({ id: n, type: "LIMITS", payload: r });
        }
        case "GET_SWAP_STATUS": {
          const r = await this.handler.getSwapStatus(
            t.payload.swapId
          );
          return this.tagged({
            id: n,
            type: "SWAP_STATUS",
            payload: r
          });
        }
        case "GET_PENDING_SUBMARINE_SWAPS": {
          const r = await this.handler.getPendingSubmarineSwaps();
          return this.tagged({
            id: n,
            type: "PENDING_SUBMARINE_SWAPS",
            payload: r
          });
        }
        case "GET_PENDING_REVERSE_SWAPS": {
          const r = await this.handler.getPendingReverseSwaps();
          return this.tagged({
            id: n,
            type: "PENDING_REVERSE_SWAPS",
            payload: r
          });
        }
        case "GET_SWAP_HISTORY": {
          const r = await this.handler.getSwapHistory();
          return this.tagged({
            id: n,
            type: "SWAP_HISTORY",
            payload: r
          });
        }
        case "REFRESH_SWAPS_STATUS":
          return await this.handler.refreshSwapsStatus(), this.tagged({ id: n, type: "SWAPS_STATUS_REFRESHED" });
        /* --- SwapManager methods --- */
        case "SM-START":
          return await this.handler.startSwapManager(), this.tagged({ id: n, type: "SM-STARTED" });
        case "SM-STOP":
          return await this.handler.stopSwapManager(), this.tagged({ id: n, type: "SM-STOPPED" });
        case "SM-ADD_SWAP":
          return await this.handler.getSwapManager().addSwap(t.payload), this.tagged({ id: n, type: "SM-SWAP_ADDED" });
        case "SM-REMOVE_SWAP":
          return await this.handler.getSwapManager().removeSwap(t.payload.swapId), this.tagged({ id: n, type: "SM-SWAP_REMOVED" });
        case "SM-GET_PENDING_SWAPS": {
          const r = await this.handler.getSwapManager().getPendingSwaps();
          return this.tagged({
            id: n,
            type: "SM-PENDING_SWAPS",
            payload: r
          });
        }
        case "SM-HAS_SWAP": {
          const r = await this.handler.getSwapManager().hasSwap(t.payload.swapId);
          return this.tagged({
            id: n,
            type: "SM-HAS_SWAP_RESULT",
            payload: { has: r }
          });
        }
        case "SM-IS_PROCESSING": {
          const r = await this.handler.getSwapManager().isProcessing(t.payload.swapId);
          return this.tagged({
            id: n,
            type: "SM-IS_PROCESSING_RESULT",
            payload: { processing: r }
          });
        }
        case "SM-GET_STATS": {
          const r = await this.handler.getSwapManager().getStats();
          return this.tagged({
            id: n,
            type: "SM-STATS",
            payload: r
          });
        }
        case "SM-WAIT_FOR_COMPLETION": {
          const r = await this.handler.getSwapManager().waitForSwapCompletion(t.payload.swapId);
          return this.tagged({
            id: n,
            type: "SM-COMPLETED",
            payload: r
          });
        }
        default:
          throw console.error("Unknown message type", t), new Error("Unknown message");
      }
    } catch (r) {
      return this.tagged({ id: n, error: r });
    }
  }
  async handleInit({ payload: t }) {
    if (!this.wallet)
      throw new Error("Wallet is required");
    const { arkServerUrl: n } = t;
    this.arkProvider = new _w(n), this.indexerProvider = new Hw(n), this.swapProvider = new mA({
      apiUrl: t.swapProvider.baseUrl,
      network: t.network
    });
    const r = new BA({
      wallet: this.wallet,
      arkProvider: this.arkProvider,
      swapProvider: this.swapProvider,
      indexerProvider: this.indexerProvider,
      swapRepository: this.swapRepository,
      swapManager: t.swapManager,
      feeConfig: t.feeConfig,
      timeoutConfig: t.timeoutConfig,
      retryConfig: t.retryConfig
    });
    this.handler = r;
    const i = r.getSwapManager();
    this.swapManager = i, i && (i.onSwapUpdate(async (s, o) => {
      await this.broadcastEvent({
        tag: this.messageTag,
        type: "SM-EVENT-SWAP_UPDATE",
        payload: { swap: s, oldStatus: o }
      });
    }), i.onSwapCompleted(async (s) => {
      await this.broadcastEvent({
        tag: this.messageTag,
        type: "SM-EVENT-SWAP_COMPLETED",
        payload: { swap: s }
      });
    }), i.onSwapFailed(async (s, o) => {
      await this.broadcastEvent({
        tag: this.messageTag,
        type: "SM-EVENT-SWAP_FAILED",
        payload: { swap: s, error: { message: o.message } }
      });
    }), i.onActionExecuted(async (s, o) => {
      await this.broadcastEvent({
        tag: this.messageTag,
        type: "SM-EVENT-ACTION_EXECUTED",
        payload: { swap: s, action: o }
      });
    }), i.onWebSocketConnected(async () => {
      await this.broadcastEvent({
        tag: this.messageTag,
        type: "SM-EVENT-WS_CONNECTED"
      });
    }), i.onWebSocketDisconnected(async (s) => {
      await this.broadcastEvent({
        tag: this.messageTag,
        type: "SM-EVENT-WS_DISCONNECTED",
        payload: s ? { errorMessage: s.message } : void 0
      });
    }));
  }
};
class Dr extends Xt {
  constructor(t) {
    super(el(t));
  }
  static fromPSBT(t, n) {
    return Xt.fromPSBT(t, el(n));
  }
  static fromRaw(t, n) {
    return Xt.fromRaw(t, el(n));
  }
}
Dr.ARK_TX_OPTS = {
  allowUnknown: !0,
  allowUnknownOutputs: !0,
  allowUnknownInputs: !0
};
function el(e) {
  return { ...Dr.ARK_TX_OPTS, ...e };
}
class _d extends Error {
  idx;
  // Indice of participant
  constructor(t, n) {
    super(n), this.idx = t;
  }
}
const { taggedHash: $b, pointToBytes: qo } = Xn.utils, en = xr.Point, it = en.Fn, Bn = xr.lengths.publicKey, uf = new Uint8Array(Bn), pg = Ur(kt(33), {
  decode: (e) => wo(e) ? uf : e.toBytes(!0),
  encode: (e) => ho(e, uf) ? en.ZERO : en.fromBytes(e)
}), gg = de(sb, (e) => (km("n", e, 1n, it.ORDER), e)), ji = zt({ R1: pg, R2: pg }), Ib = zt({ k1: gg, k2: gg, publicKey: kt(Bn) });
function yg(e, ...t) {
}
function Oe(e, ...t) {
  if (!Array.isArray(e))
    throw new Error("expected array");
  e.forEach((n) => st(n, ...t));
}
function wg(e) {
  if (!Array.isArray(e))
    throw new Error("expected array");
  e.forEach((t, n) => {
    if (typeof t != "boolean")
      throw new Error("expected boolean in xOnly array, got" + t + "(" + n + ")");
  });
}
const pc = (e, ...t) => it.create(it.fromBytes($b(e, ...t), !0)), Ns = (e, t) => Io(e.y) ? t : it.neg(t);
function ci(e) {
  return en.BASE.multiply(e);
}
function wo(e) {
  return e.equals(en.ZERO);
}
function lf(e) {
  return Oe(e, Bn), e.sort(lc);
}
function Ob(e) {
  Oe(e, Bn);
  for (let t = 1; t < e.length; t++)
    if (!ho(e[t], e[0]))
      return e[t];
  return uf;
}
function Bb(e) {
  return Oe(e, Bn), $b("KeyAgg list", ...e);
}
function Cb(e, t, n) {
  return st(e, Bn), st(t, Bn), ho(e, t) ? 1n : pc("KeyAgg coefficient", n, e);
}
function ff(e, t = [], n = []) {
  if (Oe(e, Bn), Oe(t, 32), t.length !== n.length)
    throw new Error("The tweaks and isXonly arrays must have the same length");
  const r = Ob(e), i = Bb(e);
  let s = en.ZERO;
  for (let c = 0; c < e.length; c++) {
    let u;
    try {
      u = en.fromBytes(e[c]);
    } catch {
      throw new _d(c, "pubkey");
    }
    s = s.add(u.multiply(Cb(e[c], r, i)));
  }
  let o = it.ONE, a = it.ZERO;
  for (let c = 0; c < t.length; c++) {
    const u = n[c] && !Io(s.y) ? it.neg(it.ONE) : it.ONE, l = it.fromBytes(t[c]);
    if (s = s.multiply(u).add(ci(l)), wo(s))
      throw new Error("The result of tweaking cannot be infinity");
    o = it.mul(u, o), a = it.add(l, it.mul(u, a));
  }
  return { aggPublicKey: s, gAcc: o, tweakAcc: a };
}
const mg = (e, t, n, r, i, s) => pc("MuSig/nonce", e, new Uint8Array([t.length]), t, new Uint8Array([n.length]), n, i, ko(s.length, 4), s, new Uint8Array([r]));
function PA(e, t, n = new Uint8Array(0), r, i = new Uint8Array(0), s = Es(32)) {
  if (st(e, Bn), yg(t, 32), st(n), ![0, 32].includes(n.length))
    throw new Error("wrong aggPublicKey");
  yg(), st(i), st(s, 32);
  const o = Uint8Array.of(0), a = mg(s, e, n, 0, o, i), c = mg(s, e, n, 1, o, i);
  return {
    secret: Ib.encode({ k1: a, k2: c, publicKey: e }),
    public: ji.encode({ R1: ci(a), R2: ci(c) })
  };
}
function NA(e) {
  Oe(e, 66);
  let t = en.ZERO, n = en.ZERO;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    try {
      const { R1: s, R2: o } = ji.decode(i);
      if (wo(s) || wo(o))
        throw new Error("infinity point");
      t = t.add(s), n = n.add(o);
    } catch {
      throw new _d(r, "pubnonce");
    }
  }
  return ji.encode({ R1: t, R2: n });
}
class LA {
  publicKeys;
  Q;
  gAcc;
  tweakAcc;
  b;
  R;
  e;
  tweaks;
  isXonly;
  L;
  secondKey;
  /**
   * Constructor for the Session class.
   * It precomputes and stores values derived from the aggregate nonce, public keys,
   * message, and optional tweaks, optimizing the signing process.
   * @param aggNonce The aggregate nonce (Uint8Array) from all participants combined, must be 66 bytes.
   * @param publicKeys An array of public keys (Uint8Array) from each participant, must be 33 bytes.
   * @param msg The message (Uint8Array) to be signed.
   * @param tweaks Optional array of tweaks (Uint8Array) to be applied to the aggregate public key, each must be 32 bytes. Defaults to [].
   * @param isXonly Optional array of booleans indicating whether each tweak is an X-only tweak. Defaults to [].
   * @throws {Error} If the input is invalid, such as wrong array sizes or lengths.
   */
  constructor(t, n, r, i = [], s = []) {
    if (Oe(n, 33), Oe(i, 32), wg(s), st(r), i.length !== s.length)
      throw new Error("The tweaks and isXonly arrays must have the same length");
    const { aggPublicKey: o, gAcc: a, tweakAcc: c } = ff(n, i, s), { R1: u, R2: l } = ji.decode(t);
    this.publicKeys = n, this.Q = o, this.gAcc = a, this.tweakAcc = c, this.b = pc("MuSig/noncecoef", t, qo(o), r);
    const f = u.add(l.multiply(this.b));
    this.R = wo(f) ? en.BASE : f, this.e = pc("BIP0340/challenge", qo(this.R), qo(o), r), this.tweaks = i, this.isXonly = s, this.L = Bb(n), this.secondKey = Ob(n);
  }
  /**
   * Calculates the key aggregation coefficient for a given point.
   * @private
   * @param P The point to calculate the coefficient for.
   * @returns The key aggregation coefficient as a bigint.
   * @throws {Error} If the provided public key is not included in the list of pubkeys.
   */
  getSessionKeyAggCoeff(t) {
    const { publicKeys: n } = this, r = t.toBytes(!0);
    if (!n.some((s) => ho(s, r)))
      throw new Error("The signer's pubkey must be included in the list of pubkeys");
    return Cb(r, this.secondKey, this.L);
  }
  partialSigVerifyInternal(t, n, r) {
    const { Q: i, gAcc: s, b: o, R: a, e: c } = this, u = it.fromBytes(t, !0);
    if (!it.isValid(u))
      return !1;
    const { R1: l, R2: f } = ji.decode(n), h = l.add(f.multiply(o)), g = Io(a.y) ? h : h.negate(), d = en.fromBytes(r), p = this.getSessionKeyAggCoeff(d), y = it.mul(Ns(i, 1n), s), x = ci(u), S = g.add(d.multiply(it.mul(c, it.mul(p, y))));
    return x.equals(S);
  }
  /**
   * Generates a partial signature for a given message, secret nonce, secret key, and session context.
   * @param secretNonce The secret nonce for this signing session (Uint8Array). MUST be securely erased after use.
   * @param secret The secret key of the signer (Uint8Array).
   * @param sessionCtx The session context containing all necessary information for signing.
   * @param fastSign if set to true, the signature is created without checking validity.
   * @returns The partial signature (Uint8Array).
   * @throws {Error} If the input is invalid, such as wrong array sizes, invalid nonce or secret key.
   */
  sign(t, n, r = !1) {
    if (st(n, 32), typeof r != "boolean")
      throw new Error("expected boolean");
    const { Q: i, gAcc: s, b: o, R: a, e: c } = this, { k1: u, k2: l, publicKey: f } = Ib.decode(t);
    if (t.fill(0, 0, 64), !it.isValid(u))
      throw new Error("wrong k1");
    if (!it.isValid(l))
      throw new Error("wrong k1");
    const h = Ns(a, u), g = Ns(a, l), d = it.fromBytes(n);
    if (it.is0(d))
      throw new Error("wrong d_");
    const p = ci(d), y = p.toBytes(!0);
    if (!ho(y, f))
      throw new Error("Public key does not match nonceGen argument");
    const x = this.getSessionKeyAggCoeff(p), S = Ns(i, 1n), A = it.mul(S, it.mul(s, d)), R = it.add(h, it.add(it.mul(o, g), it.mul(c, it.mul(x, A)))), N = it.toBytes(R);
    if (!r) {
      const F = ji.encode({
        R1: ci(u),
        R2: ci(l)
      });
      if (!this.partialSigVerifyInternal(N, F, y))
        throw new Error("Partial signature verification failed");
    }
    return N;
  }
  /**
   * Verifies a partial signature against the aggregate public key and other session parameters.
   * @param partialSig The partial signature to verify (Uint8Array).
   * @param pubNonces An array of public nonces from each signer (Uint8Array).
   * @param pubKeys An array of public keys from each signer (Uint8Array).
   * @param tweaks An array of tweaks applied to the aggregate public key.
   * @param isXonly An array of booleans indicating whether each tweak is an X-only tweak.
   * @param msg The message that was signed (Uint8Array).
   * @param i The index of the signer whose partial signature is being verified.
   * @returns True if the partial signature is valid, false otherwise.
   * @throws {Error} If the input is invalid, such as non array partialSig, pubNonces, pubKeys, tweaks.
   */
  partialSigVerify(t, n, r) {
    const { publicKeys: i, tweaks: s, isXonly: o } = this;
    if (st(t, 32), Oe(n, 66), Oe(i, Bn), Oe(s, 32), wg(o), Nr(r), n.length !== i.length)
      throw new Error("The pubNonces and publicKeys arrays must have the same length");
    if (s.length !== o.length)
      throw new Error("The tweaks and isXonly arrays must have the same length");
    if (r >= n.length)
      throw new Error("index outside of pubKeys/pubNonces");
    return this.partialSigVerifyInternal(t, n[r], i[r]);
  }
  /**
   * Aggregates partial signatures from multiple signers into a single final signature.
   * @param partialSigs An array of partial signatures from each signer (Uint8Array).
   * @param sessionCtx The session context containing all necessary information for signing.
   * @returns The final aggregate signature (Uint8Array).
   * @throws {Error} If the input is invalid, such as wrong array sizes, invalid signature.
   */
  partialSigAgg(t) {
    Oe(t, 32);
    const { Q: n, tweakAcc: r, R: i, e: s } = this;
    let o = 0n;
    for (let c = 0; c < t.length; c++) {
      const u = it.fromBytes(t[c], !0);
      if (!it.isValid(u))
        throw new _d(c, "psig");
      o = it.add(o, u);
    }
    const a = Ns(n, 1n);
    return o = it.add(o, it.mul(s, it.mul(a, r))), Ge(qo(i), it.toBytes(o));
  }
}
function UA(e) {
  const t = PA(e);
  return { secNonce: t.secret, pubNonce: t.public };
}
function _A(e) {
  return NA(e);
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Dd(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function bi(e, t = "") {
  if (!Number.isSafeInteger(e) || e < 0) {
    const n = t && `"${t}" `;
    throw new Error(`${n}expected integer >0, got ${e}`);
  }
}
function wt(e, t, n = "") {
  const r = Dd(e), i = e?.length, s = t !== void 0;
  if (!r || s && i !== t) {
    const o = n && `"${n}" `, a = s ? ` of length ${t}` : "", c = r ? `length=${i}` : `type=${typeof e}`;
    throw new Error(o + "expected Uint8Array" + a + ", got " + c);
  }
  return e;
}
function Rb(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  bi(e.outputLen), bi(e.blockLen);
}
function gc(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function DA(e, t) {
  wt(e, void 0, "digestInto() output");
  const n = t.outputLen;
  if (e.length < n)
    throw new Error('"digestInto() output" expected to be of length >=' + n);
}
function yc(...e) {
  for (let t = 0; t < e.length; t++)
    e[t].fill(0);
}
function nl(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function fn(e, t) {
  return e << 32 - t | e >>> t;
}
const Pb = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", VA = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function ou(e) {
  if (wt(e), Pb)
    return e.toHex();
  let t = "";
  for (let n = 0; n < e.length; n++)
    t += VA[e[n]];
  return t;
}
const Ln = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function bg(e) {
  if (e >= Ln._0 && e <= Ln._9)
    return e - Ln._0;
  if (e >= Ln.A && e <= Ln.F)
    return e - (Ln.A - 10);
  if (e >= Ln.a && e <= Ln.f)
    return e - (Ln.a - 10);
}
function wc(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (Pb)
    return Uint8Array.fromHex(e);
  const t = e.length, n = t / 2;
  if (t % 2)
    throw new Error("hex string expected, got unpadded hex of length " + t);
  const r = new Uint8Array(n);
  for (let i = 0, s = 0; i < n; i++, s += 2) {
    const o = bg(e.charCodeAt(s)), a = bg(e.charCodeAt(s + 1));
    if (o === void 0 || a === void 0) {
      const c = e[s] + e[s + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + s);
    }
    r[i] = o * 16 + a;
  }
  return r;
}
function Sn(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    wt(i), t += i.length;
  }
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const s = e[r];
    n.set(s, i), i += s.length;
  }
  return n;
}
function MA(e, t = {}) {
  const n = (i, s) => e(s).update(i).digest(), r = e(void 0);
  return n.outputLen = r.outputLen, n.blockLen = r.blockLen, n.create = (i) => e(i), Object.assign(n, t), Object.freeze(n);
}
function au(e = 32) {
  const t = typeof globalThis == "object" ? globalThis.crypto : null;
  if (typeof t?.getRandomValues != "function")
    throw new Error("crypto.getRandomValues must be defined");
  return t.getRandomValues(new Uint8Array(e));
}
const FA = (e) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, e])
});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Vd = /* @__PURE__ */ BigInt(0), df = /* @__PURE__ */ BigInt(1);
function mc(e, t = "") {
  if (typeof e != "boolean") {
    const n = t && `"${t}" `;
    throw new Error(n + "expected boolean, got type=" + typeof e);
  }
  return e;
}
function Nb(e) {
  if (typeof e == "bigint") {
    if (!ka(e))
      throw new Error("positive bigint expected, got " + e);
  } else
    bi(e);
  return e;
}
function Go(e) {
  const t = Nb(e).toString(16);
  return t.length & 1 ? "0" + t : t;
}
function Lb(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return e === "" ? Vd : BigInt("0x" + e);
}
function Ss(e) {
  return Lb(ou(e));
}
function Ub(e) {
  return Lb(ou(HA(wt(e)).reverse()));
}
function Md(e, t) {
  bi(t), e = Nb(e);
  const n = wc(e.toString(16).padStart(t * 2, "0"));
  if (n.length !== t)
    throw new Error("number too large");
  return n;
}
function _b(e, t) {
  return Md(e, t).reverse();
}
function HA(e) {
  return Uint8Array.from(e);
}
function WA(e) {
  return Uint8Array.from(e, (t, n) => {
    const r = t.charCodeAt(0);
    if (t.length !== 1 || r > 127)
      throw new Error(`string contains non-ASCII character "${e[n]}" with code ${r} at position ${n}`);
    return r;
  });
}
const ka = (e) => typeof e == "bigint" && Vd <= e;
function KA(e, t, n) {
  return ka(e) && ka(t) && ka(n) && t <= e && e < n;
}
function jA(e, t, n, r) {
  if (!KA(t, n, r))
    throw new Error("expected valid " + e + ": " + n + " <= n < " + r + ", got " + t);
}
function zA(e) {
  let t;
  for (t = 0; e > Vd; e >>= df, t += 1)
    ;
  return t;
}
const Fd = (e) => (df << BigInt(e)) - df;
function qA(e, t, n) {
  if (bi(e, "hashLen"), bi(t, "qByteLen"), typeof n != "function")
    throw new Error("hmacFn must be a function");
  const r = (y) => new Uint8Array(y), i = Uint8Array.of(), s = Uint8Array.of(0), o = Uint8Array.of(1), a = 1e3;
  let c = r(e), u = r(e), l = 0;
  const f = () => {
    c.fill(1), u.fill(0), l = 0;
  }, h = (...y) => n(u, Sn(c, ...y)), g = (y = i) => {
    u = h(s, y), c = h(), y.length !== 0 && (u = h(o, y), c = h());
  }, d = () => {
    if (l++ >= a)
      throw new Error("drbg: tried max amount of iterations");
    let y = 0;
    const x = [];
    for (; y < t; ) {
      c = h();
      const S = c.slice();
      x.push(S), y += c.length;
    }
    return Sn(...x);
  };
  return (y, x) => {
    f(), g(y);
    let S;
    for (; !(S = x(d())); )
      g();
    return f(), S;
  };
}
function Hd(e, t = {}, n = {}) {
  if (!e || typeof e != "object")
    throw new Error("expected valid options object");
  function r(s, o, a) {
    const c = e[s];
    if (a && c === void 0)
      return;
    const u = typeof c;
    if (u !== o || c === null)
      throw new Error(`param "${s}" is invalid: expected ${o}, got ${u}`);
  }
  const i = (s, o) => Object.entries(s).forEach(([a, c]) => r(a, c, o));
  i(t, !1), i(n, !0);
}
function Eg(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return (n, ...r) => {
    const i = t.get(n);
    if (i !== void 0)
      return i;
    const s = e(n, ...r);
    return t.set(n, s), s;
  };
}
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const Db = {
  p: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,
  n: 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,
  h: 1n,
  a: 0n,
  b: 7n,
  Gx: 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,
  Gy: 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n
}, { p: Ar, n: Vr, Gx: GA, Gy: YA, b: Vb } = Db, Kt = 32, Ei = 64, bc = {
  publicKey: Kt + 1,
  publicKeyUncompressed: Ei + 1,
  signature: Ei,
  seed: Kt + Kt / 2
}, ZA = (...e) => {
  "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(...e);
}, pt = (e = "") => {
  const t = new Error(e);
  throw ZA(t, pt), t;
}, XA = (e) => typeof e == "bigint", QA = (e) => typeof e == "string", JA = (e) => e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array", be = (e, t, n = "") => {
  const r = JA(e), i = e?.length, s = t !== void 0;
  if (!r || s && i !== t) {
    const o = n && `"${n}" `, a = s ? ` of length ${t}` : "", c = r ? `length=${i}` : `type=${typeof e}`;
    pt(o + "expected Uint8Array" + a + ", got " + c);
  }
  return e;
}, Mr = (e) => new Uint8Array(e), Mb = (e, t) => e.toString(16).padStart(t, "0"), Fb = (e) => Array.from(be(e)).map((t) => Mb(t, 2)).join(""), Un = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }, xg = (e) => {
  if (e >= Un._0 && e <= Un._9)
    return e - Un._0;
  if (e >= Un.A && e <= Un.F)
    return e - (Un.A - 10);
  if (e >= Un.a && e <= Un.f)
    return e - (Un.a - 10);
}, Hb = (e) => {
  const t = "hex invalid";
  if (!QA(e))
    return pt(t);
  const n = e.length, r = n / 2;
  if (n % 2)
    return pt(t);
  const i = Mr(r);
  for (let s = 0, o = 0; s < r; s++, o += 2) {
    const a = xg(e.charCodeAt(o)), c = xg(e.charCodeAt(o + 1));
    if (a === void 0 || c === void 0)
      return pt(t);
    i[s] = a * 16 + c;
  }
  return i;
}, Wb = () => globalThis?.crypto, Tg = () => Wb()?.subtle ?? pt("crypto.subtle must be defined, consider polyfill"), Cn = (...e) => {
  const t = Mr(e.reduce((r, i) => r + be(i).length, 0));
  let n = 0;
  return e.forEach((r) => {
    t.set(r, n), n += r.length;
  }), t;
}, cu = (e = Kt) => Wb().getRandomValues(Mr(e)), mo = BigInt, xi = (e, t, n, r = "bad number: out of range") => XA(e) && t <= e && e < n ? e : pt(r), G = (e, t = Ar) => {
  const n = e % t;
  return n >= 0n ? n : t + n;
}, Wn = (e) => G(e, Vr), Kb = (e, t) => {
  (e === 0n || t <= 0n) && pt("no inverse n=" + e + " mod=" + t);
  let n = G(e, t), r = t, i = 0n, s = 1n;
  for (; n !== 0n; ) {
    const o = r / n, a = r % n, c = i - s * o;
    r = n, n = a, i = s, s = c;
  }
  return r === 1n ? G(i, t) : pt("no inverse");
}, jb = (e) => {
  const t = lu[e];
  return typeof t != "function" && pt("hashes." + e + " not set"), t;
}, rl = (e) => e instanceof ie ? e : pt("Point expected"), zb = (e) => G(G(e * e) * e + Vb), Sg = (e) => xi(e, 0n, Ar), Aa = (e) => xi(e, 1n, Ar), hf = (e) => xi(e, 1n, Vr), ls = (e) => (e & 1n) === 0n, uu = (e) => Uint8Array.of(e), t$ = (e) => uu(ls(e) ? 2 : 3), qb = (e) => {
  const t = zb(Aa(e));
  let n = 1n;
  for (let r = t, i = (Ar + 1n) / 4n; i > 0n; i >>= 1n)
    i & 1n && (n = n * r % Ar), r = r * r % Ar;
  return G(n * n) === t ? n : pt("sqrt invalid");
};
class ie {
  static BASE;
  static ZERO;
  X;
  Y;
  Z;
  constructor(t, n, r) {
    this.X = Sg(t), this.Y = Aa(n), this.Z = Sg(r), Object.freeze(this);
  }
  static CURVE() {
    return Db;
  }
  /** Create 3d xyz point from 2d xy. (0, 0) => (0, 1, 0), not (0, 0, 1) */
  static fromAffine(t) {
    const { x: n, y: r } = t;
    return n === 0n && r === 0n ? Jr : new ie(n, r, 1n);
  }
  /** Convert Uint8Array or hex string to Point. */
  static fromBytes(t) {
    be(t);
    const { publicKey: n, publicKeyUncompressed: r } = bc;
    let i;
    const s = t.length, o = t[0], a = t.subarray(1), c = fs(a, 0, Kt);
    if (s === n && (o === 2 || o === 3)) {
      let u = qb(c);
      const l = ls(u);
      ls(mo(o)) !== l && (u = G(-u)), i = new ie(c, u, 1n);
    }
    return s === r && o === 4 && (i = new ie(c, fs(a, Kt, Ei), 1n)), i ? i.assertValidity() : pt("bad point: not on curve");
  }
  static fromHex(t) {
    return ie.fromBytes(Hb(t));
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  /** Equality check: compare points P&Q. */
  equals(t) {
    const { X: n, Y: r, Z: i } = this, { X: s, Y: o, Z: a } = rl(t), c = G(n * a), u = G(s * i), l = G(r * a), f = G(o * i);
    return c === u && l === f;
  }
  is0() {
    return this.equals(Jr);
  }
  /** Flip point over y coordinate. */
  negate() {
    return new ie(this.X, G(-this.Y), this.Z);
  }
  /** Point doubling: P+P, complete formula. */
  double() {
    return this.add(this);
  }
  /**
   * Point addition: P+Q, complete, exception-free formula
   * (Renes-Costello-Batina, algo 1 of [2015/1060](https://eprint.iacr.org/2015/1060)).
   * Cost: `12M + 0S + 3*a + 3*b3 + 23add`.
   */
  // prettier-ignore
  add(t) {
    const { X: n, Y: r, Z: i } = this, { X: s, Y: o, Z: a } = rl(t), c = 0n, u = Vb;
    let l = 0n, f = 0n, h = 0n;
    const g = G(u * 3n);
    let d = G(n * s), p = G(r * o), y = G(i * a), x = G(n + r), S = G(s + o);
    x = G(x * S), S = G(d + p), x = G(x - S), S = G(n + i);
    let A = G(s + a);
    return S = G(S * A), A = G(d + y), S = G(S - A), A = G(r + i), l = G(o + a), A = G(A * l), l = G(p + y), A = G(A - l), h = G(c * S), l = G(g * y), h = G(l + h), l = G(p - h), h = G(p + h), f = G(l * h), p = G(d + d), p = G(p + d), y = G(c * y), S = G(g * S), p = G(p + y), y = G(d - y), y = G(c * y), S = G(S + y), d = G(p * S), f = G(f + d), d = G(A * S), l = G(x * l), l = G(l - d), d = G(x * p), h = G(A * h), h = G(h + d), new ie(l, f, h);
  }
  subtract(t) {
    return this.add(rl(t).negate());
  }
  /**
   * Point-by-scalar multiplication. Scalar must be in range 1 <= n < CURVE.n.
   * Uses {@link wNAF} for base point.
   * Uses fake point to mitigate side-channel leakage.
   * @param n scalar by which point is multiplied
   * @param safe safe mode guards against timing attacks; unsafe mode is faster
   */
  multiply(t, n = !0) {
    if (!n && t === 0n)
      return Jr;
    if (hf(t), t === 1n)
      return this;
    if (this.equals(Fr))
      return A$(t).p;
    let r = Jr, i = Fr;
    for (let s = this; t > 0n; s = s.double(), t >>= 1n)
      t & 1n ? r = r.add(s) : n && (i = i.add(s));
    return r;
  }
  multiplyUnsafe(t) {
    return this.multiply(t, !1);
  }
  /** Convert point to 2d xy affine point. (X, Y, Z) ‚àã (x=X/Z, y=Y/Z) */
  toAffine() {
    const { X: t, Y: n, Z: r } = this;
    if (this.equals(Jr))
      return { x: 0n, y: 0n };
    if (r === 1n)
      return { x: t, y: n };
    const i = Kb(r, Ar);
    return G(r * i) !== 1n && pt("inverse invalid"), { x: G(t * i), y: G(n * i) };
  }
  /** Checks if the point is valid and on-curve. */
  assertValidity() {
    const { x: t, y: n } = this.toAffine();
    return Aa(t), Aa(n), G(n * n) === zb(t) ? this : pt("bad point: not on curve");
  }
  /** Converts point to 33/65-byte Uint8Array. */
  toBytes(t = !0) {
    const { x: n, y: r } = this.assertValidity().toAffine(), i = Te(n);
    return t ? Cn(t$(r), i) : Cn(uu(4), i, Te(r));
  }
  toHex(t) {
    return Fb(this.toBytes(t));
  }
}
const Fr = new ie(GA, YA, 1n), Jr = new ie(0n, 1n, 0n);
ie.BASE = Fr;
ie.ZERO = Jr;
const e$ = (e, t, n) => Fr.multiply(t, !1).add(e.multiply(n, !1)).assertValidity(), Kr = (e) => mo("0x" + (Fb(e) || "0")), fs = (e, t, n) => Kr(e.subarray(t, n)), n$ = 2n ** 256n, Te = (e) => Hb(Mb(xi(e, 0n, n$), Ei)), Gb = (e) => {
  const t = Kr(be(e, Kt, "secret key"));
  return xi(t, 1n, Vr, "invalid secret key: outside of range");
}, Yb = (e) => e > Vr >> 1n, r$ = (e) => {
  [0, 1, 2, 3].includes(e) || pt("recovery id must be valid and present");
}, i$ = (e) => {
  e != null && !vg.includes(e) && pt(`Signature format must be one of: ${vg.join(", ")}`), e === Xb && pt('Signature format "der" is not supported: switch to noble-curves');
}, s$ = (e, t = ds) => {
  i$(t);
  const n = bc.signature, r = n + 1;
  let i = `Signature format "${t}" expects Uint8Array with length `;
  t === ds && e.length !== n && pt(i + n), t === xc && e.length !== r && pt(i + r);
};
class Ec {
  r;
  s;
  recovery;
  constructor(t, n, r) {
    this.r = hf(t), this.s = hf(n), r != null && (this.recovery = r), Object.freeze(this);
  }
  static fromBytes(t, n = ds) {
    s$(t, n);
    let r;
    n === xc && (r = t[0], t = t.subarray(1));
    const i = fs(t, 0, Kt), s = fs(t, Kt, Ei);
    return new Ec(i, s, r);
  }
  addRecoveryBit(t) {
    return new Ec(this.r, this.s, t);
  }
  hasHighS() {
    return Yb(this.s);
  }
  toBytes(t = ds) {
    const { r: n, s: r, recovery: i } = this, s = Cn(Te(n), Te(r));
    return t === xc ? (r$(i), Cn(Uint8Array.of(i), s)) : s;
  }
}
const Zb = (e) => {
  const t = e.length * 8 - 256;
  t > 1024 && pt("msg invalid");
  const n = Kr(e);
  return t > 0 ? n >> mo(t) : n;
}, o$ = (e) => Wn(Zb(be(e))), ds = "compact", xc = "recovered", Xb = "der", vg = [ds, xc, Xb], kg = {
  lowS: !0,
  prehash: !0,
  format: ds,
  extraEntropy: !1
}, Ag = "SHA-256", lu = {
  hmacSha256Async: async (e, t) => {
    const n = Tg(), r = "HMAC", i = await n.importKey("raw", e, { name: r, hash: { name: Ag } }, !1, ["sign"]);
    return Mr(await n.sign(r, i, t));
  },
  hmacSha256: void 0,
  sha256Async: async (e) => Mr(await Tg().digest(Ag, e)),
  sha256: void 0
}, a$ = (e, t, n) => (be(e, void 0, "message"), t.prehash ? n ? lu.sha256Async(e) : jb("sha256")(e) : e), c$ = Mr(0), u$ = uu(0), l$ = uu(1), f$ = 1e3, d$ = "drbg: tried max amount of iterations", h$ = async (e, t) => {
  let n = Mr(Kt), r = Mr(Kt), i = 0;
  const s = () => {
    n.fill(1), r.fill(0);
  }, o = (...l) => lu.hmacSha256Async(r, Cn(n, ...l)), a = async (l = c$) => {
    r = await o(u$, l), n = await o(), l.length !== 0 && (r = await o(l$, l), n = await o());
  }, c = async () => (i++ >= f$ && pt(d$), n = await o(), n);
  s(), await a(e);
  let u;
  for (; !(u = t(await c())); )
    await a();
  return s(), u;
}, p$ = (e, t, n, r) => {
  let { lowS: i, extraEntropy: s } = n;
  const o = Te, a = o$(e), c = o(a), u = Gb(t), l = [o(u), c];
  if (s != null && s !== !1) {
    const d = s === !0 ? cu(Kt) : s;
    l.push(be(d, void 0, "extraEntropy"));
  }
  const f = Cn(...l), h = a;
  return r(f, (d) => {
    const p = Zb(d);
    if (!(1n <= p && p < Vr))
      return;
    const y = Kb(p, Vr), x = Fr.multiply(p).toAffine(), S = Wn(x.x);
    if (S === 0n)
      return;
    const A = Wn(y * Wn(h + S * u));
    if (A === 0n)
      return;
    let R = (x.x === S ? 0 : 2) | Number(x.y & 1n), N = A;
    return i && Yb(A) && (N = Wn(-A), R ^= 1), new Ec(S, N, R).toBytes(n.format);
  });
}, g$ = (e) => {
  const t = {};
  return Object.keys(kg).forEach((n) => {
    t[n] = e[n] ?? kg[n];
  }), t;
}, y$ = async (e, t, n = {}) => (n = g$(n), e = await a$(e, n, !0), p$(e, t, n, h$)), w$ = (e = cu(bc.seed)) => {
  be(e), (e.length < bc.seed || e.length > 1024) && pt("expected 40-1024b");
  const t = G(Kr(e), Vr - 1n);
  return Te(t + 1n);
}, m$ = (e) => (t) => {
  const n = w$(t);
  return { secretKey: n, publicKey: e(n) };
}, Qb = (e) => Uint8Array.from("BIP0340/" + e, (t) => t.charCodeAt(0)), Jb = "aux", t0 = "nonce", e0 = "challenge", pf = (e, ...t) => {
  const n = jb("sha256"), r = n(Qb(e));
  return n(Cn(r, r, ...t));
}, gf = async (e, ...t) => {
  const n = lu.sha256Async, r = await n(Qb(e));
  return await n(Cn(r, r, ...t));
}, Wd = (e) => {
  const t = Gb(e), n = Fr.multiply(t), { x: r, y: i } = n.assertValidity().toAffine(), s = ls(i) ? t : Wn(-t), o = Te(r);
  return { d: s, px: o };
}, Kd = (e) => Wn(Kr(e)), n0 = (...e) => Kd(pf(e0, ...e)), r0 = async (...e) => Kd(await gf(e0, ...e)), i0 = (e) => Wd(e).px, b$ = m$(i0), s0 = (e, t, n) => {
  const { px: r, d: i } = Wd(t);
  return { m: be(e), px: r, d: i, a: be(n, Kt) };
}, o0 = (e) => {
  const t = Kd(e);
  t === 0n && pt("sign failed: k is zero");
  const { px: n, d: r } = Wd(Te(t));
  return { rx: n, k: r };
}, a0 = (e, t, n, r) => Cn(t, Te(Wn(e + n * r))), c0 = "invalid signature produced", E$ = (e, t, n = cu(Kt)) => {
  const { m: r, px: i, d: s, a: o } = s0(e, t, n), a = pf(Jb, o), c = Te(s ^ Kr(a)), u = pf(t0, c, i, r), { rx: l, k: f } = o0(u), h = n0(l, i, r), g = a0(f, l, h, s);
  return l0(g, r, i) || pt(c0), g;
}, x$ = async (e, t, n = cu(Kt)) => {
  const { m: r, px: i, d: s, a: o } = s0(e, t, n), a = await gf(Jb, o), c = Te(s ^ Kr(a)), u = await gf(t0, c, i, r), { rx: l, k: f } = o0(u), h = await r0(l, i, r), g = a0(f, l, h, s);
  return await f0(g, r, i) || pt(c0), g;
}, T$ = (e, t) => e instanceof Promise ? e.then(t) : t(e), u0 = (e, t, n, r) => {
  const i = be(e, Ei, "signature"), s = be(t, void 0, "message"), o = be(n, Kt, "publicKey");
  try {
    const a = Kr(o), c = qb(a), u = ls(c) ? c : G(-c), l = new ie(a, u, 1n).assertValidity(), f = Te(l.toAffine().x), h = fs(i, 0, Kt);
    xi(h, 1n, Ar);
    const g = fs(i, Kt, Ei);
    xi(g, 1n, Vr);
    const d = Cn(Te(h), f, s);
    return T$(r(d), (p) => {
      const { x: y, y: x } = e$(l, g, Wn(-p)).toAffine();
      return !(!ls(x) || y !== h);
    });
  } catch {
    return !1;
  }
}, l0 = (e, t, n) => u0(e, t, n, n0), f0 = async (e, t, n) => u0(e, t, n, r0), S$ = {
  keygen: b$,
  getPublicKey: i0,
  sign: E$,
  verify: l0,
  signAsync: x$,
  verifyAsync: f0
}, Tc = 8, v$ = 256, d0 = Math.ceil(v$ / Tc) + 1, yf = 2 ** (Tc - 1), k$ = () => {
  const e = [];
  let t = Fr, n = t;
  for (let r = 0; r < d0; r++) {
    n = t, e.push(n);
    for (let i = 1; i < yf; i++)
      n = n.add(t), e.push(n);
    t = n.double();
  }
  return e;
};
let $g;
const Ig = (e, t) => {
  const n = t.negate();
  return e ? n : t;
}, A$ = (e) => {
  const t = $g || ($g = k$());
  let n = Jr, r = Fr;
  const i = 2 ** Tc, s = i, o = mo(i - 1), a = mo(Tc);
  for (let c = 0; c < d0; c++) {
    let u = Number(e & o);
    e >>= a, u > yf && (u -= s, e += 1n);
    const l = c * yf, f = l, h = l + Math.abs(u) - 1, g = c % 2 !== 0, d = u < 0;
    u === 0 ? r = r.add(Ig(g, t[f])) : n = n.add(Ig(d, t[h]));
  }
  return e !== 0n && pt("invalid wnaf"), { p: n, f: r };
};
function $$(e, t, n) {
  return e & t ^ ~e & n;
}
function I$(e, t, n) {
  return e & t ^ e & n ^ t & n;
}
class O$ {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = !1;
  length = 0;
  pos = 0;
  destroyed = !1;
  constructor(t, n, r, i) {
    this.blockLen = t, this.outputLen = n, this.padOffset = r, this.isLE = i, this.buffer = new Uint8Array(t), this.view = nl(this.buffer);
  }
  update(t) {
    gc(this), wt(t);
    const { view: n, buffer: r, blockLen: i } = this, s = t.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = nl(t);
        for (; i <= s - o; o += i)
          this.process(c, o);
        continue;
      }
      r.set(t.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(n, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    gc(this), DA(t, this), this.finished = !0;
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    n[o++] = 128, yc(this.buffer.subarray(o)), this.padOffset > i - o && (this.process(r, 0), o = 0);
    for (let f = o; f < i; f++)
      n[f] = 0;
    r.setBigUint64(i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = nl(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      a.setUint32(4 * f, l[f], s);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t ||= new this.constructor(), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a } = this;
    return t.destroyed = o, t.finished = s, t.length = i, t.pos = a, i % n && t.buffer.set(r), t;
  }
  clone() {
    return this._cloneInto();
  }
}
const lr = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), B$ = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), fr = /* @__PURE__ */ new Uint32Array(64);
class C$ extends O$ {
  constructor(t) {
    super(64, t, 8, !1);
  }
  get() {
    const { A: t, B: n, C: r, D: i, E: s, F: o, G: a, H: c } = this;
    return [t, n, r, i, s, o, a, c];
  }
  // prettier-ignore
  set(t, n, r, i, s, o, a, c) {
    this.A = t | 0, this.B = n | 0, this.C = r | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, n) {
    for (let f = 0; f < 16; f++, n += 4)
      fr[f] = t.getUint32(n, !1);
    for (let f = 16; f < 64; f++) {
      const h = fr[f - 15], g = fr[f - 2], d = fn(h, 7) ^ fn(h, 18) ^ h >>> 3, p = fn(g, 17) ^ fn(g, 19) ^ g >>> 10;
      fr[f] = p + fr[f - 7] + d + fr[f - 16] | 0;
    }
    let { A: r, B: i, C: s, D: o, E: a, F: c, G: u, H: l } = this;
    for (let f = 0; f < 64; f++) {
      const h = fn(a, 6) ^ fn(a, 11) ^ fn(a, 25), g = l + h + $$(a, c, u) + B$[f] + fr[f] | 0, p = (fn(r, 2) ^ fn(r, 13) ^ fn(r, 22)) + I$(r, i, s) | 0;
      l = u, u = c, c = a, a = o + g | 0, o = s, s = i, i = r, r = g + p | 0;
    }
    r = r + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, i, s, o, a, c, u, l);
  }
  roundClean() {
    yc(fr);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), yc(this.buffer);
  }
}
class R$ extends C$ {
  // We cannot use array here since array allows indexing by variable
  // which means optimizer/compiler cannot use registers.
  A = lr[0] | 0;
  B = lr[1] | 0;
  C = lr[2] | 0;
  D = lr[3] | 0;
  E = lr[4] | 0;
  F = lr[5] | 0;
  G = lr[6] | 0;
  H = lr[7] | 0;
  constructor() {
    super(32);
  }
}
const wf = /* @__PURE__ */ MA(
  () => new R$(),
  /* @__PURE__ */ FA(1)
);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ae = /* @__PURE__ */ BigInt(0), te = /* @__PURE__ */ BigInt(1), ui = /* @__PURE__ */ BigInt(2), h0 = /* @__PURE__ */ BigInt(3), p0 = /* @__PURE__ */ BigInt(4), g0 = /* @__PURE__ */ BigInt(5), P$ = /* @__PURE__ */ BigInt(7), y0 = /* @__PURE__ */ BigInt(8), N$ = /* @__PURE__ */ BigInt(9), w0 = /* @__PURE__ */ BigInt(16);
function We(e, t) {
  const n = e % t;
  return n >= ae ? n : t + n;
}
function ke(e, t, n) {
  let r = e;
  for (; t-- > ae; )
    r *= r, r %= n;
  return r;
}
function Og(e, t) {
  if (e === ae)
    throw new Error("invert: expected non-zero number");
  if (t <= ae)
    throw new Error("invert: expected positive modulus, got " + t);
  let n = We(e, t), r = t, i = ae, s = te;
  for (; n !== ae; ) {
    const a = r / n, c = r % n, u = i - s * a;
    r = n, n = c, i = s, s = u;
  }
  if (r !== te)
    throw new Error("invert: does not exist");
  return We(i, t);
}
function jd(e, t, n) {
  if (!e.eql(e.sqr(t), n))
    throw new Error("Cannot find square root");
}
function m0(e, t) {
  const n = (e.ORDER + te) / p0, r = e.pow(t, n);
  return jd(e, r, t), r;
}
function L$(e, t) {
  const n = (e.ORDER - g0) / y0, r = e.mul(t, ui), i = e.pow(r, n), s = e.mul(t, i), o = e.mul(e.mul(s, ui), i), a = e.mul(s, e.sub(o, e.ONE));
  return jd(e, a, t), a;
}
function U$(e) {
  const t = fu(e), n = b0(e), r = n(t, t.neg(t.ONE)), i = n(t, r), s = n(t, t.neg(r)), o = (e + P$) / w0;
  return (a, c) => {
    let u = a.pow(c, o), l = a.mul(u, r);
    const f = a.mul(u, i), h = a.mul(u, s), g = a.eql(a.sqr(l), c), d = a.eql(a.sqr(f), c);
    u = a.cmov(u, l, g), l = a.cmov(h, f, d);
    const p = a.eql(a.sqr(l), c), y = a.cmov(u, l, p);
    return jd(a, y, c), y;
  };
}
function b0(e) {
  if (e < h0)
    throw new Error("sqrt is not defined for small field");
  let t = e - te, n = 0;
  for (; t % ui === ae; )
    t /= ui, n++;
  let r = ui;
  const i = fu(e);
  for (; Bg(i, r) === 1; )
    if (r++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (n === 1)
    return m0;
  let s = i.pow(r, t);
  const o = (t + te) / ui;
  return function(c, u) {
    if (c.is0(u))
      return u;
    if (Bg(c, u) !== 1)
      throw new Error("Cannot find square root");
    let l = n, f = c.mul(c.ONE, s), h = c.pow(u, t), g = c.pow(u, o);
    for (; !c.eql(h, c.ONE); ) {
      if (c.is0(h))
        return c.ZERO;
      let d = 1, p = c.sqr(h);
      for (; !c.eql(p, c.ONE); )
        if (d++, p = c.sqr(p), d === l)
          throw new Error("Cannot find square root");
      const y = te << BigInt(l - d - 1), x = c.pow(f, y);
      l = d, f = c.sqr(x), h = c.mul(h, f), g = c.mul(g, x);
    }
    return g;
  };
}
function _$(e) {
  return e % p0 === h0 ? m0 : e % y0 === g0 ? L$ : e % w0 === N$ ? U$(e) : b0(e);
}
const D$ = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function V$(e) {
  const t = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  }, n = D$.reduce((r, i) => (r[i] = "function", r), t);
  return Hd(e, n), e;
}
function M$(e, t, n) {
  if (n < ae)
    throw new Error("invalid exponent, negatives unsupported");
  if (n === ae)
    return e.ONE;
  if (n === te)
    return t;
  let r = e.ONE, i = t;
  for (; n > ae; )
    n & te && (r = e.mul(r, i)), i = e.sqr(i), n >>= te;
  return r;
}
function E0(e, t, n = !1) {
  const r = new Array(t.length).fill(n ? e.ZERO : void 0), i = t.reduce((o, a, c) => e.is0(a) ? o : (r[c] = o, e.mul(o, a)), e.ONE), s = e.inv(i);
  return t.reduceRight((o, a, c) => e.is0(a) ? o : (r[c] = e.mul(o, r[c]), e.mul(o, a)), s), r;
}
function Bg(e, t) {
  const n = (e.ORDER - te) / ui, r = e.pow(t, n), i = e.eql(r, e.ONE), s = e.eql(r, e.ZERO), o = e.eql(r, e.neg(e.ONE));
  if (!i && !s && !o)
    throw new Error("invalid Legendre symbol result");
  return i ? 1 : s ? 0 : -1;
}
function F$(e, t) {
  t !== void 0 && bi(t);
  const n = t !== void 0 ? t : e.toString(2).length, r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
class H$ {
  ORDER;
  BITS;
  BYTES;
  isLE;
  ZERO = ae;
  ONE = te;
  _lengths;
  _sqrt;
  // cached sqrt
  _mod;
  constructor(t, n = {}) {
    if (t <= ae)
      throw new Error("invalid field: expected ORDER > 0, got " + t);
    let r;
    this.isLE = !1, n != null && typeof n == "object" && (typeof n.BITS == "number" && (r = n.BITS), typeof n.sqrt == "function" && (this.sqrt = n.sqrt), typeof n.isLE == "boolean" && (this.isLE = n.isLE), n.allowedLengths && (this._lengths = n.allowedLengths?.slice()), typeof n.modFromBytes == "boolean" && (this._mod = n.modFromBytes));
    const { nBitLength: i, nByteLength: s } = F$(t, r);
    if (s > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = t, this.BITS = i, this.BYTES = s, this._sqrt = void 0, Object.preventExtensions(this);
  }
  create(t) {
    return We(t, this.ORDER);
  }
  isValid(t) {
    if (typeof t != "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof t);
    return ae <= t && t < this.ORDER;
  }
  is0(t) {
    return t === ae;
  }
  // is valid and invertible
  isValidNot0(t) {
    return !this.is0(t) && this.isValid(t);
  }
  isOdd(t) {
    return (t & te) === te;
  }
  neg(t) {
    return We(-t, this.ORDER);
  }
  eql(t, n) {
    return t === n;
  }
  sqr(t) {
    return We(t * t, this.ORDER);
  }
  add(t, n) {
    return We(t + n, this.ORDER);
  }
  sub(t, n) {
    return We(t - n, this.ORDER);
  }
  mul(t, n) {
    return We(t * n, this.ORDER);
  }
  pow(t, n) {
    return M$(this, t, n);
  }
  div(t, n) {
    return We(t * Og(n, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(t) {
    return t * t;
  }
  addN(t, n) {
    return t + n;
  }
  subN(t, n) {
    return t - n;
  }
  mulN(t, n) {
    return t * n;
  }
  inv(t) {
    return Og(t, this.ORDER);
  }
  sqrt(t) {
    return this._sqrt || (this._sqrt = _$(this.ORDER)), this._sqrt(this, t);
  }
  toBytes(t) {
    return this.isLE ? _b(t, this.BYTES) : Md(t, this.BYTES);
  }
  fromBytes(t, n = !1) {
    wt(t);
    const { _lengths: r, BYTES: i, isLE: s, ORDER: o, _mod: a } = this;
    if (r) {
      if (!r.includes(t.length) || t.length > i)
        throw new Error("Field.fromBytes: expected " + r + " bytes, got " + t.length);
      const u = new Uint8Array(i);
      u.set(t, s ? 0 : u.length - t.length), t = u;
    }
    if (t.length !== i)
      throw new Error("Field.fromBytes: expected " + i + " bytes, got " + t.length);
    let c = s ? Ub(t) : Ss(t);
    if (a && (c = We(c, o)), !n && !this.isValid(c))
      throw new Error("invalid field element: outside of range 0..ORDER");
    return c;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(t) {
    return E0(this, t);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(t, n, r) {
    return r ? n : t;
  }
}
function fu(e, t = {}) {
  return new H$(e, t);
}
function x0(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function T0(e) {
  const t = x0(e);
  return t + Math.ceil(t / 2);
}
function S0(e, t, n = !1) {
  wt(e);
  const r = e.length, i = x0(t), s = T0(t);
  if (r < 16 || r < s || r > 1024)
    throw new Error("expected " + s + "-1024 bytes of input, got " + r);
  const o = n ? Ub(e) : Ss(e), a = We(o, t - te) + te;
  return n ? _b(a, i) : Md(a, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hs = /* @__PURE__ */ BigInt(0), li = /* @__PURE__ */ BigInt(1);
function Sc(e, t) {
  const n = t.negate();
  return e ? n : t;
}
function Cg(e, t) {
  const n = E0(e.Fp, t.map((r) => r.Z));
  return t.map((r, i) => e.fromAffine(r.toAffine(n[i])));
}
function v0(e, t) {
  if (!Number.isSafeInteger(e) || e <= 0 || e > t)
    throw new Error("invalid window size, expected [1.." + t + "], got W=" + e);
}
function il(e, t) {
  v0(e, t);
  const n = Math.ceil(t / e) + 1, r = 2 ** (e - 1), i = 2 ** e, s = Fd(e), o = BigInt(e);
  return { windows: n, windowSize: r, mask: s, maxNumber: i, shiftBy: o };
}
function Rg(e, t, n) {
  const { windowSize: r, mask: i, maxNumber: s, shiftBy: o } = n;
  let a = Number(e & i), c = e >> o;
  a > r && (a -= s, c += li);
  const u = t * r, l = u + Math.abs(a) - 1, f = a === 0, h = a < 0, g = t % 2 !== 0;
  return { nextN: c, offset: l, isZero: f, isNeg: h, isNegF: g, offsetF: u };
}
const sl = /* @__PURE__ */ new WeakMap(), k0 = /* @__PURE__ */ new WeakMap();
function ol(e) {
  return k0.get(e) || 1;
}
function Pg(e) {
  if (e !== hs)
    throw new Error("invalid wNAF");
}
class W$ {
  BASE;
  ZERO;
  Fn;
  bits;
  // Parametrized with a given Point class (not individual point)
  constructor(t, n) {
    this.BASE = t.BASE, this.ZERO = t.ZERO, this.Fn = t.Fn, this.bits = n;
  }
  // non-const time multiplication ladder
  _unsafeLadder(t, n, r = this.ZERO) {
    let i = t;
    for (; n > hs; )
      n & li && (r = r.add(i)), i = i.double(), n >>= li;
    return r;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:
   * - ùëä is the window size
   * - ùëõ is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(t, n) {
    const { windows: r, windowSize: i } = il(n, this.bits), s = [];
    let o = t, a = o;
    for (let c = 0; c < r; c++) {
      a = o, s.push(a);
      for (let u = 1; u < i; u++)
        a = a.add(o), s.push(a);
      o = a.double();
    }
    return s;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(t, n, r) {
    if (!this.Fn.isValid(r))
      throw new Error("invalid scalar");
    let i = this.ZERO, s = this.BASE;
    const o = il(t, this.bits);
    for (let a = 0; a < o.windows; a++) {
      const { nextN: c, offset: u, isZero: l, isNeg: f, isNegF: h, offsetF: g } = Rg(r, a, o);
      r = c, l ? s = s.add(Sc(h, n[g])) : i = i.add(Sc(f, n[u]));
    }
    return Pg(r), { p: i, f: s };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(t, n, r, i = this.ZERO) {
    const s = il(t, this.bits);
    for (let o = 0; o < s.windows && r !== hs; o++) {
      const { nextN: a, offset: c, isZero: u, isNeg: l } = Rg(r, o, s);
      if (r = a, !u) {
        const f = n[c];
        i = i.add(l ? f.negate() : f);
      }
    }
    return Pg(r), i;
  }
  getPrecomputes(t, n, r) {
    let i = sl.get(n);
    return i || (i = this.precomputeWindow(n, t), t !== 1 && (typeof r == "function" && (i = r(i)), sl.set(n, i))), i;
  }
  cached(t, n, r) {
    const i = ol(t);
    return this.wNAF(i, this.getPrecomputes(i, t, r), n);
  }
  unsafe(t, n, r, i) {
    const s = ol(t);
    return s === 1 ? this._unsafeLadder(t, n, i) : this.wNAFUnsafe(s, this.getPrecomputes(s, t, r), n, i);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(t, n) {
    v0(n, this.bits), k0.set(t, n), sl.delete(t);
  }
  hasCache(t) {
    return ol(t) !== 1;
  }
}
function K$(e, t, n, r) {
  let i = t, s = e.ZERO, o = e.ZERO;
  for (; n > hs || r > hs; )
    n & li && (s = s.add(i)), r & li && (o = o.add(i)), i = i.double(), n >>= li, r >>= li;
  return { p1: s, p2: o };
}
function Ng(e, t, n) {
  if (t) {
    if (t.ORDER !== e)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return V$(t), t;
  } else
    return fu(e, { isLE: n });
}
function j$(e, t, n = {}, r) {
  if (r === void 0 && (r = e === "edwards"), !t || typeof t != "object")
    throw new Error(`expected valid ${e} CURVE object`);
  for (const c of ["p", "n", "h"]) {
    const u = t[c];
    if (!(typeof u == "bigint" && u > hs))
      throw new Error(`CURVE.${c} must be positive bigint`);
  }
  const i = Ng(t.p, n.Fp, r), s = Ng(t.n, n.Fn, r), a = ["Gx", "Gy", "a", "b"];
  for (const c of a)
    if (!i.isValid(t[c]))
      throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);
  return t = Object.freeze(Object.assign({}, t)), { CURVE: t, Fp: i, Fn: s };
}
function A0(e, t) {
  return function(r) {
    const i = e(r);
    return { secretKey: i, publicKey: t(i) };
  };
}
class $0 {
  oHash;
  iHash;
  blockLen;
  outputLen;
  finished = !1;
  destroyed = !1;
  constructor(t, n) {
    if (Rb(t), wt(n, void 0, "key"), this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const r = this.blockLen, i = new Uint8Array(r);
    i.set(n.length > r ? t.create().update(n).digest() : n);
    for (let s = 0; s < i.length; s++)
      i[s] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let s = 0; s < i.length; s++)
      i[s] ^= 106;
    this.oHash.update(i), yc(i);
  }
  update(t) {
    return gc(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    gc(this), wt(t, this.outputLen, "output"), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t ||= Object.create(Object.getPrototypeOf(this), {});
    const { oHash: n, iHash: r, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;
    return t = t, t.finished = i, t.destroyed = s, t.blockLen = o, t.outputLen = a, t.oHash = n._cloneInto(t.oHash), t.iHash = r._cloneInto(t.iHash), t;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const I0 = (e, t, n) => new $0(e, t).update(n).digest();
I0.create = (e, t) => new $0(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Lg = (e, t) => (e + (e >= 0 ? t : -t) / O0) / t;
function z$(e, t, n) {
  const [[r, i], [s, o]] = t, a = Lg(o * e, n), c = Lg(-i * e, n);
  let u = e - a * r - c * s, l = -a * i - c * o;
  const f = u < Kn, h = l < Kn;
  f && (u = -u), h && (l = -l);
  const g = Fd(Math.ceil(zA(n) / 2)) + zi;
  if (u < Kn || u >= g || l < Kn || l >= g)
    throw new Error("splitScalar (endomorphism): failed, k=" + e);
  return { k1neg: f, k1: u, k2neg: h, k2: l };
}
function mf(e) {
  if (!["compact", "recovered", "der"].includes(e))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return e;
}
function al(e, t) {
  const n = {};
  for (let r of Object.keys(t))
    n[r] = e[r] === void 0 ? t[r] : e[r];
  return mc(n.lowS, "lowS"), mc(n.prehash, "prehash"), n.format !== void 0 && mf(n.format), n;
}
class q$ extends Error {
  constructor(t = "") {
    super(t);
  }
}
const yr = {
  // asn.1 DER encoding utils
  Err: q$,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, t) => {
      const { Err: n } = yr;
      if (e < 0 || e > 256)
        throw new n("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new n("tlv.encode: unpadded data");
      const r = t.length / 2, i = Go(r);
      if (i.length / 2 & 128)
        throw new n("tlv.encode: long form length too big");
      const s = r > 127 ? Go(i.length / 2 | 128) : "";
      return Go(e) + s + i + t;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, t) {
      const { Err: n } = yr;
      let r = 0;
      if (e < 0 || e > 256)
        throw new n("tlv.encode: wrong tag");
      if (t.length < 2 || t[r++] !== e)
        throw new n("tlv.decode: wrong tlv");
      const i = t[r++], s = !!(i & 128);
      let o = 0;
      if (!s)
        o = i;
      else {
        const c = i & 127;
        if (!c)
          throw new n("tlv.decode(long): indefinite length not supported");
        if (c > 4)
          throw new n("tlv.decode(long): byte length is too big");
        const u = t.subarray(r, r + c);
        if (u.length !== c)
          throw new n("tlv.decode: length bytes not complete");
        if (u[0] === 0)
          throw new n("tlv.decode(long): zero leftmost byte");
        for (const l of u)
          o = o << 8 | l;
        if (r += c, o < 128)
          throw new n("tlv.decode(long): not minimal encoding");
      }
      const a = t.subarray(r, r + o);
      if (a.length !== o)
        throw new n("tlv.decode: wrong value length");
      return { v: a, l: t.subarray(r + o) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: t } = yr;
      if (e < Kn)
        throw new t("integer: negative integers are not allowed");
      let n = Go(e);
      if (Number.parseInt(n[0], 16) & 8 && (n = "00" + n), n.length & 1)
        throw new t("unexpected DER parsing assertion: unpadded hex");
      return n;
    },
    decode(e) {
      const { Err: t } = yr;
      if (e[0] & 128)
        throw new t("invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new t("invalid signature integer: unnecessary leading zero");
      return Ss(e);
    }
  },
  toSig(e) {
    const { Err: t, _int: n, _tlv: r } = yr, i = wt(e, void 0, "signature"), { v: s, l: o } = r.decode(48, i);
    if (o.length)
      throw new t("invalid signature: left bytes after parsing");
    const { v: a, l: c } = r.decode(2, s), { v: u, l } = r.decode(2, c);
    if (l.length)
      throw new t("invalid signature: left bytes after parsing");
    return { r: n.decode(a), s: n.decode(u) };
  },
  hexFromSig(e) {
    const { _tlv: t, _int: n } = yr, r = t.encode(2, n.encode(e.r)), i = t.encode(2, n.encode(e.s)), s = r + i;
    return t.encode(48, s);
  }
}, Kn = BigInt(0), zi = BigInt(1), O0 = BigInt(2), Yo = BigInt(3), G$ = BigInt(4);
function Y$(e, t = {}) {
  const n = j$("weierstrass", e, t), { Fp: r, Fn: i } = n;
  let s = n.CURVE;
  const { h: o, n: a } = s;
  Hd(t, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo: c } = t;
  if (c && (!r.is0(s.a) || typeof c.beta != "bigint" || !Array.isArray(c.basises)))
    throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const u = C0(r, i);
  function l() {
    if (!r.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function f(v, b, E) {
    const { x: m, y: T } = b.toAffine(), k = r.toBytes(m);
    if (mc(E, "isCompressed"), E) {
      l();
      const P = !r.isOdd(T);
      return Sn(B0(P), k);
    } else
      return Sn(Uint8Array.of(4), k, r.toBytes(T));
  }
  function h(v) {
    wt(v, void 0, "Point");
    const { publicKey: b, publicKeyUncompressed: E } = u, m = v.length, T = v[0], k = v.subarray(1);
    if (m === b && (T === 2 || T === 3)) {
      const P = r.fromBytes(k);
      if (!r.isValid(P))
        throw new Error("bad point: is not on curve, wrong x");
      const O = p(P);
      let I;
      try {
        I = r.sqrt(O);
      } catch (z) {
        const H = z instanceof Error ? ": " + z.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + H);
      }
      l();
      const $ = r.isOdd(I);
      return (T & 1) === 1 !== $ && (I = r.neg(I)), { x: P, y: I };
    } else if (m === E && T === 4) {
      const P = r.BYTES, O = r.fromBytes(k.subarray(0, P)), I = r.fromBytes(k.subarray(P, P * 2));
      if (!y(O, I))
        throw new Error("bad point: is not on curve");
      return { x: O, y: I };
    } else
      throw new Error(`bad point: got length ${m}, expected compressed=${b} or uncompressed=${E}`);
  }
  const g = t.toBytes || f, d = t.fromBytes || h;
  function p(v) {
    const b = r.sqr(v), E = r.mul(b, v);
    return r.add(r.add(E, r.mul(v, s.a)), s.b);
  }
  function y(v, b) {
    const E = r.sqr(b), m = p(v);
    return r.eql(E, m);
  }
  if (!y(s.Gx, s.Gy))
    throw new Error("bad curve params: generator point");
  const x = r.mul(r.pow(s.a, Yo), G$), S = r.mul(r.sqr(s.b), BigInt(27));
  if (r.is0(r.add(x, S)))
    throw new Error("bad curve params: a or b");
  function A(v, b, E = !1) {
    if (!r.isValid(b) || E && r.is0(b))
      throw new Error(`bad point coordinate ${v}`);
    return b;
  }
  function R(v) {
    if (!(v instanceof U))
      throw new Error("Weierstrass Point expected");
  }
  function N(v) {
    if (!c || !c.basises)
      throw new Error("no endo");
    return z$(v, c.basises, i.ORDER);
  }
  const F = Eg((v, b) => {
    const { X: E, Y: m, Z: T } = v;
    if (r.eql(T, r.ONE))
      return { x: E, y: m };
    const k = v.is0();
    b == null && (b = k ? r.ONE : r.inv(T));
    const P = r.mul(E, b), O = r.mul(m, b), I = r.mul(T, b);
    if (k)
      return { x: r.ZERO, y: r.ZERO };
    if (!r.eql(I, r.ONE))
      throw new Error("invZ was invalid");
    return { x: P, y: O };
  }), w = Eg((v) => {
    if (v.is0()) {
      if (t.allowInfinityPoint && !r.is0(v.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: b, y: E } = v.toAffine();
    if (!r.isValid(b) || !r.isValid(E))
      throw new Error("bad point: x or y not field elements");
    if (!y(b, E))
      throw new Error("bad point: equation left != right");
    if (!v.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  function K(v, b, E, m, T) {
    return E = new U(r.mul(E.X, v), E.Y, E.Z), b = Sc(m, b), E = Sc(T, E), b.add(E);
  }
  class U {
    // base / generator point
    static BASE = new U(s.Gx, s.Gy, r.ONE);
    // zero / infinity / identity point
    static ZERO = new U(r.ZERO, r.ONE, r.ZERO);
    // 0, 1, 0
    // math field
    static Fp = r;
    // scalar field
    static Fn = i;
    X;
    Y;
    Z;
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(b, E, m) {
      this.X = A("x", b), this.Y = A("y", E, !0), this.Z = A("z", m), Object.freeze(this);
    }
    static CURVE() {
      return s;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(b) {
      const { x: E, y: m } = b || {};
      if (!b || !r.isValid(E) || !r.isValid(m))
        throw new Error("invalid affine point");
      if (b instanceof U)
        throw new Error("projective point not allowed");
      return r.is0(E) && r.is0(m) ? U.ZERO : new U(E, m, r.ONE);
    }
    static fromBytes(b) {
      const E = U.fromAffine(d(wt(b, void 0, "point")));
      return E.assertValidity(), E;
    }
    static fromHex(b) {
      return U.fromBytes(wc(b));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(b = 8, E = !0) {
      return B.createCache(this, b), E || this.multiply(Yo), this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      w(this);
    }
    hasEvenY() {
      const { y: b } = this.toAffine();
      if (!r.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !r.isOdd(b);
    }
    /** Compare one point to another. */
    equals(b) {
      R(b);
      const { X: E, Y: m, Z: T } = this, { X: k, Y: P, Z: O } = b, I = r.eql(r.mul(E, O), r.mul(k, T)), $ = r.eql(r.mul(m, O), r.mul(P, T));
      return I && $;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new U(this.X, r.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: b, b: E } = s, m = r.mul(E, Yo), { X: T, Y: k, Z: P } = this;
      let O = r.ZERO, I = r.ZERO, $ = r.ZERO, L = r.mul(T, T), z = r.mul(k, k), H = r.mul(P, P), _ = r.mul(T, k);
      return _ = r.add(_, _), $ = r.mul(T, P), $ = r.add($, $), O = r.mul(b, $), I = r.mul(m, H), I = r.add(O, I), O = r.sub(z, I), I = r.add(z, I), I = r.mul(O, I), O = r.mul(_, O), $ = r.mul(m, $), H = r.mul(b, H), _ = r.sub(L, H), _ = r.mul(b, _), _ = r.add(_, $), $ = r.add(L, L), L = r.add($, L), L = r.add(L, H), L = r.mul(L, _), I = r.add(I, L), H = r.mul(k, P), H = r.add(H, H), L = r.mul(H, _), O = r.sub(O, L), $ = r.mul(H, z), $ = r.add($, $), $ = r.add($, $), new U(O, I, $);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(b) {
      R(b);
      const { X: E, Y: m, Z: T } = this, { X: k, Y: P, Z: O } = b;
      let I = r.ZERO, $ = r.ZERO, L = r.ZERO;
      const z = s.a, H = r.mul(s.b, Yo);
      let _ = r.mul(E, k), j = r.mul(m, P), Y = r.mul(T, O), ot = r.add(E, m), q = r.add(k, P);
      ot = r.mul(ot, q), q = r.add(_, j), ot = r.sub(ot, q), q = r.add(E, T);
      let Q = r.add(k, O);
      return q = r.mul(q, Q), Q = r.add(_, Y), q = r.sub(q, Q), Q = r.add(m, T), I = r.add(P, O), Q = r.mul(Q, I), I = r.add(j, Y), Q = r.sub(Q, I), L = r.mul(z, q), I = r.mul(H, Y), L = r.add(I, L), I = r.sub(j, L), L = r.add(j, L), $ = r.mul(I, L), j = r.add(_, _), j = r.add(j, _), Y = r.mul(z, Y), q = r.mul(H, q), j = r.add(j, Y), Y = r.sub(_, Y), Y = r.mul(z, Y), q = r.add(q, Y), _ = r.mul(j, q), $ = r.add($, _), _ = r.mul(Q, q), I = r.mul(ot, I), I = r.sub(I, _), _ = r.mul(ot, j), L = r.mul(Q, L), L = r.add(L, _), new U(I, $, L);
    }
    subtract(b) {
      return this.add(b.negate());
    }
    is0() {
      return this.equals(U.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(b) {
      const { endo: E } = t;
      if (!i.isValidNot0(b))
        throw new Error("invalid scalar: out of range");
      let m, T;
      const k = (P) => B.cached(this, P, (O) => Cg(U, O));
      if (E) {
        const { k1neg: P, k1: O, k2neg: I, k2: $ } = N(b), { p: L, f: z } = k(O), { p: H, f: _ } = k($);
        T = z.add(_), m = K(E.beta, L, H, P, I);
      } else {
        const { p: P, f: O } = k(b);
        m = P, T = O;
      }
      return Cg(U, [m, T])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(b) {
      const { endo: E } = t, m = this;
      if (!i.isValid(b))
        throw new Error("invalid scalar: out of range");
      if (b === Kn || m.is0())
        return U.ZERO;
      if (b === zi)
        return m;
      if (B.hasCache(this))
        return this.multiply(b);
      if (E) {
        const { k1neg: T, k1: k, k2neg: P, k2: O } = N(b), { p1: I, p2: $ } = K$(U, m, k, O);
        return K(E.beta, I, $, T, P);
      } else
        return B.unsafe(m, b);
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(b) {
      return F(this, b);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: b } = t;
      return o === zi ? !0 : b ? b(U, this) : B.unsafe(this, a).is0();
    }
    clearCofactor() {
      const { clearCofactor: b } = t;
      return o === zi ? this : b ? b(U, this) : this.multiplyUnsafe(o);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(o).is0();
    }
    toBytes(b = !0) {
      return mc(b, "isCompressed"), this.assertValidity(), g(U, this, b);
    }
    toHex(b = !0) {
      return ou(this.toBytes(b));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  const W = i.BITS, B = new W$(U, t.endo ? Math.ceil(W / 2) : W);
  return U.BASE.precompute(8), U;
}
function B0(e) {
  return Uint8Array.of(e ? 2 : 3);
}
function C0(e, t) {
  return {
    secretKey: t.BYTES,
    publicKey: 1 + e.BYTES,
    publicKeyUncompressed: 1 + 2 * e.BYTES,
    publicKeyHasPrefix: !0,
    signature: 2 * t.BYTES
  };
}
function Z$(e, t = {}) {
  const { Fn: n } = e, r = t.randomBytes || au, i = Object.assign(C0(e.Fp, n), { seed: T0(n.ORDER) });
  function s(g) {
    try {
      const d = n.fromBytes(g);
      return n.isValidNot0(d);
    } catch {
      return !1;
    }
  }
  function o(g, d) {
    const { publicKey: p, publicKeyUncompressed: y } = i;
    try {
      const x = g.length;
      return d === !0 && x !== p || d === !1 && x !== y ? !1 : !!e.fromBytes(g);
    } catch {
      return !1;
    }
  }
  function a(g = r(i.seed)) {
    return S0(wt(g, i.seed, "seed"), n.ORDER);
  }
  function c(g, d = !0) {
    return e.BASE.multiply(n.fromBytes(g)).toBytes(d);
  }
  function u(g) {
    const { secretKey: d, publicKey: p, publicKeyUncompressed: y } = i;
    if (!Dd(g) || "_lengths" in n && n._lengths || d === p)
      return;
    const x = wt(g, void 0, "key").length;
    return x === p || x === y;
  }
  function l(g, d, p = !0) {
    if (u(g) === !0)
      throw new Error("first arg must be private key");
    if (u(d) === !1)
      throw new Error("second arg must be public key");
    const y = n.fromBytes(g);
    return e.fromBytes(d).multiply(y).toBytes(p);
  }
  const f = {
    isValidSecretKey: s,
    isValidPublicKey: o,
    randomSecretKey: a
  }, h = A0(a, c);
  return Object.freeze({ getPublicKey: c, getSharedSecret: l, keygen: h, Point: e, utils: f, lengths: i });
}
function X$(e, t, n = {}) {
  Rb(t), Hd(n, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  }), n = Object.assign({}, n);
  const r = n.randomBytes || au, i = n.hmac || ((E, m) => I0(t, E, m)), { Fp: s, Fn: o } = e, { ORDER: a, BITS: c } = o, { keygen: u, getPublicKey: l, getSharedSecret: f, utils: h, lengths: g } = Z$(e, n), d = {
    prehash: !0,
    lowS: typeof n.lowS == "boolean" ? n.lowS : !0,
    format: "compact",
    extraEntropy: !1
  }, p = a * O0 < s.ORDER;
  function y(E) {
    const m = a >> zi;
    return E > m;
  }
  function x(E, m) {
    if (!o.isValidNot0(m))
      throw new Error(`invalid signature ${E}: out of range 1..Point.Fn.ORDER`);
    return m;
  }
  function S() {
    if (p)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function A(E, m) {
    mf(m);
    const T = g.signature, k = m === "compact" ? T : m === "recovered" ? T + 1 : void 0;
    return wt(E, k);
  }
  class R {
    r;
    s;
    recovery;
    constructor(m, T, k) {
      if (this.r = x("r", m), this.s = x("s", T), k != null) {
        if (S(), ![0, 1, 2, 3].includes(k))
          throw new Error("invalid recovery id");
        this.recovery = k;
      }
      Object.freeze(this);
    }
    static fromBytes(m, T = d.format) {
      A(m, T);
      let k;
      if (T === "der") {
        const { r: $, s: L } = yr.toSig(wt(m));
        return new R($, L);
      }
      T === "recovered" && (k = m[0], T = "compact", m = m.subarray(1));
      const P = g.signature / 2, O = m.subarray(0, P), I = m.subarray(P, P * 2);
      return new R(o.fromBytes(O), o.fromBytes(I), k);
    }
    static fromHex(m, T) {
      return this.fromBytes(wc(m), T);
    }
    assertRecovery() {
      const { recovery: m } = this;
      if (m == null)
        throw new Error("invalid recovery id: must be present");
      return m;
    }
    addRecoveryBit(m) {
      return new R(this.r, this.s, m);
    }
    recoverPublicKey(m) {
      const { r: T, s: k } = this, P = this.assertRecovery(), O = P === 2 || P === 3 ? T + a : T;
      if (!s.isValid(O))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const I = s.toBytes(O), $ = e.fromBytes(Sn(B0((P & 1) === 0), I)), L = o.inv(O), z = F(wt(m, void 0, "msgHash")), H = o.create(-z * L), _ = o.create(k * L), j = e.BASE.multiplyUnsafe(H).add($.multiplyUnsafe(_));
      if (j.is0())
        throw new Error("invalid recovery: point at infinify");
      return j.assertValidity(), j;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return y(this.s);
    }
    toBytes(m = d.format) {
      if (mf(m), m === "der")
        return wc(yr.hexFromSig(this));
      const { r: T, s: k } = this, P = o.toBytes(T), O = o.toBytes(k);
      return m === "recovered" ? (S(), Sn(Uint8Array.of(this.assertRecovery()), P, O)) : Sn(P, O);
    }
    toHex(m) {
      return ou(this.toBytes(m));
    }
  }
  const N = n.bits2int || function(m) {
    if (m.length > 8192)
      throw new Error("input is too large");
    const T = Ss(m), k = m.length * 8 - c;
    return k > 0 ? T >> BigInt(k) : T;
  }, F = n.bits2int_modN || function(m) {
    return o.create(N(m));
  }, w = Fd(c);
  function K(E) {
    return jA("num < 2^" + c, E, Kn, w), o.toBytes(E);
  }
  function U(E, m) {
    return wt(E, void 0, "message"), m ? wt(t(E), void 0, "prehashed message") : E;
  }
  function W(E, m, T) {
    const { lowS: k, prehash: P, extraEntropy: O } = al(T, d);
    E = U(E, P);
    const I = F(E), $ = o.fromBytes(m);
    if (!o.isValidNot0($))
      throw new Error("invalid private key");
    const L = [K($), K(I)];
    if (O != null && O !== !1) {
      const j = O === !0 ? r(g.secretKey) : O;
      L.push(wt(j, void 0, "extraEntropy"));
    }
    const z = Sn(...L), H = I;
    function _(j) {
      const Y = N(j);
      if (!o.isValidNot0(Y))
        return;
      const ot = o.inv(Y), q = e.BASE.multiply(Y).toAffine(), Q = o.create(q.x);
      if (Q === Kn)
        return;
      const ee = o.create(ot * o.create(H + Q * $));
      if (ee === Kn)
        return;
      let Qn = (q.x === Q ? 0 : 2) | Number(q.y & zi), Jn = ee;
      return k && y(ee) && (Jn = o.neg(ee), Qn ^= 1), new R(Q, Jn, p ? void 0 : Qn);
    }
    return { seed: z, k2sig: _ };
  }
  function B(E, m, T = {}) {
    const { seed: k, k2sig: P } = W(E, m, T);
    return qA(t.outputLen, o.BYTES, i)(k, P).toBytes(T.format);
  }
  function v(E, m, T, k = {}) {
    const { lowS: P, prehash: O, format: I } = al(k, d);
    if (T = wt(T, void 0, "publicKey"), m = U(m, O), !Dd(E)) {
      const $ = E instanceof R ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + $);
    }
    A(E, I);
    try {
      const $ = R.fromBytes(E, I), L = e.fromBytes(T);
      if (P && $.hasHighS())
        return !1;
      const { r: z, s: H } = $, _ = F(m), j = o.inv(H), Y = o.create(_ * j), ot = o.create(z * j), q = e.BASE.multiplyUnsafe(Y).add(L.multiplyUnsafe(ot));
      return q.is0() ? !1 : o.create(q.x) === z;
    } catch {
      return !1;
    }
  }
  function b(E, m, T = {}) {
    const { prehash: k } = al(T, d);
    return m = U(m, k), R.fromBytes(E, "recovered").recoverPublicKey(m).toBytes();
  }
  return Object.freeze({
    keygen: u,
    getPublicKey: l,
    getSharedSecret: f,
    utils: h,
    lengths: g,
    Point: e,
    sign: B,
    verify: v,
    recoverPublicKey: b,
    Signature: R,
    hash: t
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const du = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
}, Q$ = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
}, J$ = /* @__PURE__ */ BigInt(0), bf = /* @__PURE__ */ BigInt(2);
function tI(e) {
  const t = du.p, n = BigInt(3), r = BigInt(6), i = BigInt(11), s = BigInt(22), o = BigInt(23), a = BigInt(44), c = BigInt(88), u = e * e * e % t, l = u * u * e % t, f = ke(l, n, t) * l % t, h = ke(f, n, t) * l % t, g = ke(h, bf, t) * u % t, d = ke(g, i, t) * g % t, p = ke(d, s, t) * d % t, y = ke(p, a, t) * p % t, x = ke(y, c, t) * y % t, S = ke(x, a, t) * p % t, A = ke(S, n, t) * l % t, R = ke(A, o, t) * d % t, N = ke(R, r, t) * u % t, F = ke(N, bf, t);
  if (!vc.eql(vc.sqr(F), e))
    throw new Error("Cannot find square root");
  return F;
}
const vc = fu(du.p, { sqrt: tI }), ki = /* @__PURE__ */ Y$(du, {
  Fp: vc,
  endo: Q$
}), Ug = /* @__PURE__ */ X$(ki, wf), _g = {};
function kc(e, ...t) {
  let n = _g[e];
  if (n === void 0) {
    const r = wf(WA(e));
    n = Sn(r, r), _g[e] = n;
  }
  return wf(Sn(n, ...t));
}
const zd = (e) => e.toBytes(!0).slice(1), qd = (e) => e % bf === J$;
function Ef(e) {
  const { Fn: t, BASE: n } = ki, r = t.fromBytes(e), i = n.multiply(r);
  return { scalar: qd(i.y) ? r : t.neg(r), bytes: zd(i) };
}
function R0(e) {
  const t = vc;
  if (!t.isValidNot0(e))
    throw new Error("invalid x: Fail if x ‚â• p");
  const n = t.create(e * e), r = t.create(n * e + BigInt(7));
  let i = t.sqrt(r);
  qd(i) || (i = t.neg(i));
  const s = ki.fromAffine({ x: e, y: i });
  return s.assertValidity(), s;
}
const Xs = Ss;
function P0(...e) {
  return ki.Fn.create(Xs(kc("BIP0340/challenge", ...e)));
}
function Dg(e) {
  return Ef(e).bytes;
}
function eI(e, t, n = au(32)) {
  const { Fn: r } = ki, i = wt(e, void 0, "message"), { bytes: s, scalar: o } = Ef(t), a = wt(n, 32, "auxRand"), c = r.toBytes(o ^ Xs(kc("BIP0340/aux", a))), u = kc("BIP0340/nonce", c, s, i), { bytes: l, scalar: f } = Ef(u), h = P0(l, s, i), g = new Uint8Array(64);
  if (g.set(l, 0), g.set(r.toBytes(r.create(f + h * o)), 32), !N0(g, i, s))
    throw new Error("sign: Invalid signature produced");
  return g;
}
function N0(e, t, n) {
  const { Fp: r, Fn: i, BASE: s } = ki, o = wt(e, 64, "signature"), a = wt(t, void 0, "message"), c = wt(n, 32, "publicKey");
  try {
    const u = R0(Xs(c)), l = Xs(o.subarray(0, 32));
    if (!r.isValidNot0(l))
      return !1;
    const f = Xs(o.subarray(32, 64));
    if (!i.isValidNot0(f))
      return !1;
    const h = P0(i.toBytes(l), zd(u), a), g = s.multiplyUnsafe(f).add(u.multiplyUnsafe(i.neg(h))), { x: d, y: p } = g.toAffine();
    return !(g.is0() || !qd(p) || d !== l);
  } catch {
    return !1;
  }
}
const Gd = /* @__PURE__ */ (() => {
  const n = (r = au(48)) => S0(r, du.n);
  return {
    keygen: A0(n, Dg),
    getPublicKey: Dg,
    sign: eI,
    verify: N0,
    Point: ki,
    utils: {
      randomSecretKey: n,
      taggedHash: kc,
      lift_x: R0,
      pointToBytes: zd
    },
    lengths: {
      secretKey: 32,
      publicKey: 32,
      publicKeyHasPrefix: !1,
      signature: 64,
      seed: 48
    }
  };
})();
function Yd(e, t, n = {}) {
  e = lf(e);
  const { aggPublicKey: r } = ff(e);
  if (!n.taprootTweak)
    return {
      preTweakedKey: r.toBytes(!0),
      finalKey: r.toBytes(!0)
    };
  const i = Gd.utils.taggedHash("TapTweak", r.toBytes(!0).subarray(1), n.taprootTweak ?? new Uint8Array(0)), { aggPublicKey: s } = ff(e, [i], [!0]);
  return {
    preTweakedKey: r.toBytes(!0),
    finalKey: s.toBytes(!0)
  };
}
class Zo extends Error {
  constructor(t) {
    super(t), this.name = "PartialSignatureError";
  }
}
class Zd {
  constructor(t, n) {
    if (this.s = t, this.R = n, t.length !== 32)
      throw new Zo("Invalid s length");
    if (n.length !== 33)
      throw new Zo("Invalid R length");
  }
  /**
   * Encodes the partial signature into bytes
   * Returns a 32-byte array containing just the s value
   */
  encode() {
    return new Uint8Array(this.s);
  }
  /**
   * Decodes a partial signature from bytes
   * @param bytes - 32-byte array containing s value
   */
  static decode(t) {
    if (t.length !== 32)
      throw new Zo("Invalid partial signature length");
    if (Ss(t) >= ie.CURVE().n)
      throw new Zo("s value overflows curve order");
    const r = new Uint8Array(33);
    return new Zd(t, r);
  }
}
function nI(e, t, n, r, i, s) {
  let o;
  if (s?.taprootTweak !== void 0) {
    const { preTweakedKey: u } = Yd(lf(r));
    o = Gd.utils.taggedHash("TapTweak", u.subarray(1), s.taprootTweak);
  }
  const c = new LA(n, lf(r), i, o ? [o] : void 0, o ? [!0] : void 0).sign(e, t);
  return Zd.decode(c);
}
var Ee;
(function(e) {
  e.VtxoTaprootTree = "taptree", e.VtxoTreeExpiry = "expiry", e.Cosigner = "cosigner", e.ConditionWitness = "condition";
})(Ee || (Ee = {}));
const Xd = 222;
function rI(e, t, n, r) {
  e.updateInput(t, {
    unknown: [
      ...e.getInput(t)?.unknown ?? [],
      n.encode(r)
    ]
  });
}
function xf(e, t, n) {
  const r = e.getInput(t)?.unknown ?? [], i = [];
  for (const s of r) {
    const o = n.decode(s);
    o && i.push(o);
  }
  return i;
}
const L0 = {
  key: Ee.VtxoTaprootTree,
  encode: (e) => [
    {
      type: Xd,
      key: hu[Ee.VtxoTaprootTree]
    },
    e
  ],
  decode: (e) => Qd(() => Jd(e[0], Ee.VtxoTaprootTree) ? e[1] : null)
}, iI = {
  key: Ee.ConditionWitness,
  encode: (e) => [
    {
      type: Xd,
      key: hu[Ee.ConditionWitness]
    },
    po.encode(e)
  ],
  decode: (e) => Qd(() => Jd(e[0], Ee.ConditionWitness) ? po.decode(e[1]) : null)
}, Tf = {
  key: Ee.Cosigner,
  encode: (e) => [
    {
      type: Xd,
      key: new Uint8Array([
        ...hu[Ee.Cosigner],
        e.index
      ])
    },
    e.key
  ],
  decode: (e) => Qd(() => Jd(e[0], Ee.Cosigner) ? {
    index: e[0].key[e[0].key.length - 1],
    key: e[1]
  } : null)
};
Ee.VtxoTreeExpiry;
const hu = Object.fromEntries(Object.values(Ee).map((e) => [
  e,
  new TextEncoder().encode(e)
])), Qd = (e) => {
  try {
    return e();
  } catch {
    return null;
  }
};
function Jd(e, t) {
  const n = C.encode(hu[t]);
  return C.encode(new Uint8Array([e.type, ...e.key])).includes(n);
}
const Xo = new Error("missing vtxo graph");
class bo {
  constructor(t) {
    this.secretKey = t, this.myNonces = null, this.aggregateNonces = null, this.graph = null, this.scriptRoot = null, this.rootSharedOutputAmount = null;
  }
  static random() {
    const t = Jl();
    return new bo(t);
  }
  async init(t, n, r) {
    this.graph = t, this.scriptRoot = n, this.rootSharedOutputAmount = r;
  }
  async getPublicKey() {
    return Ug.getPublicKey(this.secretKey);
  }
  async getNonces() {
    if (!this.graph)
      throw Xo;
    this.myNonces || (this.myNonces = this.generateNonces());
    const t = /* @__PURE__ */ new Map();
    for (const [n, r] of this.myNonces)
      t.set(n, { pubNonce: r.pubNonce });
    return t;
  }
  async aggregatedNonces(t, n) {
    if (!this.graph)
      throw Xo;
    if (this.aggregateNonces || (this.aggregateNonces = /* @__PURE__ */ new Map()), this.myNonces || await this.getNonces(), this.aggregateNonces.has(t))
      return {
        hasAllNonces: this.aggregateNonces.size === this.myNonces?.size
      };
    const r = this.myNonces.get(t);
    if (!r)
      throw new Error(`missing nonce for txid ${t}`);
    const i = await this.getPublicKey();
    n.set(C.encode(i.subarray(1)), r);
    const s = this.graph.find(t);
    if (!s)
      throw new Error(`missing tx for txid ${t}`);
    const o = xf(s.root, 0, Tf).map(
      (u) => C.encode(u.key.subarray(1))
      // xonly pubkey
    ), a = [];
    for (const u of o) {
      const l = n.get(u);
      if (!l)
        throw new Error(`missing nonce for cosigner ${u}`);
      a.push(l.pubNonce);
    }
    const c = _A(a);
    return this.aggregateNonces.set(t, { pubNonce: c }), {
      hasAllNonces: this.aggregateNonces.size === this.myNonces?.size
    };
  }
  async sign() {
    if (!this.graph)
      throw Xo;
    if (!this.aggregateNonces)
      throw new Error("nonces not set");
    if (!this.myNonces)
      throw new Error("nonces not generated");
    const t = /* @__PURE__ */ new Map();
    for (const n of this.graph.iterator()) {
      const r = this.signPartial(n);
      t.set(n.txid, r);
    }
    return t;
  }
  generateNonces() {
    if (!this.graph)
      throw Xo;
    const t = /* @__PURE__ */ new Map(), n = Ug.getPublicKey(this.secretKey);
    for (const r of this.graph.iterator()) {
      const i = UA(n);
      t.set(r.txid, i);
    }
    return t;
  }
  signPartial(t) {
    if (!this.graph || !this.scriptRoot || !this.rootSharedOutputAmount)
      throw bo.NOT_INITIALIZED;
    if (!this.myNonces || !this.aggregateNonces)
      throw new Error("session not properly initialized");
    const n = this.myNonces.get(t.txid);
    if (!n)
      throw new Error("missing private nonce");
    const r = this.aggregateNonces.get(t.txid);
    if (!r)
      throw new Error("missing aggregate nonce");
    const i = [], s = [], o = xf(t.root, 0, Tf).map((u) => u.key), { finalKey: a } = Yd(o, !0, {
      taprootTweak: this.scriptRoot
    });
    for (let u = 0; u < t.root.inputsLength; u++) {
      const l = sI(a, this.graph, this.rootSharedOutputAmount, t.root);
      i.push(l.amount), s.push(l.script);
    }
    const c = t.root.preimageWitnessV1(
      0,
      // always first input
      s,
      _r.DEFAULT,
      i
    );
    return nI(n.secNonce, this.secretKey, r.pubNonce, o, c, {
      taprootTweak: this.scriptRoot
    });
  }
}
bo.NOT_INITIALIZED = new Error("session not initialized, call init method");
function sI(e, t, n, r) {
  const i = et.encode(["OP_1", e.slice(1)]);
  if (r.id === t.txid)
    return {
      amount: n,
      script: i
    };
  const s = r.getInput(0);
  if (!s.txid)
    throw new Error("missing parent input txid");
  const o = C.encode(s.txid), a = t.find(o);
  if (!a)
    throw new Error("parent  tx not found");
  if (s.index === void 0)
    throw new Error("missing input index");
  const c = a.root.getOutput(s.index);
  if (!c)
    throw new Error("parent output not found");
  if (!c.amount)
    throw new Error("parent output amount not found");
  return {
    amount: c.amount,
    script: i
  };
}
const Vg = Object.values(_r).filter((e) => typeof e == "number");
class Qs {
  constructor(t) {
    this.key = t || Jl();
  }
  static fromPrivateKey(t) {
    return new Qs(t);
  }
  static fromHex(t) {
    return new Qs(C.decode(t));
  }
  static fromRandomBytes() {
    return new Qs(Jl());
  }
  /**
   * Export the private key as a hex string.
   *
   * @returns The private key as a hex string
   */
  toHex() {
    return C.encode(this.key);
  }
  async sign(t, n) {
    const r = t.clone();
    if (!n) {
      try {
        if (!r.sign(this.key, Vg))
          throw new Error("Failed to sign transaction");
      } catch (i) {
        if (!(i instanceof Error && i.message.includes("No inputs signed"))) throw i;
      }
      return r;
    }
    for (const i of n)
      if (!r.signIdx(this.key, i, Vg))
        throw new Error(`Failed to sign input #${i}`);
    return r;
  }
  compressedPublicKey() {
    return Promise.resolve(ub(this.key, !0));
  }
  xOnlyPublicKey() {
    return Promise.resolve(Id(this.key));
  }
  signerSession() {
    return bo.random();
  }
  async signMessage(t, n = "schnorr") {
    return n === "ecdsa" ? y$(t, this.key, { prehash: !1 }) : S$.signAsync(t, this.key);
  }
  async toReadonly() {
    return new pu(await this.compressedPublicKey());
  }
}
class pu {
  constructor(t) {
    if (this.publicKey = t, t.length !== 33)
      throw new Error("Invalid public key length");
  }
  /**
   * Create a ReadonlySingleKey from a compressed public key.
   *
   * @param publicKey - 33-byte compressed public key (02/03 prefix + 32-byte x coordinate)
   * @returns A new ReadonlySingleKey instance
   * @example
   * ```typescript
   * const pubkey = new Uint8Array(33); // your compressed public key
   * const readonlyKey = ReadonlySingleKey.fromPublicKey(pubkey);
   * ```
   */
  static fromPublicKey(t) {
    return new pu(t);
  }
  xOnlyPublicKey() {
    return Promise.resolve(this.publicKey.slice(1));
  }
  compressedPublicKey() {
    return Promise.resolve(this.publicKey);
  }
}
class pi {
  constructor(t, n, r, i = 0) {
    if (this.serverPubKey = t, this.vtxoTaprootKey = n, this.hrp = r, this.version = i, t.length !== 32)
      throw new Error("Invalid server public key length, expected 32 bytes, got " + t.length);
    if (n.length !== 32)
      throw new Error("Invalid vtxo taproot public key length, expected 32 bytes, got " + n.length);
  }
  static decode(t) {
    const n = Ni.decodeUnsafe(t, 1023);
    if (!n)
      throw new Error("Invalid address");
    const r = new Uint8Array(Ni.fromWords(n.words));
    if (r.length !== 65)
      throw new Error("Invalid data length, expected 65 bytes, got " + r.length);
    const i = r[0], s = r.slice(1, 33), o = r.slice(33, 65);
    return new pi(s, o, n.prefix, i);
  }
  encode() {
    const t = new Uint8Array(65);
    t[0] = this.version, t.set(this.serverPubKey, 1), t.set(this.vtxoTaprootKey, 33);
    const n = Ni.toWords(t);
    return Ni.encode(this.hrp, n, 1023);
  }
  // pkScript is the script that should be used to send non-dust funds to the address
  get pkScript() {
    return et.encode(["OP_1", this.vtxoTaprootKey]);
  }
  // subdustPkScript is the script that should be used to send sub-dust funds to the address
  get subdustPkScript() {
    return et.encode(["RETURN", this.vtxoTaprootKey]);
  }
}
const Ac = Cd(void 0, !0);
var _t;
(function(e) {
  e.Multisig = "multisig", e.CSVMultisig = "csv-multisig", e.ConditionCSVMultisig = "condition-csv-multisig", e.ConditionMultisig = "condition-multisig", e.CLTVMultisig = "cltv-multisig";
})(_t || (_t = {}));
function U0(e) {
  const t = [
    nn,
    xe,
    Eo,
    $c,
    ps
  ];
  for (const n of t)
    try {
      return n.decode(e);
    } catch {
      continue;
    }
  throw new Error(`Failed to decode: script ${C.encode(e)} is not a valid tapscript`);
}
var nn;
(function(e) {
  let t;
  (function(a) {
    a[a.CHECKSIG = 0] = "CHECKSIG", a[a.CHECKSIGADD = 1] = "CHECKSIGADD";
  })(t = e.MultisigType || (e.MultisigType = {}));
  function n(a) {
    if (a.pubkeys.length === 0)
      throw new Error("At least 1 pubkey is required");
    for (const u of a.pubkeys)
      if (u.length !== 32)
        throw new Error(`Invalid pubkey length: expected 32, got ${u.length}`);
    if (a.type || (a.type = t.CHECKSIG), a.type === t.CHECKSIGADD)
      return {
        type: _t.Multisig,
        params: a,
        script: Wk(a.pubkeys.length, a.pubkeys).script
      };
    const c = [];
    for (let u = 0; u < a.pubkeys.length; u++)
      c.push(a.pubkeys[u]), u < a.pubkeys.length - 1 ? c.push("CHECKSIGVERIFY") : c.push("CHECKSIG");
    return {
      type: _t.Multisig,
      params: a,
      script: et.encode(c)
    };
  }
  e.encode = n;
  function r(a) {
    if (a.length === 0)
      throw new Error("Failed to decode: script is empty");
    try {
      return i(a);
    } catch {
      try {
        return s(a);
      } catch (u) {
        throw new Error(`Failed to decode script: ${u instanceof Error ? u.message : String(u)}`);
      }
    }
  }
  e.decode = r;
  function i(a) {
    const c = et.decode(a), u = [];
    let l = !1;
    for (let h = 0; h < c.length; h++) {
      const g = c[h];
      if (typeof g != "string" && typeof g != "number") {
        if (g.length !== 32)
          throw new Error(`Invalid pubkey length: expected 32, got ${g.length}`);
        if (u.push(g), h + 1 >= c.length || c[h + 1] !== "CHECKSIGADD" && c[h + 1] !== "CHECKSIG")
          throw new Error("Expected CHECKSIGADD or CHECKSIG after pubkey");
        h++;
        continue;
      }
      if (h === c.length - 1) {
        if (g !== "NUMEQUAL")
          throw new Error("Expected NUMEQUAL at end of script");
        l = !0;
      }
    }
    if (!l)
      throw new Error("Missing NUMEQUAL operation");
    if (u.length === 0)
      throw new Error("Invalid script: must have at least 1 pubkey");
    const f = n({
      pubkeys: u,
      type: t.CHECKSIGADD
    });
    if (C.encode(f.script) !== C.encode(a))
      throw new Error("Invalid script format: script reconstruction mismatch");
    return {
      type: _t.Multisig,
      params: { pubkeys: u, type: t.CHECKSIGADD },
      script: a
    };
  }
  function s(a) {
    const c = et.decode(a), u = [];
    for (let f = 0; f < c.length; f++) {
      const h = c[f];
      if (typeof h != "string" && typeof h != "number") {
        if (h.length !== 32)
          throw new Error(`Invalid pubkey length: expected 32, got ${h.length}`);
        if (u.push(h), f + 1 >= c.length)
          throw new Error("Unexpected end of script");
        const g = c[f + 1];
        if (g !== "CHECKSIGVERIFY" && g !== "CHECKSIG")
          throw new Error("Expected CHECKSIGVERIFY or CHECKSIG after pubkey");
        if (f === c.length - 2 && g !== "CHECKSIG")
          throw new Error("Last operation must be CHECKSIG");
        f++;
        continue;
      }
    }
    if (u.length === 0)
      throw new Error("Invalid script: must have at least 1 pubkey");
    const l = n({ pubkeys: u, type: t.CHECKSIG });
    if (C.encode(l.script) !== C.encode(a))
      throw new Error("Invalid script format: script reconstruction mismatch");
    return {
      type: _t.Multisig,
      params: { pubkeys: u, type: t.CHECKSIG },
      script: a
    };
  }
  function o(a) {
    return a.type === _t.Multisig;
  }
  e.is = o;
})(nn || (nn = {}));
var xe;
(function(e) {
  function t(i) {
    for (const u of i.pubkeys)
      if (u.length !== 32)
        throw new Error(`Invalid pubkey length: expected 32, got ${u.length}`);
    const s = Ac.encode(BigInt(us.encode(i.timelock.type === "blocks" ? { blocks: Number(i.timelock.value) } : { seconds: Number(i.timelock.value) }))), o = [
      s.length === 1 ? s[0] : s,
      "CHECKSEQUENCEVERIFY",
      "DROP"
    ], a = nn.encode(i), c = new Uint8Array([
      ...et.encode(o),
      ...a.script
    ]);
    return {
      type: _t.CSVMultisig,
      params: i,
      script: c
    };
  }
  e.encode = t;
  function n(i) {
    if (i.length === 0)
      throw new Error("Failed to decode: script is empty");
    const s = et.decode(i);
    if (s.length < 3)
      throw new Error("Invalid script: too short (expected at least 3)");
    const o = s[0];
    if (typeof o == "string")
      throw new Error("Invalid script: expected sequence number");
    if (s[1] !== "CHECKSEQUENCEVERIFY" || s[2] !== "DROP")
      throw new Error("Invalid script: expected CHECKSEQUENCEVERIFY DROP");
    const a = new Uint8Array(et.encode(s.slice(3)));
    let c;
    try {
      c = nn.decode(a);
    } catch (g) {
      throw new Error(`Invalid multisig script: ${g instanceof Error ? g.message : String(g)}`);
    }
    let u;
    typeof o == "number" ? u = o : u = Number(Ac.decode(o));
    const l = us.decode(u), f = l.blocks !== void 0 ? { type: "blocks", value: BigInt(l.blocks) } : { type: "seconds", value: BigInt(l.seconds) }, h = t({
      timelock: f,
      ...c.params
    });
    if (C.encode(h.script) !== C.encode(i))
      throw new Error("Invalid script format: script reconstruction mismatch");
    return {
      type: _t.CSVMultisig,
      params: {
        timelock: f,
        ...c.params
      },
      script: i
    };
  }
  e.decode = n;
  function r(i) {
    return i.type === _t.CSVMultisig;
  }
  e.is = r;
})(xe || (xe = {}));
var Eo;
(function(e) {
  function t(i) {
    const s = new Uint8Array([
      ...i.conditionScript,
      ...et.encode(["VERIFY"]),
      ...xe.encode(i).script
    ]);
    return {
      type: _t.ConditionCSVMultisig,
      params: i,
      script: s
    };
  }
  e.encode = t;
  function n(i) {
    if (i.length === 0)
      throw new Error("Failed to decode: script is empty");
    const s = et.decode(i);
    if (s.length < 1)
      throw new Error("Invalid script: too short (expected at least 1)");
    let o = -1;
    for (let f = s.length - 1; f >= 0; f--)
      s[f] === "VERIFY" && (o = f);
    if (o === -1)
      throw new Error("Invalid script: missing VERIFY operation");
    const a = new Uint8Array(et.encode(s.slice(0, o))), c = new Uint8Array(et.encode(s.slice(o + 1)));
    let u;
    try {
      u = xe.decode(c);
    } catch (f) {
      throw new Error(`Invalid CSV multisig script: ${f instanceof Error ? f.message : String(f)}`);
    }
    const l = t({
      conditionScript: a,
      ...u.params
    });
    if (C.encode(l.script) !== C.encode(i))
      throw new Error("Invalid script format: script reconstruction mismatch");
    return {
      type: _t.ConditionCSVMultisig,
      params: {
        conditionScript: a,
        ...u.params
      },
      script: i
    };
  }
  e.decode = n;
  function r(i) {
    return i.type === _t.ConditionCSVMultisig;
  }
  e.is = r;
})(Eo || (Eo = {}));
var $c;
(function(e) {
  function t(i) {
    const s = new Uint8Array([
      ...i.conditionScript,
      ...et.encode(["VERIFY"]),
      ...nn.encode(i).script
    ]);
    return {
      type: _t.ConditionMultisig,
      params: i,
      script: s
    };
  }
  e.encode = t;
  function n(i) {
    if (i.length === 0)
      throw new Error("Failed to decode: script is empty");
    const s = et.decode(i);
    if (s.length < 1)
      throw new Error("Invalid script: too short (expected at least 1)");
    let o = -1;
    for (let f = s.length - 1; f >= 0; f--)
      s[f] === "VERIFY" && (o = f);
    if (o === -1)
      throw new Error("Invalid script: missing VERIFY operation");
    const a = new Uint8Array(et.encode(s.slice(0, o))), c = new Uint8Array(et.encode(s.slice(o + 1)));
    let u;
    try {
      u = nn.decode(c);
    } catch (f) {
      throw new Error(`Invalid multisig script: ${f instanceof Error ? f.message : String(f)}`);
    }
    const l = t({
      conditionScript: a,
      ...u.params
    });
    if (C.encode(l.script) !== C.encode(i))
      throw new Error("Invalid script format: script reconstruction mismatch");
    return {
      type: _t.ConditionMultisig,
      params: {
        conditionScript: a,
        ...u.params
      },
      script: i
    };
  }
  e.decode = n;
  function r(i) {
    return i.type === _t.ConditionMultisig;
  }
  e.is = r;
})($c || ($c = {}));
var ps;
(function(e) {
  function t(i) {
    const s = Ac.encode(i.absoluteTimelock), o = [
      s.length === 1 ? s[0] : s,
      "CHECKLOCKTIMEVERIFY",
      "DROP"
    ], a = et.encode(o), c = new Uint8Array([
      ...a,
      ...nn.encode(i).script
    ]);
    return {
      type: _t.CLTVMultisig,
      params: i,
      script: c
    };
  }
  e.encode = t;
  function n(i) {
    if (i.length === 0)
      throw new Error("Failed to decode: script is empty");
    const s = et.decode(i);
    if (s.length < 3)
      throw new Error("Invalid script: too short (expected at least 3)");
    const o = s[0];
    if (typeof o == "string" || typeof o == "number")
      throw new Error("Invalid script: expected locktime number");
    if (s[1] !== "CHECKLOCKTIMEVERIFY" || s[2] !== "DROP")
      throw new Error("Invalid script: expected CHECKLOCKTIMEVERIFY DROP");
    const a = new Uint8Array(et.encode(s.slice(3)));
    let c;
    try {
      c = nn.decode(a);
    } catch (f) {
      throw new Error(`Invalid multisig script: ${f instanceof Error ? f.message : String(f)}`);
    }
    const u = Ac.decode(o), l = t({
      absoluteTimelock: u,
      ...c.params
    });
    if (C.encode(l.script) !== C.encode(i))
      throw new Error("Invalid script format: script reconstruction mismatch");
    return {
      type: _t.CLTVMultisig,
      params: {
        absoluteTimelock: u,
        ...c.params
      },
      script: i
    };
  }
  e.decode = n;
  function r(i) {
    return i.type === _t.CLTVMultisig;
  }
  e.is = r;
})(ps || (ps = {}));
const Mg = go.tapTree[2];
function Js(e) {
  return e[1].subarray(0, e[1].length - 1);
}
class Ne {
  static decode(t) {
    const r = Mg.decode(t).map((i) => i.script);
    return new Ne(r);
  }
  constructor(t) {
    this.scripts = t;
    const n = t.length % 2 !== 0 ? t.slice().reverse() : t, r = wb(n.map((s) => ({
      script: s,
      leafVersion: yo
    }))), i = Hk(Bd, r, void 0, !0);
    if (!i.tapLeafScript || i.tapLeafScript.length !== t.length)
      throw new Error("invalid scripts");
    this.leaves = i.tapLeafScript, this.tweakedPublicKey = i.tweakedPubkey;
  }
  encode() {
    return Mg.encode(this.scripts.map((n) => ({
      depth: 1,
      version: yo,
      script: n
    })));
  }
  address(t, n) {
    return new pi(n, this.tweakedPublicKey, t);
  }
  get pkScript() {
    return et.encode(["OP_1", this.tweakedPublicKey]);
  }
  onchainAddress(t) {
    return Gn(t).encode({
      type: "tr",
      pubkey: this.tweakedPublicKey
    });
  }
  findLeaf(t) {
    const n = this.leaves.find((r) => C.encode(Js(r)) === t);
    if (!n)
      throw new Error(`leaf '${t}' not found`);
    return n;
  }
  exitPaths() {
    const t = [];
    for (const n of this.leaves)
      try {
        const r = xe.decode(Js(n));
        t.push(r);
        continue;
      } catch {
        try {
          const i = Eo.decode(Js(n));
          t.push(i);
        } catch {
          continue;
        }
      }
    return t;
  }
}
var Sf;
(function(e) {
  class t extends Ne {
    constructor(i) {
      n(i);
      const { sender: s, receiver: o, server: a, preimageHash: c, refundLocktime: u, unilateralClaimDelay: l, unilateralRefundDelay: f, unilateralRefundWithoutReceiverDelay: h } = i, g = oI(c), d = $c.encode({
        conditionScript: g,
        pubkeys: [o, a]
      }).script, p = nn.encode({
        pubkeys: [s, o, a]
      }).script, y = ps.encode({
        absoluteTimelock: u,
        pubkeys: [s, a]
      }).script, x = Eo.encode({
        conditionScript: g,
        timelock: l,
        pubkeys: [o]
      }).script, S = xe.encode({
        timelock: f,
        pubkeys: [s, o]
      }).script, A = xe.encode({
        timelock: h,
        pubkeys: [s]
      }).script;
      super([
        d,
        p,
        y,
        x,
        S,
        A
      ]), this.options = i, this.claimScript = C.encode(d), this.refundScript = C.encode(p), this.refundWithoutReceiverScript = C.encode(y), this.unilateralClaimScript = C.encode(x), this.unilateralRefundScript = C.encode(S), this.unilateralRefundWithoutReceiverScript = C.encode(A);
    }
    claim() {
      return this.findLeaf(this.claimScript);
    }
    refund() {
      return this.findLeaf(this.refundScript);
    }
    refundWithoutReceiver() {
      return this.findLeaf(this.refundWithoutReceiverScript);
    }
    unilateralClaim() {
      return this.findLeaf(this.unilateralClaimScript);
    }
    unilateralRefund() {
      return this.findLeaf(this.unilateralRefundScript);
    }
    unilateralRefundWithoutReceiver() {
      return this.findLeaf(this.unilateralRefundWithoutReceiverScript);
    }
  }
  e.Script = t;
  function n(r) {
    const { sender: i, receiver: s, server: o, preimageHash: a, refundLocktime: c, unilateralClaimDelay: u, unilateralRefundDelay: l, unilateralRefundWithoutReceiverDelay: f } = r;
    if (!a || a.length !== 20)
      throw new Error("preimage hash must be 20 bytes");
    if (!s || s.length !== 32)
      throw new Error("Invalid public key length (receiver)");
    if (!i || i.length !== 32)
      throw new Error("Invalid public key length (sender)");
    if (!o || o.length !== 32)
      throw new Error("Invalid public key length (server)");
    if (typeof c != "bigint" || c <= 0n)
      throw new Error("refund locktime must be greater than 0");
    if (!u || typeof u.value != "bigint" || u.value <= 0n)
      throw new Error("unilateral claim delay must greater than 0");
    if (u.type === "seconds" && u.value % 512n !== 0n)
      throw new Error("seconds timelock must be multiple of 512");
    if (u.type === "seconds" && u.value < 512n)
      throw new Error("seconds timelock must be greater or equal to 512");
    if (!l || typeof l.value != "bigint" || l.value <= 0n)
      throw new Error("unilateral refund delay must greater than 0");
    if (l.type === "seconds" && l.value % 512n !== 0n)
      throw new Error("seconds timelock must be multiple of 512");
    if (l.type === "seconds" && l.value < 512n)
      throw new Error("seconds timelock must be greater or equal to 512");
    if (!f || typeof f.value != "bigint" || f.value <= 0n)
      throw new Error("unilateral refund without receiver delay must greater than 0");
    if (f.type === "seconds" && f.value % 512n !== 0n)
      throw new Error("seconds timelock must be multiple of 512");
    if (f.type === "seconds" && f.value < 512n)
      throw new Error("seconds timelock must be greater or equal to 512");
  }
})(Sf || (Sf = {}));
function oI(e) {
  return et.encode(["HASH160", e, "EQUAL"]);
}
var gi;
(function(e) {
  class t extends Ne {
    constructor(r) {
      const { pubKey: i, serverPubKey: s, csvTimelock: o = t.DEFAULT_TIMELOCK } = r, a = nn.encode({
        pubkeys: [i, s]
      }).script, c = xe.encode({
        timelock: o,
        pubkeys: [i]
      }).script;
      super([a, c]), this.options = r, this.forfeitScript = C.encode(a), this.exitScript = C.encode(c);
    }
    forfeit() {
      return this.findLeaf(this.forfeitScript);
    }
    exit() {
      return this.findLeaf(this.exitScript);
    }
  }
  t.DEFAULT_TIMELOCK = {
    value: 144n,
    type: "blocks"
  }, e.Script = t;
})(gi || (gi = {}));
const Qo = /* @__PURE__ */ new Map();
function _0() {
  if (!("serviceWorker" in navigator))
    throw new Error("Service workers are not supported in this browser");
}
function D0(e) {
  if (!Qo.has(e)) {
    const t = navigator.serviceWorker.register(e).then(async (n) => {
      try {
        await n.update();
      } catch (r) {
        console.warn("Service worker update failed; continuing with registration", r);
      }
      return n;
    }).catch((n) => {
      throw Qo.delete(e), n;
    });
    Qo.set(e, t);
  }
  return Qo.get(e);
}
async function aI(e) {
  return _0(), D0(e);
}
async function Fg(e) {
  _0();
  const t = e ? await D0(e) : await navigator.serviceWorker.ready;
  let n = t.active || t.waiting || t.installing || navigator.serviceWorker.controller;
  if (!n && e) {
    const r = await navigator.serviceWorker.ready;
    n = r.active || r.waiting || r.installing || navigator.serviceWorker.controller;
  }
  if (!n)
    throw new Error("Service worker not ready yet");
  return n;
}
async function* vf(e) {
  const t = [], n = [];
  let r = null, i = null;
  const s = (a) => {
    r ? (r(a), r = null) : t.push(a);
  }, o = () => {
    const a = new Error("EventSource error");
    i ? (i(a), i = null) : n.push(a);
  };
  e.addEventListener("message", s), e.addEventListener("error", o);
  try {
    for (; ; ) {
      if (t.length > 0) {
        yield t.shift();
        continue;
      }
      if (n.length > 0)
        throw n.shift();
      const a = await new Promise((c, u) => {
        r = c, i = u;
      }).finally(() => {
        r = null, i = null;
      });
      a && (yield a);
    }
  } finally {
    e.removeEventListener("message", s), e.removeEventListener("error", o);
  }
}
class V0 extends Error {
  constructor(t, n, r, i) {
    super(n), this.code = t, this.message = n, this.name = r, this.metadata = i;
  }
}
function cI(e) {
  try {
    if (!(e instanceof Error))
      return;
    const t = JSON.parse(e.message);
    if (!("details" in t) || !Array.isArray(t.details))
      return;
    for (const n of t.details) {
      if (!("@type" in n) || n["@type"] !== "type.googleapis.com/ark.v1.ErrorDetails" || !("code" in n))
        continue;
      const i = n.code;
      if (!("message" in n))
        continue;
      const s = n.message;
      if (!("name" in n))
        continue;
      const o = n.name;
      let a;
      return "metadata" in n && uI(n.metadata) && (a = n.metadata), new V0(i, s, o, a);
    }
    return;
  } catch {
    return;
  }
}
function uI(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
var $r;
(function(e) {
  function t(i, s, o = []) {
    if (typeof i != "string" && (i = r(i)), s.length == 0)
      throw new Error("intent proof requires at least one input");
    gI(s), wI(o);
    const a = mI(i, s[0].witnessUtxo.script);
    return bI(a, s, o);
  }
  e.create = t;
  function n(i) {
    let s = 0n;
    for (let a = 0; a < i.inputsLength; a++) {
      const c = i.getInput(a);
      if (c.witnessUtxo === void 0)
        throw new Error("intent proof input requires witness utxo");
      s += c.witnessUtxo.amount;
    }
    let o = 0n;
    for (let a = 0; a < i.outputsLength; a++) {
      const c = i.getOutput(a);
      if (c.amount === void 0)
        throw new Error("intent proof output requires amount");
      o += c.amount;
    }
    if (o > s)
      throw new Error(`intent proof output amount is greater than input amount: ${o} > ${s}`);
    return Number(s - o);
  }
  e.fee = n;
  function r(i) {
    switch (i.type) {
      case "register":
        return JSON.stringify({
          type: "register",
          onchain_output_indexes: i.onchain_output_indexes,
          valid_at: i.valid_at,
          expire_at: i.expire_at,
          cosigners_public_keys: i.cosigners_public_keys
        });
      case "delete":
        return JSON.stringify({
          type: "delete",
          expire_at: i.expire_at
        });
      case "get-pending-tx":
        return JSON.stringify({
          type: "get-pending-tx",
          expire_at: i.expire_at
        });
    }
  }
  e.encodeMessage = r;
})($r || ($r = {}));
const lI = new Uint8Array([Vt.RETURN]), fI = new Uint8Array(32).fill(0), dI = 4294967295, hI = "ark-intent-proof-message";
function pI(e) {
  if (e.index === void 0)
    throw new Error("intent proof input requires index");
  if (e.txid === void 0)
    throw new Error("intent proof input requires txid");
  if (e.witnessUtxo === void 0)
    throw new Error("intent proof input requires witness utxo");
  return !0;
}
function gI(e) {
  return e.forEach(pI), !0;
}
function yI(e) {
  if (e.amount === void 0)
    throw new Error("intent proof output requires amount");
  if (e.script === void 0)
    throw new Error("intent proof output requires script");
  return !0;
}
function wI(e) {
  return e.forEach(yI), !0;
}
function mI(e, t) {
  const n = EI(e), r = new Dr({
    version: 0
  });
  return r.addInput({
    txid: fI,
    // zero hash
    index: dI,
    sequence: 0
  }), r.addOutput({
    amount: 0n,
    script: t
  }), r.updateInput(0, {
    finalScriptSig: et.encode(["OP_0", n])
  }), r;
}
function bI(e, t, n) {
  const r = t[0], i = t.map((o) => o.sequence || 0).reduce((o, a) => Math.max(o, a), 0), s = new Dr({
    version: 2,
    lockTime: i
  });
  s.addInput({
    ...r,
    txid: e.id,
    index: 0,
    witnessUtxo: {
      script: r.witnessUtxo.script,
      amount: 0n
    },
    sighashType: _r.ALL
  });
  for (const [o, a] of t.entries())
    s.addInput({
      ...a,
      sighashType: _r.ALL
    }), a.unknown?.length && s.updateInput(o + 1, {
      unknown: a.unknown
    });
  n.length === 0 && (n = [
    {
      amount: 0n,
      script: lI
    }
  ]);
  for (const o of n)
    s.addOutput({
      amount: o.amount,
      script: o.script
    });
  return s;
}
function EI(e) {
  return Gd.utils.taggedHash(hI, new TextEncoder().encode(e));
}
var Wt;
(function(e) {
  e.BatchStarted = "batch_started", e.BatchFinalization = "batch_finalization", e.BatchFinalized = "batch_finalized", e.BatchFailed = "batch_failed", e.TreeSigningStarted = "tree_signing_started", e.TreeNonces = "tree_nonces", e.TreeTx = "tree_tx", e.TreeSignature = "tree_signature";
})(Wt || (Wt = {}));
class M0 {
  constructor(t) {
    this.serverUrl = t;
  }
  async getInfo() {
    const t = `${this.serverUrl}/v1/info`, n = await fetch(t);
    if (!n.ok) {
      const i = await n.text();
      dn(i, `Failed to get server info: ${n.statusText}`);
    }
    const r = await n.json();
    return {
      boardingExitDelay: BigInt(r.boardingExitDelay ?? 0),
      checkpointTapscript: r.checkpointTapscript ?? "",
      deprecatedSigners: r.deprecatedSigners?.map((i) => ({
        cutoffDate: BigInt(i.cutoffDate ?? 0),
        pubkey: i.pubkey ?? ""
      })) ?? [],
      digest: r.digest ?? "",
      dust: BigInt(r.dust ?? 0),
      fees: {
        intentFee: r.fees?.intentFee ?? {},
        txFeeRate: r?.fees?.txFeeRate ?? ""
      },
      forfeitAddress: r.forfeitAddress ?? "",
      forfeitPubkey: r.forfeitPubkey ?? "",
      network: r.network ?? "",
      scheduledSession: "scheduledSession" in r && r.scheduledSession != null ? {
        duration: BigInt(r.scheduledSession.duration ?? 0),
        nextStartTime: BigInt(r.scheduledSession.nextStartTime ?? 0),
        nextEndTime: BigInt(r.scheduledSession.nextEndTime ?? 0),
        period: BigInt(r.scheduledSession.period ?? 0),
        fees: r.scheduledSession.fees ?? {}
      } : void 0,
      serviceStatus: r.serviceStatus ?? {},
      sessionDuration: BigInt(r.sessionDuration ?? 0),
      signerPubkey: r.signerPubkey ?? "",
      unilateralExitDelay: BigInt(r.unilateralExitDelay ?? 0),
      utxoMaxAmount: BigInt(r.utxoMaxAmount ?? -1),
      utxoMinAmount: BigInt(r.utxoMinAmount ?? 0),
      version: r.version ?? "",
      vtxoMaxAmount: BigInt(r.vtxoMaxAmount ?? -1),
      vtxoMinAmount: BigInt(r.vtxoMinAmount ?? 0)
    };
  }
  async submitTx(t, n) {
    const r = `${this.serverUrl}/v1/tx/submit`, i = await fetch(r, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        signedArkTx: t,
        checkpointTxs: n
      })
    });
    if (!i.ok) {
      const o = await i.text();
      dn(o, `Failed to submit virtual transaction: ${o}`);
    }
    const s = await i.json();
    return {
      arkTxid: s.arkTxid,
      finalArkTx: s.finalArkTx,
      signedCheckpointTxs: s.signedCheckpointTxs
    };
  }
  async finalizeTx(t, n) {
    const r = `${this.serverUrl}/v1/tx/finalize`, i = await fetch(r, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        arkTxid: t,
        finalCheckpointTxs: n
      })
    });
    if (!i.ok) {
      const s = await i.text();
      dn(s, `Failed to finalize offchain transaction: ${s}`);
    }
  }
  async registerIntent(t) {
    const n = `${this.serverUrl}/v1/batch/registerIntent`, r = await fetch(n, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        intent: {
          proof: t.proof,
          message: $r.encodeMessage(t.message)
        }
      })
    });
    if (!r.ok) {
      const s = await r.text();
      dn(s, `Failed to register intent: ${s}`);
    }
    return (await r.json()).intentId;
  }
  async deleteIntent(t) {
    const n = `${this.serverUrl}/v1/batch/deleteIntent`, r = await fetch(n, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        intent: {
          proof: t.proof,
          message: $r.encodeMessage(t.message)
        }
      })
    });
    if (!r.ok) {
      const i = await r.text();
      dn(i, `Failed to delete intent: ${i}`);
    }
  }
  async confirmRegistration(t) {
    const n = `${this.serverUrl}/v1/batch/ack`, r = await fetch(n, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        intentId: t
      })
    });
    if (!r.ok) {
      const i = await r.text();
      dn(i, `Failed to confirm registration: ${i}`);
    }
  }
  async submitTreeNonces(t, n, r) {
    const i = `${this.serverUrl}/v1/batch/tree/submitNonces`, s = await fetch(i, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        batchId: t,
        pubkey: n,
        treeNonces: xI(r)
      })
    });
    if (!s.ok) {
      const o = await s.text();
      dn(o, `Failed to submit tree nonces: ${o}`);
    }
  }
  async submitTreeSignatures(t, n, r) {
    const i = `${this.serverUrl}/v1/batch/tree/submitSignatures`, s = await fetch(i, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        batchId: t,
        pubkey: n,
        treeSignatures: TI(r)
      })
    });
    if (!s.ok) {
      const o = await s.text();
      dn(o, `Failed to submit tree signatures: ${o}`);
    }
  }
  async submitSignedForfeitTxs(t, n) {
    const r = `${this.serverUrl}/v1/batch/submitForfeitTxs`, i = await fetch(r, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        signedForfeitTxs: t,
        signedCommitmentTx: n
      })
    });
    if (!i.ok) {
      const s = await i.text();
      dn(s, `Failed to submit forfeit transactions: ${i.statusText}`);
    }
  }
  async *getEventStream(t, n) {
    const r = `${this.serverUrl}/v1/batch/events`, i = n.length > 0 ? `?${n.map((s) => `topics=${encodeURIComponent(s)}`).join("&")}` : "";
    for (; !t?.aborted; )
      try {
        const s = new EventSource(r + i), o = () => {
          s.close();
        };
        t?.addEventListener("abort", o);
        try {
          for await (const a of vf(s)) {
            if (t?.aborted)
              break;
            try {
              const c = JSON.parse(a.data), u = this.parseSettlementEvent(c);
              u && (yield u);
            } catch (c) {
              throw console.error("Failed to parse event:", c), c;
            }
          }
        } finally {
          t?.removeEventListener("abort", o), s.close();
        }
      } catch (s) {
        if (s instanceof Error && s.name === "AbortError")
          break;
        if (kf(s)) {
          console.debug("Timeout error ignored");
          continue;
        }
        throw console.error("Event stream error:", s), s;
      }
  }
  async *getTransactionsStream(t) {
    const n = `${this.serverUrl}/v1/txs`;
    for (; !t?.aborted; )
      try {
        const r = new EventSource(n), i = () => {
          r.close();
        };
        t?.addEventListener("abort", i);
        try {
          for await (const s of vf(r)) {
            if (t?.aborted)
              break;
            try {
              const o = JSON.parse(s.data), a = this.parseTransactionNotification(o);
              a && (yield a);
            } catch (o) {
              throw console.error("Failed to parse transaction notification:", o), o;
            }
          }
        } finally {
          t?.removeEventListener("abort", i), r.close();
        }
      } catch (r) {
        if (r instanceof Error && r.name === "AbortError")
          break;
        if (kf(r)) {
          console.debug("Timeout error ignored");
          continue;
        }
        throw console.error("Transaction stream error:", r), r;
      }
  }
  async getPendingTxs(t) {
    const n = `${this.serverUrl}/v1/tx/pending`, r = await fetch(n, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        intent: {
          proof: t.proof,
          message: $r.encodeMessage(t.message)
        }
      })
    });
    if (!r.ok) {
      const s = await r.text();
      dn(s, `Failed to get pending transactions: ${s}`);
    }
    return (await r.json()).pendingTxs;
  }
  parseSettlementEvent(t) {
    if (t.batchStarted)
      return {
        type: Wt.BatchStarted,
        id: t.batchStarted.id,
        intentIdHashes: t.batchStarted.intentIdHashes,
        batchExpiry: BigInt(t.batchStarted.batchExpiry)
      };
    if (t.batchFinalization)
      return {
        type: Wt.BatchFinalization,
        id: t.batchFinalization.id,
        commitmentTx: t.batchFinalization.commitmentTx
      };
    if (t.batchFinalized)
      return {
        type: Wt.BatchFinalized,
        id: t.batchFinalized.id,
        commitmentTxid: t.batchFinalized.commitmentTxid
      };
    if (t.batchFailed)
      return {
        type: Wt.BatchFailed,
        id: t.batchFailed.id,
        reason: t.batchFailed.reason
      };
    if (t.treeSigningStarted)
      return {
        type: Wt.TreeSigningStarted,
        id: t.treeSigningStarted.id,
        cosignersPublicKeys: t.treeSigningStarted.cosignersPubkeys,
        unsignedCommitmentTx: t.treeSigningStarted.unsignedCommitmentTx
      };
    if (t.treeNoncesAggregated)
      return null;
    if (t.treeNonces)
      return {
        type: Wt.TreeNonces,
        id: t.treeNonces.id,
        topic: t.treeNonces.topic,
        txid: t.treeNonces.txid,
        nonces: SI(t.treeNonces.nonces)
        // pubkey -> public nonce
      };
    if (t.treeTx) {
      const n = Object.fromEntries(Object.entries(t.treeTx.children).map(([r, i]) => [parseInt(r), i]));
      return {
        type: Wt.TreeTx,
        id: t.treeTx.id,
        topic: t.treeTx.topic,
        batchIndex: t.treeTx.batchIndex,
        chunk: {
          txid: t.treeTx.txid,
          tx: t.treeTx.tx,
          children: n
        }
      };
    }
    return t.treeSignature ? {
      type: Wt.TreeSignature,
      id: t.treeSignature.id,
      topic: t.treeSignature.topic,
      batchIndex: t.treeSignature.batchIndex,
      txid: t.treeSignature.txid,
      signature: t.treeSignature.signature
    } : (t.heartbeat || console.warn("Unknown event type:", t), null);
  }
  parseTransactionNotification(t) {
    return t.commitmentTx ? {
      commitmentTx: {
        txid: t.commitmentTx.txid,
        tx: t.commitmentTx.tx,
        spentVtxos: t.commitmentTx.spentVtxos.map(Jo),
        spendableVtxos: t.commitmentTx.spendableVtxos.map(Jo),
        checkpointTxs: t.commitmentTx.checkpointTxs
      }
    } : t.arkTx ? {
      arkTx: {
        txid: t.arkTx.txid,
        tx: t.arkTx.tx,
        spentVtxos: t.arkTx.spentVtxos.map(Jo),
        spendableVtxos: t.arkTx.spendableVtxos.map(Jo),
        checkpointTxs: t.arkTx.checkpointTxs
      }
    } : (t.heartbeat || console.warn("Unknown transaction notification type:", t), null);
  }
}
function xI(e) {
  const t = {};
  for (const [n, r] of e)
    t[n] = C.encode(r.pubNonce);
  return t;
}
function TI(e) {
  const t = {};
  for (const [n, r] of e)
    t[n] = C.encode(r.encode());
  return t;
}
function SI(e) {
  return new Map(Object.entries(e).map(([t, n]) => {
    if (typeof n != "string")
      throw new Error("invalid nonce");
    return [t, { pubNonce: C.decode(n) }];
  }));
}
function kf(e) {
  const t = (n) => n instanceof Error ? n.name === "TypeError" && n.message === "Failed to fetch" || n.name === "HeadersTimeoutError" || n.name === "BodyTimeoutError" || n.code === "UND_ERR_HEADERS_TIMEOUT" || n.code === "UND_ERR_BODY_TIMEOUT" : !1;
  return t(e) || t(e.cause);
}
function Jo(e) {
  return {
    outpoint: {
      txid: e.outpoint.txid,
      vout: e.outpoint.vout
    },
    amount: e.amount,
    script: e.script,
    createdAt: e.createdAt,
    expiresAt: e.expiresAt,
    commitmentTxids: e.commitmentTxids,
    isPreconfirmed: e.isPreconfirmed,
    isSwept: e.isSwept,
    isUnrolled: e.isUnrolled,
    isSpent: e.isSpent,
    spentBy: e.spentBy,
    settledBy: e.settledBy,
    arkTxid: e.arkTxid
  };
}
function dn(e, t) {
  const n = new Error(e);
  throw cI(n) ?? new Error(t);
}
const vI = (e) => kI[e], kI = {
  bitcoin: Ls(cs, "ark"),
  testnet: Ls(jo, "tark"),
  signet: Ls(jo, "tark"),
  mutinynet: Ls(jo, "tark"),
  regtest: Ls({
    ...jo,
    bech32: "bcrt",
    pubKeyHash: 111,
    scriptHash: 196
  }, "tark")
};
function Ls(e, t) {
  return {
    ...e,
    hrp: t
  };
}
const AI = {
  bitcoin: "https://mempool.space/api",
  testnet: "https://mempool.space/testnet/api",
  signet: "https://mempool.space/signet/api",
  mutinynet: "https://mutinynet.com/api",
  regtest: "http://localhost:3000"
};
class $I {
  constructor(t, n) {
    this.baseUrl = t, this.pollingInterval = n?.pollingInterval ?? 15e3, this.forcePolling = n?.forcePolling ?? !1;
  }
  async getCoins(t) {
    const n = await fetch(`${this.baseUrl}/address/${t}/utxo`);
    if (!n.ok)
      throw new Error(`Failed to fetch UTXOs: ${n.statusText}`);
    return n.json();
  }
  async getFeeRate() {
    const t = await fetch(`${this.baseUrl}/fee-estimates`);
    if (!t.ok)
      throw new Error(`Failed to fetch fee rate: ${t.statusText}`);
    return (await t.json())[1] ?? void 0;
  }
  async broadcastTransaction(...t) {
    switch (t.length) {
      case 1:
        return this.broadcastTx(t[0]);
      case 2:
        return this.broadcastPackage(t[0], t[1]);
      default:
        throw new Error("Only 1 or 1C1P package can be broadcast");
    }
  }
  async getTxOutspends(t) {
    const n = await fetch(`${this.baseUrl}/tx/${t}/outspends`);
    if (!n.ok) {
      const r = await n.text();
      throw new Error(`Failed to get transaction outspends: ${r}`);
    }
    return n.json();
  }
  async getTransactions(t) {
    const n = await fetch(`${this.baseUrl}/address/${t}/txs`);
    if (!n.ok) {
      const r = await n.text();
      throw new Error(`Failed to get transactions: ${r}`);
    }
    return n.json();
  }
  async getTxStatus(t) {
    const n = await fetch(`${this.baseUrl}/tx/${t}`);
    if (!n.ok)
      throw new Error(n.statusText);
    if (!(await n.json()).status.confirmed)
      return { confirmed: !1 };
    const i = await fetch(`${this.baseUrl}/tx/${t}/status`);
    if (!i.ok)
      throw new Error(`Failed to get transaction status: ${i.statusText}`);
    const s = await i.json();
    return s.confirmed ? {
      confirmed: s.confirmed,
      blockTime: s.block_time,
      blockHeight: s.block_height
    } : { confirmed: !1 };
  }
  async watchAddresses(t, n) {
    let r = null;
    const i = this.baseUrl.replace(/^http(s)?:/, "ws$1:") + "/v1/ws", s = async () => {
      const c = async () => (await Promise.all(t.map((g) => this.getTransactions(g)))).flat(), u = await c(), l = (h) => `${h.txid}_${h.status.block_time}`, f = new Set(u.map(l));
      r = setInterval(async () => {
        try {
          const g = (await c()).filter((d) => !f.has(l(d)));
          g.length > 0 && (g.forEach((d) => f.add(l(d))), n(g));
        } catch (h) {
          console.error("Error in polling mechanism:", h);
        }
      }, this.pollingInterval);
    };
    let o = null;
    const a = () => {
      o && o.close(), r && clearInterval(r);
    };
    if (this.forcePolling)
      return await s(), a;
    try {
      o = new WebSocket(i), o.addEventListener("open", () => {
        const c = {
          "track-addresses": t
        };
        o.send(JSON.stringify(c));
      }), o.addEventListener("message", (c) => {
        try {
          const u = [], l = JSON.parse(c.data.toString());
          if (!l["multi-address-transactions"])
            return;
          const f = l["multi-address-transactions"];
          for (const h in f)
            for (const g of [
              "mempool",
              "confirmed",
              "removed"
            ])
              f[h][g] && u.push(...f[h][g].filter(OI));
          u.length > 0 && n(u);
        } catch (u) {
          console.error("Failed to process WebSocket message:", u);
        }
      }), o.addEventListener("error", async () => {
        await s();
      });
    } catch {
      r && clearInterval(r), await s();
    }
    return a;
  }
  async getChainTip() {
    const t = await fetch(`${this.baseUrl}/blocks/tip`);
    if (!t.ok)
      throw new Error(`Failed to get chain tip: ${t.statusText}`);
    const n = await t.json();
    if (!II(n))
      throw new Error(`Invalid chain tip: ${JSON.stringify(n)}`);
    if (n.length === 0)
      throw new Error("No chain tip found");
    const r = n[0].id;
    return {
      height: n[0].height,
      time: n[0].mediantime,
      hash: r
    };
  }
  async broadcastPackage(t, n) {
    const r = await fetch(`${this.baseUrl}/txs/package`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify([t, n])
    });
    if (!r.ok) {
      const i = await r.text();
      throw new Error(`Failed to broadcast package: ${i}`);
    }
    return r.json();
  }
  async broadcastTx(t) {
    const n = await fetch(`${this.baseUrl}/tx`, {
      method: "POST",
      headers: {
        "Content-Type": "text/plain"
      },
      body: t
    });
    if (!n.ok) {
      const r = await n.text();
      throw new Error(`Failed to broadcast transaction: ${r}`);
    }
    return n.text();
  }
}
function II(e) {
  return Array.isArray(e) && e.every((t) => t && typeof t == "object" && typeof t.id == "string" && t.id.length > 0 && typeof t.height == "number" && t.height >= 0 && typeof t.mediantime == "number" && t.mediantime > 0);
}
const OI = (e) => typeof e.txid == "string" && Array.isArray(e.vout) && e.vout.every((t) => typeof t.scriptpubkey_address == "string" && typeof t.value == "number") && typeof e.status == "object" && typeof e.status.confirmed == "boolean", BI = 0n, CI = new Uint8Array([81, 2, 78, 115]), th = {
  script: CI,
  amount: BI
};
C.encode(th.script);
function RI(e, t, n) {
  const r = new Dr({
    version: 3,
    lockTime: n
  });
  let i = 0n;
  for (const s of e) {
    if (!s.witnessUtxo)
      throw new Error("input needs witness utxo");
    i += s.witnessUtxo.amount, r.addInput(s);
  }
  return r.addOutput({
    script: t,
    amount: i
  }), r.addOutput(th), r;
}
const PI = new Error("invalid settlement transaction outputs"), NI = new Error("empty tree"), LI = new Error("invalid number of inputs"), cl = new Error("wrong settlement txid"), UI = new Error("invalid amount"), _I = new Error("no leaves"), DI = new Error("invalid taproot script"), Hg = new Error("invalid round transaction outputs"), VI = new Error("wrong commitment txid"), MI = new Error("missing cosigners public keys"), ul = 0, Wg = 1;
function FI(e, t) {
  if (t.validate(), t.root.inputsLength !== 1)
    throw LI;
  const n = t.root.getInput(0), r = Xt.fromPSBT(ut.decode(e));
  if (r.outputsLength <= Wg)
    throw PI;
  const i = r.id;
  if (!n.txid || C.encode(n.txid) !== i || n.index !== Wg)
    throw cl;
}
function HI(e, t, n) {
  if (t.outputsLength < ul + 1)
    throw Hg;
  const r = t.getOutput(ul)?.amount;
  if (!r)
    throw Hg;
  if (!e.root)
    throw NI;
  const i = e.root.getInput(0), s = t.id;
  if (!i.txid || C.encode(i.txid) !== s || i.index !== ul)
    throw VI;
  let o = 0n;
  for (let c = 0; c < e.root.outputsLength; c++) {
    const u = e.root.getOutput(c);
    u?.amount && (o += u.amount);
  }
  if (o !== r)
    throw UI;
  if (e.leaves().length === 0)
    throw _I;
  e.validate();
  for (const c of e.iterator())
    for (const [u, l] of c.children) {
      const f = c.root.getOutput(u);
      if (!f?.script)
        throw new Error(`parent output ${u} not found`);
      const h = f.script.slice(2);
      if (h.length !== 32)
        throw new Error(`parent output ${u} has invalid script`);
      const g = xf(l.root, 0, Tf);
      if (g.length === 0)
        throw MI;
      const d = g.map((y) => y.key), { finalKey: p } = Yd(d, !0, {
        taprootTweak: n
      });
      if (!p || C.encode(p.slice(1)) !== C.encode(h))
        throw DI;
    }
}
var Mn;
(function(e) {
  e.TxSent = "SENT", e.TxReceived = "RECEIVED";
})(Mn || (Mn = {}));
function qi(e) {
  return !e.isSpent;
}
function eh(e) {
  return e.virtualStatus.state === "swept" && qi(e);
}
function F0(e) {
  if (e.virtualStatus.state === "swept")
    return !0;
  const t = e.virtualStatus.batchExpiry;
  return !t || new Date(t).getFullYear() < 2025 ? !1 : t <= Date.now();
}
function H0(e, t) {
  return e.value < t;
}
function WI(e, t, n) {
  let r = !1;
  for (const [o, a] of t.entries()) {
    if (!a.script)
      throw new Error(`missing output script ${o}`);
    if (et.decode(a.script)[0] === "RETURN") {
      if (r)
        throw new Error("multiple OP_RETURN outputs");
      r = !0;
    }
  }
  const i = e.map((o) => KI(o, n));
  return {
    arkTx: W0(i.map((o) => o.input), t),
    checkpoints: i.map((o) => o.tx)
  };
}
function W0(e, t) {
  let n = 0n;
  for (const i of e) {
    const s = U0(Js(i.tapLeafScript));
    if (ps.is(s)) {
      if (n !== 0n && Kg(n) !== Kg(s.params.absoluteTimelock))
        throw new Error("cannot mix seconds and blocks locktime");
      s.params.absoluteTimelock > n && (n = s.params.absoluteTimelock);
    }
  }
  const r = new Dr({
    version: 3,
    lockTime: Number(n)
  });
  for (const [i, s] of e.entries())
    r.addInput({
      txid: s.txid,
      index: s.vout,
      sequence: n ? Ud - 1 : void 0,
      witnessUtxo: {
        script: Ne.decode(s.tapTree).pkScript,
        amount: BigInt(s.value)
      },
      tapLeafScript: [s.tapLeafScript]
    }), rI(r, i, L0, s.tapTree);
  for (const i of t)
    r.addOutput(i);
  return r.addOutput(th), r;
}
function KI(e, t) {
  const n = U0(Js(e.tapLeafScript)), r = new Ne([
    t.script,
    n.script
  ]), i = W0([e], [
    {
      amount: BigInt(e.value),
      script: r.pkScript
    }
  ]), s = r.findLeaf(C.encode(n.script)), o = {
    txid: i.id,
    vout: 0,
    value: e.value,
    tapLeafScript: s,
    tapTree: r.encode()
  };
  return {
    tx: i,
    input: o
  };
}
const jI = 500000000n;
function Kg(e) {
  return e >= jI;
}
function zI(e, t) {
  if (!e.status.block_time)
    return !1;
  if (t.value === 0n)
    return !0;
  if (t.type === "blocks")
    return !1;
  const n = BigInt(Math.floor(Date.now() / 1e3));
  return BigInt(Math.floor(e.status.block_time)) + t.value <= n;
}
const qI = 4320 * 60 * 1e3, GI = {
  thresholdMs: qI
  // 3 days
};
class Lt {
  constructor(t, n, r = Lt.DefaultHRP) {
    this.preimage = t, this.value = n, this.HRP = r, this.vout = 0;
    const i = Bt(this.preimage);
    this.vtxoScript = new Ne([XI(i)]);
    const s = this.vtxoScript.leaves[0];
    this.txid = C.encode(new Uint8Array(i).reverse()), this.tapTree = this.vtxoScript.encode(), this.forfeitTapLeafScript = s, this.intentTapLeafScript = s, this.value = n, this.status = { confirmed: !0 }, this.extraWitness = [this.preimage];
  }
  encode() {
    const t = new Uint8Array(Lt.Length);
    return t.set(this.preimage, 0), YI(t, this.value, this.preimage.length), t;
  }
  static decode(t, n = Lt.DefaultHRP) {
    if (t.length !== Lt.Length)
      throw new Error(`invalid data length: expected ${Lt.Length} bytes, got ${t.length}`);
    const r = t.subarray(0, Lt.PreimageLength), i = ZI(t, Lt.PreimageLength);
    return new Lt(r, i, n);
  }
  static fromString(t, n = Lt.DefaultHRP) {
    if (t = t.trim(), !t.startsWith(n))
      throw new Error(`invalid human-readable part: expected ${n} prefix (note '${t}')`);
    const r = t.slice(n.length), i = jl.decode(r);
    if (i.length === 0)
      throw new Error("failed to decode base58 string");
    return Lt.decode(i, n);
  }
  toString() {
    return this.HRP + jl.encode(this.encode());
  }
}
Lt.DefaultHRP = "arknote";
Lt.PreimageLength = 32;
Lt.ValueLength = 4;
Lt.Length = Lt.PreimageLength + Lt.ValueLength;
Lt.FakeOutpointIndex = 0;
function YI(e, t, n) {
  new DataView(e.buffer, e.byteOffset + n, 4).setUint32(0, t, !1);
}
function ZI(e, t) {
  return new DataView(e.buffer, e.byteOffset + t, 4).getUint32(0, !1);
}
function XI(e) {
  return et.encode(["SHA256", e, "EQUAL"]);
}
var Af;
(function(e) {
  e[e.INDEXER_TX_TYPE_UNSPECIFIED = 0] = "INDEXER_TX_TYPE_UNSPECIFIED", e[e.INDEXER_TX_TYPE_RECEIVED = 1] = "INDEXER_TX_TYPE_RECEIVED", e[e.INDEXER_TX_TYPE_SENT = 2] = "INDEXER_TX_TYPE_SENT";
})(Af || (Af = {}));
var Gi;
(function(e) {
  e.UNSPECIFIED = "INDEXER_CHAINED_TX_TYPE_UNSPECIFIED", e.COMMITMENT = "INDEXER_CHAINED_TX_TYPE_COMMITMENT", e.ARK = "INDEXER_CHAINED_TX_TYPE_ARK", e.TREE = "INDEXER_CHAINED_TX_TYPE_TREE", e.CHECKPOINT = "INDEXER_CHAINED_TX_TYPE_CHECKPOINT";
})(Gi || (Gi = {}));
class K0 {
  constructor(t) {
    this.serverUrl = t;
  }
  async getVtxoTree(t, n) {
    let r = `${this.serverUrl}/v1/indexer/batch/${t.txid}/${t.vout}/tree`;
    const i = new URLSearchParams();
    n && (n.pageIndex !== void 0 && i.append("page.index", n.pageIndex.toString()), n.pageSize !== void 0 && i.append("page.size", n.pageSize.toString())), i.toString() && (r += "?" + i.toString());
    const s = await fetch(r);
    if (!s.ok)
      throw new Error(`Failed to fetch vtxo tree: ${s.statusText}`);
    const o = await s.json();
    if (!Ve.isVtxoTreeResponse(o))
      throw new Error("Invalid vtxo tree data received");
    return o.vtxoTree.forEach((a) => {
      a.children = Object.fromEntries(Object.entries(a.children).map(([c, u]) => [
        Number(c),
        u
      ]));
    }), o;
  }
  async getVtxoTreeLeaves(t, n) {
    let r = `${this.serverUrl}/v1/indexer/batch/${t.txid}/${t.vout}/tree/leaves`;
    const i = new URLSearchParams();
    n && (n.pageIndex !== void 0 && i.append("page.index", n.pageIndex.toString()), n.pageSize !== void 0 && i.append("page.size", n.pageSize.toString())), i.toString() && (r += "?" + i.toString());
    const s = await fetch(r);
    if (!s.ok)
      throw new Error(`Failed to fetch vtxo tree leaves: ${s.statusText}`);
    const o = await s.json();
    if (!Ve.isVtxoTreeLeavesResponse(o))
      throw new Error("Invalid vtxos tree leaves data received");
    return o;
  }
  async getBatchSweepTransactions(t) {
    const n = `${this.serverUrl}/v1/indexer/batch/${t.txid}/${t.vout}/sweepTxs`, r = await fetch(n);
    if (!r.ok)
      throw new Error(`Failed to fetch batch sweep transactions: ${r.statusText}`);
    const i = await r.json();
    if (!Ve.isBatchSweepTransactionsResponse(i))
      throw new Error("Invalid batch sweep transactions data received");
    return i;
  }
  async getCommitmentTx(t) {
    const n = `${this.serverUrl}/v1/indexer/commitmentTx/${t}`, r = await fetch(n);
    if (!r.ok)
      throw new Error(`Failed to fetch commitment tx: ${r.statusText}`);
    const i = await r.json();
    if (!Ve.isCommitmentTx(i))
      throw new Error("Invalid commitment tx data received");
    return i;
  }
  async getCommitmentTxConnectors(t, n) {
    let r = `${this.serverUrl}/v1/indexer/commitmentTx/${t}/connectors`;
    const i = new URLSearchParams();
    n && (n.pageIndex !== void 0 && i.append("page.index", n.pageIndex.toString()), n.pageSize !== void 0 && i.append("page.size", n.pageSize.toString())), i.toString() && (r += "?" + i.toString());
    const s = await fetch(r);
    if (!s.ok)
      throw new Error(`Failed to fetch commitment tx connectors: ${s.statusText}`);
    const o = await s.json();
    if (!Ve.isConnectorsResponse(o))
      throw new Error("Invalid commitment tx connectors data received");
    return o.connectors.forEach((a) => {
      a.children = Object.fromEntries(Object.entries(a.children).map(([c, u]) => [
        Number(c),
        u
      ]));
    }), o;
  }
  async getCommitmentTxForfeitTxs(t, n) {
    let r = `${this.serverUrl}/v1/indexer/commitmentTx/${t}/forfeitTxs`;
    const i = new URLSearchParams();
    n && (n.pageIndex !== void 0 && i.append("page.index", n.pageIndex.toString()), n.pageSize !== void 0 && i.append("page.size", n.pageSize.toString())), i.toString() && (r += "?" + i.toString());
    const s = await fetch(r);
    if (!s.ok)
      throw new Error(`Failed to fetch commitment tx forfeitTxs: ${s.statusText}`);
    const o = await s.json();
    if (!Ve.isForfeitTxsResponse(o))
      throw new Error("Invalid commitment tx forfeitTxs data received");
    return o;
  }
  async *getSubscription(t, n) {
    const r = `${this.serverUrl}/v1/indexer/script/subscription/${t}`;
    for (; !n?.aborted; )
      try {
        const i = new EventSource(r), s = () => {
          i.close();
        };
        n?.addEventListener("abort", s);
        try {
          for await (const o of vf(i)) {
            if (n?.aborted)
              break;
            try {
              const a = JSON.parse(o.data);
              a.event && (yield {
                txid: a.event.txid,
                scripts: a.event.scripts || [],
                newVtxos: (a.event.newVtxos || []).map(ta),
                spentVtxos: (a.event.spentVtxos || []).map(ta),
                sweptVtxos: (a.event.sweptVtxos || []).map(ta),
                tx: a.event.tx,
                checkpointTxs: a.event.checkpointTxs
              });
            } catch (a) {
              throw console.error("Failed to parse subscription event:", a), a;
            }
          }
        } finally {
          n?.removeEventListener("abort", s), i.close();
        }
      } catch (i) {
        if (i instanceof Error && i.name === "AbortError")
          break;
        if (kf(i)) {
          console.debug("Timeout error ignored");
          continue;
        }
        throw console.error("Subscription error:", i), i;
      }
  }
  async getVirtualTxs(t, n) {
    let r = `${this.serverUrl}/v1/indexer/virtualTx/${t.join(",")}`;
    const i = new URLSearchParams();
    n && (n.pageIndex !== void 0 && i.append("page.index", n.pageIndex.toString()), n.pageSize !== void 0 && i.append("page.size", n.pageSize.toString())), i.toString() && (r += "?" + i.toString());
    const s = await fetch(r);
    if (!s.ok)
      throw new Error(`Failed to fetch virtual txs: ${s.statusText}`);
    const o = await s.json();
    if (!Ve.isVirtualTxsResponse(o))
      throw new Error("Invalid virtual txs data received");
    return o;
  }
  async getVtxoChain(t, n) {
    let r = `${this.serverUrl}/v1/indexer/vtxo/${t.txid}/${t.vout}/chain`;
    const i = new URLSearchParams();
    n && (n.pageIndex !== void 0 && i.append("page.index", n.pageIndex.toString()), n.pageSize !== void 0 && i.append("page.size", n.pageSize.toString())), i.toString() && (r += "?" + i.toString());
    const s = await fetch(r);
    if (!s.ok)
      throw new Error(`Failed to fetch vtxo chain: ${s.statusText}`);
    const o = await s.json();
    if (!Ve.isVtxoChainResponse(o))
      throw new Error("Invalid vtxo chain data received");
    return o;
  }
  async getVtxos(t) {
    if (t?.scripts && t?.outpoints)
      throw new Error("scripts and outpoints are mutually exclusive options");
    if (!t?.scripts && !t?.outpoints)
      throw new Error("Either scripts or outpoints must be provided");
    let n = `${this.serverUrl}/v1/indexer/vtxos`;
    const r = new URLSearchParams();
    t?.scripts && t.scripts.length > 0 && t.scripts.forEach((o) => {
      r.append("scripts", o);
    }), t?.outpoints && t.outpoints.length > 0 && t.outpoints.forEach((o) => {
      r.append("outpoints", `${o.txid}:${o.vout}`);
    }), t && (t.spendableOnly !== void 0 && r.append("spendableOnly", t.spendableOnly.toString()), t.spentOnly !== void 0 && r.append("spentOnly", t.spentOnly.toString()), t.recoverableOnly !== void 0 && r.append("recoverableOnly", t.recoverableOnly.toString()), t.pageIndex !== void 0 && r.append("page.index", t.pageIndex.toString()), t.pageSize !== void 0 && r.append("page.size", t.pageSize.toString())), r.toString() && (n += "?" + r.toString());
    const i = await fetch(n);
    if (!i.ok)
      throw new Error(`Failed to fetch vtxos: ${i.statusText}`);
    const s = await i.json();
    if (!Ve.isVtxosResponse(s))
      throw new Error("Invalid vtxos data received");
    return {
      vtxos: s.vtxos.map(ta),
      page: s.page
    };
  }
  async subscribeForScripts(t, n) {
    const r = `${this.serverUrl}/v1/indexer/script/subscribe`, i = await fetch(r, {
      headers: {
        "Content-Type": "application/json"
      },
      method: "POST",
      body: JSON.stringify({ scripts: t, subscriptionId: n })
    });
    if (!i.ok) {
      const o = await i.text();
      throw new Error(`Failed to subscribe to scripts: ${o}`);
    }
    const s = await i.json();
    if (!s.subscriptionId)
      throw new Error("Subscription ID not found");
    return s.subscriptionId;
  }
  async unsubscribeForScripts(t, n) {
    const r = `${this.serverUrl}/v1/indexer/script/unsubscribe`, i = await fetch(r, {
      headers: {
        "Content-Type": "application/json"
      },
      method: "POST",
      body: JSON.stringify({ subscriptionId: t, scripts: n })
    });
    if (!i.ok) {
      const s = await i.text();
      console.warn(`Failed to unsubscribe to scripts: ${s}`);
    }
  }
}
function ta(e) {
  return {
    txid: e.outpoint.txid,
    vout: e.outpoint.vout,
    value: Number(e.amount),
    status: {
      confirmed: !e.isSwept && !e.isPreconfirmed,
      isLeaf: !e.isPreconfirmed
    },
    virtualStatus: {
      state: e.isSwept ? "swept" : e.isPreconfirmed ? "preconfirmed" : "settled",
      commitmentTxIds: e.commitmentTxids,
      batchExpiry: e.expiresAt ? Number(e.expiresAt) * 1e3 : void 0
    },
    spentBy: e.spentBy ?? "",
    settledBy: e.settledBy,
    arkTxId: e.arkTxid,
    createdAt: new Date(Number(e.createdAt) * 1e3),
    isUnrolled: e.isUnrolled,
    isSpent: e.isSpent
  };
}
var Ve;
(function(e) {
  function t(w) {
    return typeof w == "object" && typeof w.totalOutputAmount == "string" && typeof w.totalOutputVtxos == "number" && typeof w.expiresAt == "string" && typeof w.swept == "boolean";
  }
  function n(w) {
    return typeof w == "object" && typeof w.txid == "string" && typeof w.expiresAt == "string" && Object.values(Gi).includes(w.type) && Array.isArray(w.spends) && w.spends.every((K) => typeof K == "string");
  }
  function r(w) {
    return typeof w == "object" && typeof w.startedAt == "string" && typeof w.endedAt == "string" && typeof w.totalInputAmount == "string" && typeof w.totalInputVtxos == "number" && typeof w.totalOutputAmount == "string" && typeof w.totalOutputVtxos == "number" && typeof w.batches == "object" && Object.values(w.batches).every(t);
  }
  e.isCommitmentTx = r;
  function i(w) {
    return typeof w == "object" && typeof w.txid == "string" && typeof w.vout == "number";
  }
  e.isOutpoint = i;
  function s(w) {
    return Array.isArray(w) && w.every(i);
  }
  e.isOutpointArray = s;
  function o(w) {
    return typeof w == "object" && typeof w.txid == "string" && typeof w.children == "object" && Object.values(w.children).every(l) && Object.keys(w.children).every((K) => Number.isInteger(Number(K)));
  }
  function a(w) {
    return Array.isArray(w) && w.every(o);
  }
  e.isTxsArray = a;
  function c(w) {
    return typeof w == "object" && typeof w.amount == "string" && typeof w.createdAt == "string" && typeof w.isSettled == "boolean" && typeof w.settledBy == "string" && Object.values(Af).includes(w.type) && (!w.commitmentTxid && typeof w.virtualTxid == "string" || typeof w.commitmentTxid == "string" && !w.virtualTxid);
  }
  function u(w) {
    return Array.isArray(w) && w.every(c);
  }
  e.isTxHistoryRecordArray = u;
  function l(w) {
    return typeof w == "string" && w.length === 64;
  }
  function f(w) {
    return Array.isArray(w) && w.every(l);
  }
  e.isTxidArray = f;
  function h(w) {
    return typeof w == "object" && i(w.outpoint) && typeof w.createdAt == "string" && (w.expiresAt === null || typeof w.expiresAt == "string") && typeof w.amount == "string" && typeof w.script == "string" && typeof w.isPreconfirmed == "boolean" && typeof w.isSwept == "boolean" && typeof w.isUnrolled == "boolean" && typeof w.isSpent == "boolean" && (!w.spentBy || typeof w.spentBy == "string") && (!w.settledBy || typeof w.settledBy == "string") && (!w.arkTxid || typeof w.arkTxid == "string") && Array.isArray(w.commitmentTxids) && w.commitmentTxids.every(l);
  }
  function g(w) {
    return typeof w == "object" && typeof w.current == "number" && typeof w.next == "number" && typeof w.total == "number";
  }
  function d(w) {
    return typeof w == "object" && Array.isArray(w.vtxoTree) && w.vtxoTree.every(o) && (!w.page || g(w.page));
  }
  e.isVtxoTreeResponse = d;
  function p(w) {
    return typeof w == "object" && Array.isArray(w.leaves) && w.leaves.every(i) && (!w.page || g(w.page));
  }
  e.isVtxoTreeLeavesResponse = p;
  function y(w) {
    return typeof w == "object" && Array.isArray(w.connectors) && w.connectors.every(o) && (!w.page || g(w.page));
  }
  e.isConnectorsResponse = y;
  function x(w) {
    return typeof w == "object" && Array.isArray(w.txids) && w.txids.every(l) && (!w.page || g(w.page));
  }
  e.isForfeitTxsResponse = x;
  function S(w) {
    return typeof w == "object" && Array.isArray(w.sweptBy) && w.sweptBy.every(l);
  }
  e.isSweptCommitmentTxResponse = S;
  function A(w) {
    return typeof w == "object" && Array.isArray(w.sweptBy) && w.sweptBy.every(l);
  }
  e.isBatchSweepTransactionsResponse = A;
  function R(w) {
    return typeof w == "object" && Array.isArray(w.txs) && w.txs.every((K) => typeof K == "string") && (!w.page || g(w.page));
  }
  e.isVirtualTxsResponse = R;
  function N(w) {
    return typeof w == "object" && Array.isArray(w.chain) && w.chain.every(n) && (!w.page || g(w.page));
  }
  e.isVtxoChainResponse = N;
  function F(w) {
    return typeof w == "object" && Array.isArray(w.vtxos) && w.vtxos.every(h) && (!w.page || g(w.page));
  }
  e.isVtxosResponse = F;
})(Ve || (Ve = {}));
const QI = 546;
function jn(e, t) {
  return {
    ...t,
    forfeitTapLeafScript: e.offchainTapscript.forfeit(),
    intentTapLeafScript: e.offchainTapscript.forfeit(),
    tapTree: e.offchainTapscript.encode()
  };
}
function $f(e, t) {
  return {
    ...t,
    forfeitTapLeafScript: e.boardingTapscript.forfeit(),
    intentTapLeafScript: e.boardingTapscript.forfeit(),
    tapTree: e.boardingTapscript.encode()
  };
}
class $a {
  constructor(t, n = /* @__PURE__ */ new Map()) {
    this.root = t, this.children = n;
  }
  static create(t) {
    if (t.length === 0)
      throw new Error("empty chunks");
    const n = /* @__PURE__ */ new Map();
    for (const s of t) {
      const o = t2(s), a = o.tx.id;
      n.set(a, o);
    }
    const r = [];
    for (const [s] of n) {
      let o = !1;
      for (const [a, c] of n)
        if (a !== s && (o = JI(c, s), o))
          break;
      if (!o) {
        r.push(s);
        continue;
      }
    }
    if (r.length === 0)
      throw new Error("no root chunk found");
    if (r.length > 1)
      throw new Error(`multiple root chunks found: ${r.join(", ")}`);
    const i = j0(r[0], n);
    if (!i)
      throw new Error(`chunk not found for root txid: ${r[0]}`);
    if (i.nbOfNodes() !== t.length)
      throw new Error(`number of chunks (${t.length}) is not equal to the number of nodes in the graph (${i.nbOfNodes()})`);
    return i;
  }
  nbOfNodes() {
    let t = 1;
    for (const n of this.children.values())
      t += n.nbOfNodes();
    return t;
  }
  validate() {
    if (!this.root)
      throw new Error("unexpected nil root");
    const t = this.root.outputsLength, n = this.root.inputsLength;
    if (n !== 1)
      throw new Error(`unexpected number of inputs: ${n}, expected 1`);
    if (this.children.size > t - 1)
      throw new Error(`unexpected number of children: ${this.children.size}, expected maximum ${t - 1}`);
    for (const [r, i] of this.children) {
      if (r >= t)
        throw new Error(`output index ${r} is out of bounds (nb of outputs: ${t})`);
      i.validate();
      const s = i.root.getInput(0), o = this.root.id;
      if (!s.txid || C.encode(s.txid) !== o || s.index !== r)
        throw new Error(`input of child ${r} is not the output of the parent`);
      let a = 0n;
      for (let u = 0; u < i.root.outputsLength; u++) {
        const l = i.root.getOutput(u);
        l?.amount && (a += l.amount);
      }
      const c = this.root.getOutput(r);
      if (!c?.amount)
        throw new Error(`parent output ${r} has no amount`);
      if (a !== c.amount)
        throw new Error(`sum of child's outputs is not equal to the output of the parent: ${a} != ${c.amount}`);
    }
  }
  leaves() {
    if (this.children.size === 0)
      return [this.root];
    const t = [];
    for (const n of this.children.values())
      t.push(...n.leaves());
    return t;
  }
  get txid() {
    return this.root.id;
  }
  find(t) {
    if (t === this.txid)
      return this;
    for (const n of this.children.values()) {
      const r = n.find(t);
      if (r)
        return r;
    }
    return null;
  }
  update(t, n) {
    if (t === this.txid) {
      n(this.root);
      return;
    }
    for (const r of this.children.values())
      try {
        r.update(t, n);
        return;
      } catch {
        continue;
      }
    throw new Error(`tx not found: ${t}`);
  }
  *iterator() {
    for (const t of this.children.values())
      yield* t.iterator();
    yield this;
  }
}
function JI(e, t) {
  return Object.values(e.children).includes(t);
}
function j0(e, t) {
  const n = t.get(e);
  if (!n)
    return null;
  const r = n.tx, i = /* @__PURE__ */ new Map();
  for (const [s, o] of Object.entries(n.children)) {
    const a = parseInt(s), c = j0(o, t);
    c && i.set(a, c);
  }
  return new $a(r, i);
}
function t2(e) {
  return { tx: Xt.fromPSBT(ut.decode(e.tx)), children: e.children };
}
var If;
(function(e) {
  let t;
  (function(r) {
    r.Start = "start", r.BatchStarted = "batch_started", r.TreeSigningStarted = "tree_signing_started", r.TreeNoncesAggregated = "tree_nonces_aggregated", r.BatchFinalization = "batch_finalization";
  })(t || (t = {}));
  async function n(r, i, s = {}) {
    const { abortController: o, skipVtxoTreeSigning: a = !1, eventCallback: c } = s;
    let u = t.Start;
    const l = [], f = [];
    let h, g;
    for await (const d of r) {
      if (o?.signal.aborted)
        throw new Error("canceled");
      switch (c && c(d).catch(() => {
      }), d.type) {
        case Wt.BatchStarted: {
          const p = d, { skip: y } = await i.onBatchStarted(p);
          y || (u = t.BatchStarted, a && (u = t.TreeNoncesAggregated));
          continue;
        }
        case Wt.BatchFinalized: {
          if (u !== t.BatchFinalization)
            continue;
          return i.onBatchFinalized && await i.onBatchFinalized(d), d.commitmentTxid;
        }
        case Wt.BatchFailed: {
          if (i.onBatchFailed) {
            await i.onBatchFailed(d);
            continue;
          }
          throw new Error(d.reason);
        }
        case Wt.TreeTx: {
          if (u !== t.BatchStarted && u !== t.TreeNoncesAggregated)
            continue;
          d.batchIndex === 0 ? l.push(d.chunk) : f.push(d.chunk), i.onTreeTxEvent && await i.onTreeTxEvent(d);
          continue;
        }
        case Wt.TreeSignature: {
          if (u !== t.TreeNoncesAggregated)
            continue;
          if (!h)
            throw new Error("vtxo tree not initialized");
          const p = C.decode(d.signature);
          h.update(d.txid, (y) => {
            y.updateInput(0, {
              tapKeySig: p
            });
          }), i.onTreeSignatureEvent && await i.onTreeSignatureEvent(d);
          continue;
        }
        case Wt.TreeSigningStarted: {
          if (u !== t.BatchStarted)
            continue;
          h = $a.create(l);
          const { skip: p } = await i.onTreeSigningStarted(d, h);
          p || (u = t.TreeSigningStarted);
          continue;
        }
        case Wt.TreeNonces: {
          if (u !== t.TreeSigningStarted)
            continue;
          const { fullySigned: p } = await i.onTreeNonces(d);
          p && (u = t.TreeNoncesAggregated);
          continue;
        }
        case Wt.BatchFinalization: {
          if (u !== t.TreeNoncesAggregated)
            continue;
          if (!h && l.length > 0 && (h = $a.create(l)), !h && !a)
            throw new Error("vtxo tree not initialized");
          f.length > 0 && (g = $a.create(f)), await i.onBatchFinalization(d, h, g), u = t.BatchFinalization;
          continue;
        }
        default:
          continue;
      }
    }
    throw new Error("event stream closed");
  }
  e.join = n;
})(If || (If = {}));
class bt extends Error {
  #t;
  constructor(t, n, r) {
    super(t, { cause: r }), this.name = "ParseError", this.#t = n, n?.input && (this.message = gs(this.message, n));
  }
  get node() {
    return this.#t;
  }
  withAst(t) {
    return this.#t || !t?.input ? this : (this.#t = t, this.message = gs(this.message, t), this);
  }
}
class tt extends Error {
  #t;
  constructor(t, n, r) {
    super(t, { cause: r }), this.name = "EvaluationError", this.#t = n, n?.input && (this.message = gs(this.message, n));
  }
  get node() {
    return this.#t;
  }
  withAst(t) {
    return this.#t || !t?.input ? this : (this.#t = t, this.message = gs(this.message, t), this);
  }
}
let e2 = class extends Error {
  #t;
  constructor(t, n, r) {
    super(t, { cause: r }), this.name = "TypeError", this.#t = n, n?.input && (this.message = gs(this.message, n));
  }
  get node() {
    return this.#t;
  }
  withAst(t) {
    return this.#t || !t?.input ? this : (this.#t = t, this.message = gs(this.message, t), this);
  }
};
function gs(e, t) {
  if (t?.pos === void 0) return e;
  const n = t.pos, r = t.input;
  let i = 1, s = 0, o = 0;
  for (; s < n; )
    r[s] === `
` ? (i++, o = 0) : o++, s++;
  let a = n, c = n;
  for (; a > 0 && r[a - 1] !== `
`; ) a--;
  for (; c < r.length && r[c] !== `
`; ) c++;
  const u = r.slice(a, c), l = `> ${`${i}`.padStart(4, " ")} | ${u}
${" ".repeat(9 + o)}^`;
  return `${e}

${l}`;
}
class An {
  #t;
  constructor(t) {
    this.#t = t;
  }
  static of(t) {
    return t === void 0 ? Ic : new An(t);
  }
  static none() {
    return Ic;
  }
  hasValue() {
    return this.#t !== void 0;
  }
  value() {
    if (this.#t === void 0) throw new tt("Optional value is not present");
    return this.#t;
  }
  or(t) {
    if (this.#t !== void 0) return this;
    if (t instanceof An) return t;
    throw new tt("Optional.or must be called with an Optional argument");
  }
  orValue(t) {
    return this.#t === void 0 ? t : this.#t;
  }
  get [Symbol.toStringTag]() {
    return "optional";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.#t === void 0 ? "Optional { none }" : `Optional { value: ${JSON.stringify(this.#t)} }`;
  }
}
const Ic = Object.freeze(new An());
class z0 {
}
const q0 = new z0();
function n2(e, t) {
  e.constants.set("optional", t ? q0 : void 0);
}
function r2(e) {
  const t = (f, h) => e.registerFunctionOverload(f, h), n = e.enableOptionalTypes ? q0 : void 0;
  e.registerType("OptionalNamespace", z0), e.registerConstant("optional", "OptionalNamespace", n), t("optional.hasValue(): bool", (f) => f.hasValue()), t("optional<A>.value(): A", (f) => f.value()), e.registerFunctionOverload("OptionalNamespace.none(): optional<T>", () => An.none()), t("OptionalNamespace.of(A): optional<A>", (f, h) => An.of(h));
  function r(f, h, g) {
    if (f instanceof An) return f;
    throw new tt(`${g} must be optional`, h);
  }
  function i(f, h, g) {
    const d = f.eval(h.receiver, g);
    return d instanceof Promise ? d.then((p) => s(p, f, h, g)) : s(d, f, h, g);
  }
  function s(f, h, g, d) {
    const p = r(f, g.receiver, `${g.functionDesc} receiver`);
    return p.hasValue() ? g.onHasValue(p) : g.onEmpty(h, g, d);
  }
  function o(f, h, g, d) {
    const p = f.check(h, g);
    if (p.kind === "optional") return p;
    if (p.kind === "dyn") return f.getType("optional");
    throw new f.Error(`${d} must be optional, got '${p}'`, h);
  }
  function a({ functionDesc: f, evaluate: h, typeCheck: g, onHasValue: d, onEmpty: p }) {
    return ({ args: y, receiver: x }) => ({
      functionDesc: f,
      receiver: x,
      arg: y[0],
      evaluate: h,
      typeCheck: g,
      onHasValue: d,
      onEmpty: p
    });
  }
  const c = "optional.orValue() receiver", u = "optional.or(optional) receiver", l = "optional.or(optional) argument";
  e.registerFunctionOverload(
    "optional.or(ast): optional<dyn>",
    a({
      functionDesc: "optional.or(optional)",
      evaluate: i,
      typeCheck(f, h, g) {
        const d = o(f, h.receiver, g, u), p = o(f, h.arg, g, l), y = d.unify(f.registry, p);
        if (y) return y;
        throw new f.Error(
          `${h.functionDesc} argument must be compatible type, got '${d}' and '${p}'`,
          h.arg
        );
      },
      onHasValue: (f) => f,
      onEmpty(f, h, g) {
        const d = h.arg, p = f.eval(d, g);
        return p instanceof Promise ? p.then((y) => r(y, d, l)) : r(p, d, l);
      }
    })
  ), e.registerFunctionOverload(
    "optional.orValue(ast): dyn",
    a({
      functionDesc: "optional.orValue(value)",
      onHasValue: (f) => f.value(),
      onEmpty(f, h, g) {
        return f.eval(h.arg, g);
      },
      evaluate: i,
      typeCheck(f, h, g) {
        const d = o(f, h.receiver, g, c).valueType, p = f.check(h.arg, g), y = d.unify(f.registry, p);
        if (y) return y;
        throw new f.Error(
          `${h.functionDesc} argument must be compatible type, got '${d}' and '${p}'`,
          h.arg
        );
      }
    })
  );
}
const Of = Object.hasOwn, $n = Object.keys, jr = Object.freeze, i2 = Object.entries, Ia = Array.isArray, jg = Array.from, Oc = /* @__PURE__ */ new Set([
  "as",
  "break",
  "const",
  "continue",
  "else",
  "for",
  "function",
  "if",
  "import",
  "let",
  "loop",
  "package",
  "namespace",
  "return",
  "var",
  "void",
  "while",
  "__proto__",
  "prototype"
]);
class ti {
  #t;
  constructor(t) {
    this.verify(BigInt(t));
  }
  get value() {
    return this.#t;
  }
  valueOf() {
    return this.#t;
  }
  verify(t) {
    if (t < 0n || t > 18446744073709551615n) throw new tt("Unsigned integer overflow");
    this.#t = t;
  }
  get [Symbol.toStringTag]() {
    return `value = ${this.#t}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `UnsignedInteger { value: ${this.#t} }`;
  }
}
const s2 = {
  h: 3600000000000n,
  m: 60000000000n,
  s: 1000000000n,
  ms: 1000000n,
  us: 1000n,
  ¬µs: 1000n,
  ns: 1n
};
class Ir {
  #t;
  #e;
  constructor(t, n = 0) {
    this.#t = BigInt(t), this.#e = n;
  }
  get seconds() {
    return this.#t;
  }
  get nanos() {
    return this.#e;
  }
  valueOf() {
    return Number(this.#t) * 1e3 + this.#e / 1e6;
  }
  static fromMilliseconds(t) {
    const n = BigInt(Math.trunc(t * 1e6)), r = n / 1000000000n, i = Number(n % 1000000000n);
    return new Ir(r, i);
  }
  addDuration(t) {
    const n = this.#e + t.nanos;
    return new Ir(
      this.#t + t.seconds + BigInt(Math.floor(n / 1e9)),
      n % 1e9
    );
  }
  subtractDuration(t) {
    const n = this.#e - t.nanos;
    return new Ir(
      this.#t - t.seconds + BigInt(Math.floor(n / 1e9)),
      (n + 1e9) % 1e9
    );
  }
  extendTimestamp(t) {
    return new Date(
      t.getTime() + Number(this.#t) * 1e3 + Math.floor(this.#e / 1e6)
    );
  }
  subtractTimestamp(t) {
    return new Date(
      t.getTime() - Number(this.#t) * 1e3 - Math.floor(this.#e / 1e6)
    );
  }
  toString() {
    const t = this.#e ? (this.#e / 1e9).toLocaleString("en-US", { useGrouping: !1, maximumFractionDigits: 9 }).slice(1) : "";
    return `${this.#t}${t}s`;
  }
  getHours() {
    return this.#t / 3600n;
  }
  getMinutes() {
    return this.#t / 60n;
  }
  getSeconds() {
    return this.#t;
  }
  getMilliseconds() {
    return this.#t * 1000n + BigInt(Math.floor(this.#e / 1e6));
  }
  get [Symbol.toStringTag]() {
    return "google.protobuf.Duration";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `google.protobuf.Duration { seconds: ${this.#t}, nanos: ${this.#e} }`;
  }
}
function o2(e) {
  const t = (d, p) => e.registerFunctionOverload(d, p), n = (d) => d;
  t("dyn(dyn): dyn", n);
  for (const d in Ie) {
    const p = Ie[d];
    p instanceof re && t(`type(${p.name}): type`, () => p);
  }
  t("bool(bool): bool", n), t("bool(string): bool", (d) => {
    switch (d) {
      case "1":
      case "t":
      case "true":
      case "TRUE":
      case "True":
        return !0;
      case "0":
      case "f":
      case "false":
      case "FALSE":
      case "False":
        return !1;
      default:
        throw new tt(`bool() conversion error: invalid string value "${d}"`);
    }
  }), t("size(string): int", (d) => BigInt(zg(d))), t("size(bytes): int", (d) => BigInt(d.length)), t("size(list): int", (d) => BigInt(d.length ?? d.size)), t("size(map): int", (d) => BigInt(d instanceof Map ? d.size : $n(d).length)), t("string.size(): int", (d) => BigInt(zg(d))), t("bytes.size(): int", (d) => BigInt(d.length)), t("list.size(): int", (d) => BigInt(d.length ?? d.size)), t("map.size(): int", (d) => BigInt(d instanceof Map ? d.size : $n(d).length)), t("bytes(string): bytes", (d) => s.fromString(d)), t("bytes(bytes): bytes", n), t("double(double): double", n), t("double(int): double", (d) => Number(d)), t("double(uint): double", (d) => Number(d)), t("double(string): double", (d) => {
    if (!d || d !== d.trim())
      throw new tt("double() type error: cannot convert to double");
    switch (d.toLowerCase()) {
      case "inf":
      case "+inf":
      case "infinity":
      case "+infinity":
        return Number.POSITIVE_INFINITY;
      case "-inf":
      case "-infinity":
        return Number.NEGATIVE_INFINITY;
      case "nan":
        return Number.NaN;
      default: {
        const y = Number(d);
        if (!Number.isNaN(y)) return y;
        throw new tt("double() type error: cannot convert to double");
      }
    }
  }), t("int(int): int", n), t("int(double): int", (d) => {
    if (Number.isFinite(d)) return BigInt(Math.trunc(d));
    throw new tt("int() type error: integer overflow");
  }), t("int(string): int", (d) => {
    if (d !== d.trim() || d.length > 20 || d.includes("0x"))
      throw new tt("int() type error: cannot convert to int");
    try {
      const p = BigInt(d);
      if (p <= 9223372036854775807n && p >= -9223372036854775808n) return p;
    } catch {
    }
    throw new tt("int() type error: cannot convert to int");
  }), t("uint(uint): uint", n), t("uint(int): uint", (d) => {
    if (d >= 0n && d <= 18446744073709551615n) return d;
    throw new tt("uint() type error: cannot convert to uint");
  }), t("uint(double): uint", (d) => {
    if (d >= 0 && Number.isFinite(d)) return BigInt(Math.trunc(d));
    throw new tt("uint() type error: unsigned integer overflow");
  }), t("uint(string): uint", (d) => {
    if (d !== d.trim() || d.length > 20 || d.includes("0x"))
      throw new tt("uint() type error: cannot convert to uint");
    try {
      const p = BigInt(d);
      if (p <= 18446744073709551615n && p >= 0n) return p;
    } catch {
    }
    throw new tt("uint() type error: cannot convert to uint");
  }), t("string(string): string", n), t("string(bool): string", (d) => `${d}`), t("string(int): string", (d) => `${d}`), t("string(bytes): string", (d) => s.toUtf8(d)), t("string(double): string", (d) => d === 1 / 0 ? "+Inf" : d === -1 / 0 ? "-Inf" : `${d}`), t("string.startsWith(string): bool", (d, p) => d.startsWith(p)), t("string.endsWith(string): bool", (d, p) => d.endsWith(p)), t("string.contains(string): bool", (d, p) => d.includes(p)), t("string.lowerAscii(): string", (d) => d.toLowerCase()), t("string.upperAscii(): string", (d) => d.toUpperCase()), t("string.trim(): string", (d) => d.trim()), t(
    "string.indexOf(string): int",
    (d, p) => BigInt(d.indexOf(p))
  ), t("string.indexOf(string, int): int", (d, p, y) => {
    if (p === "") return y;
    if (y = Number(y), y < 0 || y >= d.length)
      throw new tt("string.indexOf(search, fromIndex): fromIndex out of range");
    return BigInt(d.indexOf(p, y));
  }), t(
    "string.lastIndexOf(string): int",
    (d, p) => BigInt(d.lastIndexOf(p))
  ), t("string.lastIndexOf(string, int): int", (d, p, y) => {
    if (p === "") return y;
    if (y = Number(y), y < 0 || y >= d.length)
      throw new tt("string.lastIndexOf(search, fromIndex): fromIndex out of range");
    return BigInt(d.lastIndexOf(p, y));
  }), t("string.substring(int): string", (d, p) => {
    if (p = Number(p), p < 0 || p > d.length)
      throw new tt("string.substring(start, end): start index out of range");
    return d.substring(p);
  }), t("string.substring(int, int): string", (d, p, y) => {
    if (p = Number(p), p < 0 || p > d.length)
      throw new tt("string.substring(start, end): start index out of range");
    if (y = Number(y), y < p || y > d.length)
      throw new tt("string.substring(start, end): end index out of range");
    return d.substring(p, y);
  }), t("string.matches(string): bool", (d, p) => {
    try {
      return new RegExp(p).test(d);
    } catch {
      throw new tt(`Invalid regular expression: ${p}`);
    }
  }), t("string.split(string): list<string>", (d, p) => d.split(p)), t("string.split(string, int): list<string>", (d, p, y) => {
    if (y = Number(y), y === 0) return [];
    const x = d.split(p);
    if (y < 0 || x.length <= y) return x;
    const S = x.slice(0, y - 1);
    return S.push(x.slice(y - 1).join(p)), S;
  }), t("list<string>.join(): string", (d) => {
    for (let p = 0; p < d.length; p++)
      if (typeof d[p] != "string")
        throw new tt("string.join(): list must contain only strings");
    return d.join("");
  }), t("list<string>.join(string): string", (d, p) => {
    for (let y = 0; y < d.length; y++)
      if (typeof d[y] != "string")
        throw new tt("string.join(separator): list must contain only strings");
    return d.join(p);
  });
  const r = new TextEncoder("utf8"), i = new TextDecoder("utf8"), s = typeof Buffer < "u" ? {
    byteLength: (d) => Buffer.byteLength(d),
    fromString: (d) => Buffer.from(d, "utf8"),
    toHex: (d) => Buffer.prototype.hexSlice.call(d, 0, d.length),
    toBase64: (d) => Buffer.prototype.base64Slice.call(d, 0, d.length),
    toUtf8: (d) => Buffer.prototype.utf8Slice.call(d, 0, d.length),
    jsonParse: (d) => JSON.parse(d)
  } : {
    textEncoder: new TextEncoder("utf8"),
    byteLength: (d) => r.encode(d).length,
    fromString: (d) => r.encode(d),
    toHex: Uint8Array.prototype.toHex ? (d) => d.toHex() : (d) => jg(d, (p) => p.toString(16).padStart(2, "0")).join(""),
    toBase64: Uint8Array.prototype.toBase64 ? (d) => d.toBase64() : (d) => btoa(jg(d, (p) => String.fromCodePoint(p)).join("")),
    toUtf8: (d) => i.decode(d),
    jsonParse: (d) => JSON.parse(r.decode(d))
  };
  t("bytes.json(): map", s.jsonParse), t("bytes.hex(): string", s.toHex), t("bytes.string(): string", s.toUtf8), t("bytes.base64(): string", s.toBase64), t("bytes.at(int): int", (d, p) => {
    if (p < 0 || p >= d.length) throw new tt("Bytes index out of range");
    return BigInt(d[p]);
  });
  const o = "google.protobuf.Timestamp", a = "google.protobuf.Duration", c = e.registerType(o, Date).getObjectType(o).typeType, u = e.registerType(a, Ir).getObjectType(a).typeType;
  e.registerConstant("google", "map<string, map<string, type>>", {
    protobuf: { Duration: u, Timestamp: c }
  });
  function l(d, p) {
    return new Date(d.toLocaleString("en-US", { timeZone: p }));
  }
  function f(d, p) {
    const y = p ? l(d, p) : new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()), x = new Date(y.getFullYear(), 0, 0);
    return BigInt(Math.floor((y - x) / 864e5) - 1);
  }
  t(`timestamp(string): ${o}`, (d) => {
    if (d.length < 20 || d.length > 30)
      throw new tt("timestamp() requires a string in ISO 8601 format");
    const p = new Date(d);
    if (p <= 253402300799999 && p >= -621355968e5) return p;
    throw new tt("timestamp() requires a string in ISO 8601 format");
  }), t(`timestamp(int): ${o}`, (d) => {
    if (d = Number(d) * 1e3, d <= 253402300799999 && d >= -621355968e5) return new Date(d);
    throw new tt("timestamp() requires a valid integer unix timestamp");
  }), t(`${o}.getDate(): int`, (d) => BigInt(d.getUTCDate())), t(`${o}.getDate(string): int`, (d, p) => BigInt(l(d, p).getDate())), t(`${o}.getDayOfMonth(): int`, (d) => BigInt(d.getUTCDate() - 1)), t(
    `${o}.getDayOfMonth(string): int`,
    (d, p) => BigInt(l(d, p).getDate() - 1)
  ), t(`${o}.getDayOfWeek(): int`, (d) => BigInt(d.getUTCDay())), t(`${o}.getDayOfWeek(string): int`, (d, p) => BigInt(l(d, p).getDay())), t(`${o}.getDayOfYear(): int`, f), t(`${o}.getDayOfYear(string): int`, f), t(`${o}.getFullYear(): int`, (d) => BigInt(d.getUTCFullYear())), t(`${o}.getFullYear(string): int`, (d, p) => BigInt(l(d, p).getFullYear())), t(`${o}.getHours(): int`, (d) => BigInt(d.getUTCHours())), t(`${o}.getHours(string): int`, (d, p) => BigInt(l(d, p).getHours())), t(`${o}.getMilliseconds(): int`, (d) => BigInt(d.getUTCMilliseconds())), t(`${o}.getMilliseconds(string): int`, (d) => BigInt(d.getUTCMilliseconds())), t(`${o}.getMinutes(): int`, (d) => BigInt(d.getUTCMinutes())), t(`${o}.getMinutes(string): int`, (d, p) => BigInt(l(d, p).getMinutes())), t(`${o}.getMonth(): int`, (d) => BigInt(d.getUTCMonth())), t(`${o}.getMonth(string): int`, (d, p) => BigInt(l(d, p).getMonth())), t(`${o}.getSeconds(): int`, (d) => BigInt(d.getUTCSeconds())), t(`${o}.getSeconds(string): int`, (d, p) => BigInt(l(d, p).getSeconds()));
  const h = /(\d*\.?\d*)(ns|us|¬µs|ms|s|m|h)/;
  function g(d) {
    if (!d) throw new tt("Invalid duration string: ''");
    const p = d[0] === "-";
    (d[0] === "-" || d[0] === "+") && (d = d.slice(1));
    let y = BigInt(0);
    for (; ; ) {
      const A = h.exec(d);
      if (!A) throw new tt(`Invalid duration string: ${d}`);
      if (A.index !== 0) throw new tt(`Invalid duration string: ${d}`);
      d = d.slice(A[0].length);
      const R = s2[A[2]], [N = "0", F = ""] = A[1].split("."), w = BigInt(N) * R, K = F ? BigInt(F.slice(0, 13).padEnd(13, "0")) * R / 10000000000000n : 0n;
      if (y += w + K, d === "") break;
    }
    const x = y >= 1000000000n ? y / 1000000000n : 0n, S = Number(y % 1000000000n);
    return p ? new Ir(-x, -S) : new Ir(x, S);
  }
  t("duration(string): google.protobuf.Duration", (d) => g(d)), t("google.protobuf.Duration.getHours(): int", (d) => d.getHours()), t("google.protobuf.Duration.getMinutes(): int", (d) => d.getMinutes()), t("google.protobuf.Duration.getSeconds(): int", (d) => d.getSeconds()), t("google.protobuf.Duration.getMilliseconds(): int", (d) => d.getMilliseconds()), r2(e);
}
function zg(e) {
  let t = 0;
  for (const n of e) t++;
  return t;
}
class re {
  #t;
  constructor(t) {
    this.#t = t, jr(this);
  }
  get name() {
    return this.#t;
  }
  get [Symbol.toStringTag]() {
    return `Type<${this.#t}>`;
  }
  toString() {
    return `Type<${this.#t}>`;
  }
}
const Ie = {
  string: new re("string"),
  bool: new re("bool"),
  int: new re("int"),
  uint: new re("uint"),
  double: new re("double"),
  map: new re("map"),
  list: new re("list"),
  bytes: new re("bytes"),
  null_type: new re("null"),
  type: new re("type")
}, a2 = new re("optional");
class gu {
  #t = null;
  #e = null;
  constructor(t) {
    t instanceof gu ? (this.#t = t, this.#e = /* @__PURE__ */ new Map()) : this.#e = new Map(t);
  }
  fork(t = !0) {
    return t && (this.set = this.#n), new this.constructor(this);
  }
  #n() {
    throw new Error("Cannot modify frozen registry");
  }
  set(t, n) {
    return this.#e.set(t, n), this;
  }
  has(t) {
    return this.#e.has(t) || (this.#t ? this.#t.has(t) : !1);
  }
  get(t) {
    return this.#e.get(t) || this.#t?.get(t);
  }
  *#r() {
    this.#t && (yield* this.#t), yield* this.#e;
  }
  [Symbol.iterator]() {
    return this.#r();
  }
  get size() {
    return this.#e.size + (this.#t ? this.#t.size : 0);
  }
}
class c2 extends gu {
  get(t) {
    return super.get(t) ?? (Oc.has(t) ? void 0 : Ye);
  }
}
function dr(e, t = gu, n = !0) {
  return e instanceof t ? e.fork(n) : new t(e);
}
class zr {
  #t = /* @__PURE__ */ new WeakMap();
  #e = null;
  #n = null;
  constructor({ kind: t, type: n, name: r, keyType: i, valueType: s, values: o }) {
    this.kind = t, this.type = n, this.name = r, i && (this.keyType = i), s && (this.valueType = s), o && (this.values = o), this.unwrappedType = t === "dyn" && s ? s.unwrappedType : this, this.wrappedType = t === "dyn" ? this : G0(this.unwrappedType), t === "list" ? this.fieldLazy = this.#a : t === "map" ? this.fieldLazy = this.#o : t === "message" ? this.fieldLazy = this.#i : t === "optional" && (this.fieldLazy = this.#r), this.#e = this.kind === "dyn" || this.valueType?.hasDyn() || this.keyType?.hasDyn() || !1, this.#n = this.kind === "param" || this.keyType?.hasPlaceholder() || this.valueType?.hasPlaceholder() || !1, jr(this);
  }
  hasDyn() {
    return this.#e;
  }
  hasNoDynTypes() {
    return this.#e === !1;
  }
  isDynOrBool() {
    return this.type === "bool" || this.kind === "dyn";
  }
  isEmpty() {
    return this.valueType && this.valueType.kind === "param";
  }
  hasPlaceholder() {
    return this.#n;
  }
  unify(t, n) {
    const r = this;
    if (r === n || r.kind === "dyn" || n.kind === "param") return r;
    if (n.kind === "dyn" || r.kind === "param") return n;
    if (r.kind !== n.kind || !(r.hasPlaceholder() || n.hasPlaceholder() || r.hasDyn() || n.hasDyn())) return null;
    const i = r.valueType.unify(t, n.valueType);
    if (!i) return null;
    switch (r.kind) {
      case "optional":
        return t.getOptionalType(i);
      case "list":
        return t.getListType(i);
      case "map":
        const s = r.keyType.unify(t, n.keyType);
        return s ? t.getMapType(s, i) : null;
    }
  }
  templated(t, n) {
    if (!this.hasPlaceholder()) return this;
    switch (this.kind) {
      case "dyn":
        return this.valueType.templated(t, n);
      case "param":
        return n?.get(this.name) || this;
      case "map":
        return t.getMapType(this.keyType.templated(t, n), this.valueType.templated(t, n));
      case "list":
        return t.getListType(this.valueType.templated(t, n));
      case "optional":
        return t.getOptionalType(this.valueType.templated(t, n));
      default:
        return this;
    }
  }
  toString() {
    return this.name;
  }
  #r(t, n, r, i) {
    if (t = t instanceof An ? t.orValue() : t, t === void 0) return Ic;
    const s = i.debugType(t);
    try {
      return An.of(s.fieldLazy(t, n, r, i));
    } catch (o) {
      if (o instanceof tt) return Ic;
      throw o;
    }
  }
  #i(t, n, r, i) {
    const s = i.objectTypesByConstructor.get(t.constructor);
    if (!s || !(t instanceof s.ctor)) return;
    if (!s.fields) return Of(t, n) ? t[n] : void 0;
    const o = s.fields[n];
    if (!o) return;
    const a = t[n], c = i.debugType(a);
    switch (o) {
      case ft.dyn:
      case c:
        return a;
      default:
        if (o.matches(c)) return a;
    }
    throw new tt(`Field '${n}' is not of type '${o}', got '${c}'`, r);
  }
  #o(t, n, r, i) {
    let s;
    if (t instanceof Map ? s = t.get(n) : s = Of(t, n) ? t[n] : void 0, s === void 0) return;
    const o = this.valueType, a = i.debugType(s);
    if (o.matches(a)) return s;
    throw new tt(`Field '${n}' is not of type '${o}', got '${a}'`, r);
  }
  #a(t, n, r, i) {
    if (!(typeof n == "number" || typeof n == "bigint")) return;
    const s = t[n];
    if (s === void 0)
      throw new tt(
        `No such key: index out of bounds, index ${n} ${n < 0 ? "< 0" : `>= size ${t.length}`}`,
        r
      );
    const o = i.debugType(s);
    if (this.valueType.matches(o)) return s;
    throw new tt(
      `List item with index '${n}' is not of type '${this.valueType}', got '${o}'`,
      r
    );
  }
  fieldLazy() {
  }
  field(t, n, r, i) {
    const s = this.fieldLazy(t, n, r, i);
    if (s !== void 0) return s;
    throw new tt(`No such key: ${n}`, r);
  }
  matchesBoth(t) {
    return this.matches(t) && t.matches(this);
  }
  matches(t) {
    const n = this.unwrappedType;
    return t = t.unwrappedType, n === t || n.kind === "dyn" || t.kind === "dyn" || t.kind === "param" ? !0 : this.#t.get(t) ?? this.#t.set(t, this.#c(n, t)).get(t);
  }
  #c(t, n) {
    switch (t.kind) {
      case "dyn":
      case "param":
        return !0;
      case "list":
        return n.kind === "list" && t.valueType.matches(n.valueType);
      case "map":
        return n.kind === "map" && t.keyType.matches(n.keyType) && t.valueType.matches(n.valueType);
      case "optional":
        return n.kind === "optional" && t.valueType.matches(n.valueType);
      default:
        return t.name === n.name;
    }
  }
}
const u2 = "have a .callAst property or .evaluate(checker, macro, ctx) method.", l2 = "have a .callAst property or .typeCheck(checker, macro, ctx) method.";
function f2(e, t) {
  const n = `Macro '${e}' must`;
  return function(i) {
    const s = t(i);
    if (!s || typeof s != "object") throw new Error(`${n} return an object.`);
    if (s.callAst) return s;
    if (!s.evaluate) throw new Error(`${n} ${u2}`);
    if (!s.typeCheck) throw new Error(`${n} ${l2}`);
    return s;
  };
}
class d2 {
  #t;
  constructor({ name: t, receiverType: n, argTypes: r, returnType: i, handler: s }) {
    this.name = t, this.receiverType = n || null, this.argTypes = r, this.returnType = i, this.macro = r.includes(Oa);
    const o = n ? `${n}.` : "";
    this.signature = `${o}${t}(${r.join(", ")}): ${i}`, this.handler = this.macro ? f2(this.signature, s) : s, this.#t = this.returnType.hasPlaceholder() || this.receiverType?.hasPlaceholder() || this.argTypes.some((a) => a.hasPlaceholder()) || !1, jr(this);
  }
  hasPlaceholder() {
    return this.#t;
  }
  matchesArgs(t) {
    return t.length === this.argTypes.length && this.argTypes.every((n, r) => n.matches(t[r])) ? this : null;
  }
}
class Us {
  #t;
  constructor({ operator: t, leftType: n, rightType: r, handler: i, returnType: s }) {
    this.operator = t, this.leftType = n, this.rightType = r || null, this.handler = i, this.returnType = s, r ? this.signature = `${n} ${t} ${r}: ${s}` : this.signature = `${t}${n}: ${s}`, this.#t = this.leftType.hasPlaceholder() || this.rightType?.hasPlaceholder() || !1, jr(this);
  }
  hasPlaceholder() {
    return this.#t;
  }
  equals(t) {
    return this.operator === t.operator && this.leftType === t.leftType && this.rightType === t.rightType;
  }
}
function nh(e) {
  return new zr({
    kind: "list",
    name: `list<${e}>`,
    type: "list",
    valueType: e
  });
}
function Dn(e) {
  return new zr({ kind: "primitive", name: e, type: e });
}
function h2(e) {
  return new zr({ kind: "message", name: e, type: e });
}
function G0(e) {
  const t = e ? `dyn<${e}>` : "dyn";
  return new zr({ kind: "dyn", name: t, type: t, valueType: e });
}
function Y0(e) {
  const t = `optional<${e}>`;
  return new zr({ kind: "optional", name: t, type: "optional", valueType: e });
}
function rh(e, t) {
  return new zr({
    kind: "map",
    name: `map<${e}, ${t}>`,
    type: "map",
    keyType: e,
    valueType: t
  });
}
function p2(e) {
  return new zr({ kind: "param", name: e, type: e });
}
const Ye = G0(), Oa = Dn("ast"), qg = nh(Ye), Gg = rh(Ye, Ye), ft = {
  string: Dn("string"),
  bool: Dn("bool"),
  int: Dn("int"),
  uint: Dn("uint"),
  double: Dn("double"),
  bytes: Dn("bytes"),
  dyn: Ye,
  null: Dn("null"),
  type: Dn("type"),
  optional: Y0(Ye),
  list: qg,
  "list<dyn>": qg,
  map: Gg,
  "map<dyn, dyn>": Gg
};
for (const e of [ft.string, ft.double, ft.int]) {
  const t = nh(e), n = rh(ft.string, e);
  ft[t.name] = t, ft[n.name] = n;
}
Object.freeze(ft);
class g2 {
  returnType = null;
  /** @type {Array<FunctionDeclaration>} */
  declarations = [];
  constructor(t) {
    this.registry = t;
  }
  add(t) {
    this.returnType = (this.returnType || t.returnType).unify(this.registry, t.returnType) || Ye, t.macro && (this.macro = t), this.declarations.push(t);
  }
  findMatch(t, n = null) {
    for (let r = 0; r < this.declarations.length; r++) {
      const i = this.#t(this.declarations[r], t, n);
      if (i) return i;
    }
    return null;
  }
  #t(t, n, r) {
    if (t.hasPlaceholder()) return this.#e(t, n, r);
    if (!(r && t.receiverType && !r.matches(t.receiverType)))
      return t.matchesArgs(n);
  }
  #e(t, n, r) {
    const i = /* @__PURE__ */ new Map();
    if (r && t.receiverType && !this.registry.matchTypeWithPlaceholders(t.receiverType, r, i))
      return null;
    for (let s = 0; s < n.length; s++)
      if (!this.registry.matchTypeWithPlaceholders(t.argTypes[s], n[s], i))
        return null;
    return {
      handler: t.handler,
      signature: t.signature,
      returnType: t.returnType.templated(this.registry, i)
    };
  }
}
function Yg(e) {
  const t = [];
  let n = "", r = 0;
  for (const i of e) {
    if (i === "<") r++;
    else if (i === ">") r--;
    else if (i === "," && r === 0) {
      t.push(n.trim()), n = "";
      continue;
    }
    n += i;
  }
  return n && t.push(n.trim()), t;
}
const Z0 = [
  [void 0, "map", Ie.map, ft.map],
  [Object, "map", Ie.map, ft.map],
  [Map, "map", Ie.map, ft.map],
  [Array, "list", Ie.list, ft.list],
  [ti, "uint", Ie.uint, ft.uint],
  [re, "type", Ie.type, ft.type],
  [An, "optional", a2, ft.optional],
  [Uint8Array, "bytes", Ie.bytes, ft.bytes],
  ...typeof Buffer < "u" ? [[Buffer, "bytes", Ie.bytes, ft.bytes]] : []
].map(([e, t, n, r]) => Object.freeze({ name: t, typeType: n, type: r, ctor: e })), y2 = Z0.map((e) => [e.name, e]), w2 = Z0.map((e) => [e.ctor, e]);
class ih {
  #t = {};
  #e = {};
  #n;
  #r;
  #i;
  #o = /* @__PURE__ */ new Map();
  #a = /* @__PURE__ */ new Map();
  #c = /* @__PURE__ */ new Map();
  #f = /* @__PURE__ */ new Map();
  #h = /* @__PURE__ */ new Map();
  constructor(t = {}) {
    if (this.enableOptionalTypes = t.enableOptionalTypes ?? !1, this.objectTypes = dr(t.objectTypes || y2), this.objectTypesByConstructor = dr(t.objectTypesByConstructor || w2), this.#i = dr(t.functionDeclarations), this.#r = dr(t.operatorDeclarations), this.#n = dr(
      t.typeDeclarations || i2(ft),
      void 0,
      !1
    ), this.constants = dr(t.constants), this.variables = t.unlistedVariablesAreDyn ? dr(t.variables, c2) : dr(t.variables), this.variables.size)
      n2(this, this.enableOptionalTypes);
    else
      for (const n in Ie) this.registerConstant(n, "type", Ie[n]);
  }
  #p() {
    this.#t = {}, this.#e = {};
  }
  registerVariable(t, n) {
    if (Oc.has(t)) throw new Error(`Cannot register reserved variable name: ${t}`);
    if (this.variables.has(t)) throw new Error(`Variable already registered: ${t}`);
    return this.variables.set(t, n instanceof zr ? n : this.getType(n)), this;
  }
  registerConstant(t, n, r) {
    return this.registerVariable(t, n), this.constants.set(t, r), this;
  }
  #g(t, n, r) {
    let i = t ? this.#a : this.#o;
    return i = i.get(n) || i.set(n, /* @__PURE__ */ new Map()).get(n), i.get(r) || i.set(r, new g2(this)).get(r);
  }
  getFunctionCandidates(t, n, r) {
    const i = (t ? this.#a : this.#o).get(n)?.get(r);
    if (i) return i;
    for (const [, s] of this.#i)
      this.#g(!!s.receiverType, s.name, s.argTypes.length).add(s);
    return this.#g(t, n, r);
  }
  getType(t) {
    return this.#s(t, !0);
  }
  getListType(t) {
    return this.#c.get(t) || this.#c.set(t, this.#s(`list<${t}>`, !0)).get(t);
  }
  getMapType(t, n) {
    return this.#f.get(t)?.get(n) || (this.#f.get(t) || this.#f.set(t, /* @__PURE__ */ new Map()).get(t)).set(n, this.#s(`map<${t}, ${n}>`, !0)).get(n);
  }
  getOptionalType(t) {
    return this.#h.get(t) || this.#h.set(t, this.#s(`optional<${t}>`, !0)).get(t);
  }
  assertType(t, n, r) {
    try {
      return this.#s(t, !0);
    } catch (i) {
      throw i.message = `Invalid ${n} '${i.unknownType || t}' in '${r}'`, i;
    }
  }
  getFunctionType(t) {
    return t === "ast" ? Oa : this.#s(t, !0);
  }
  registerType(t, n) {
    if (typeof t == "object" && (n = t, t = n.fullName || n.name || n.ctor?.name), typeof t == "string" && t[0] === "." && (t = t.slice(1)), typeof t != "string" || t.length < 2 || Oc.has(t))
      throw new Error(`Message type name invalid: ${t}`);
    if (this.objectTypes.has(t)) throw new Error(`Message type already registered: ${t}`);
    const r = this.#s(t, !1);
    if (r.kind !== "message") throw new Error(`Message type invalid: ${t}`);
    const i = typeof n == "function" ? n : n?.ctor;
    if (typeof i != "function") throw new Error(`Message type constructor invalid: '${t}'`);
    const s = Object.freeze({
      name: t,
      typeType: new re(t),
      type: r,
      ctor: i,
      fields: this.#v(t, n?.fields)
    });
    return this.objectTypes.set(t, s), this.objectTypesByConstructor.set(i, s), this.registerFunctionOverload(`type(${t}): type`, () => s.typeType), this;
  }
  getObjectType(t) {
    return this.objectTypes.get(t);
  }
  /** @returns {TypeDeclaration} */
  #s(t, n = !0) {
    let r = this.#n.get(t);
    if (r) return r;
    if (r = t.match(/^[A-Z]$/), r) return this.#u(p2, t, t);
    if (r = t.match(/^(dyn|list|map|optional)<(.+)>$/), !r) {
      if (n) {
        const o = new Error(`Unknown type: ${t}`);
        throw o.unknownType = t, o;
      }
      return this.#u(h2, t, t);
    }
    const i = r[1], s = r[2].trim();
    switch (i) {
      case "dyn": {
        const o = this.#s(s, n).wrappedType;
        return this.#n.set(o.name, o), o;
      }
      case "list": {
        const o = this.#s(s, n);
        return this.#u(nh, `list<${o}>`, o);
      }
      case "map": {
        const o = Yg(s);
        if (o.length !== 2) throw new Error(`Invalid map type: ${t}`);
        const a = this.#s(o[0], n), c = this.#s(o[1], n);
        return this.#u(rh, `map<${a}, ${c}>`, a, c);
      }
      case "optional": {
        const o = this.#s(s, n);
        return this.#u(Y0, `optional<${o}>`, o);
      }
    }
  }
  #u(t, n, ...r) {
    return this.#n.get(n) || this.#n.set(n, t(...r)).get(n);
  }
  findMacro(t, n, r) {
    return this.getFunctionCandidates(n, t, r).macro || !1;
  }
  #y(t, n, r) {
    const i = [], s = n.unwrappedType, o = r.unwrappedType;
    for (const [, a] of this.#r) {
      if (a.operator !== t) continue;
      if (a.leftType === s && a.rightType === o) return [a];
      if (a.leftType === n && a.rightType === r) return [a];
      const c = this.#E(a, n, r);
      c && i.push(c);
    }
    return i.length === 0 && (t === "==" || t === "!=") && (n.kind === "dyn" || r.kind === "dyn") ? [{ handler: t === "==" ? (c, u) => c === u : (c, u) => c !== u, returnType: this.getType("bool") }] : i;
  }
  findUnaryOverload(t, n) {
    const r = this.#t[t]?.get(n);
    if (r !== void 0) return r;
    let i = !1;
    for (const [, s] of this.#r)
      if (!(s.operator !== t || s.leftType !== n)) {
        i = s;
        break;
      }
    return (this.#t[t] ??= /* @__PURE__ */ new Map()).set(n, i).get(n);
  }
  findBinaryOverload(t, n, r) {
    return this.#t[t]?.get(n)?.get(r) ?? this.#w(
      this.#t,
      t,
      n,
      r,
      this.#m(t, n, r)
    );
  }
  checkBinaryOverload(t, n, r) {
    return this.#e[t]?.get(n)?.get(r) ?? this.#w(
      this.#e,
      t,
      n,
      r,
      this.#b(t, n, r)
    );
  }
  #m(t, n, r) {
    const i = this.#y(t, n, r);
    if (i.length === 0) return !1;
    if (i.length === 1) return i[0];
    throw new Error(`Operator overload '${i[0].signature}' overlaps with '${i[1].signature}'.`);
  }
  #b(t, n, r) {
    const i = this.#y(t, n, r);
    if (i.length === 0) return !1;
    const s = i[0].returnType;
    return i.every((o) => o.returnType === s) ? s : (s.kind === "list" || s.kind === "map") && i.every((o) => o.returnType.kind === s.kind) ? s.kind === "list" ? ft.list : ft.map : ft.dyn;
  }
  #w(t, n, r, i, s) {
    const o = t[n] ??= /* @__PURE__ */ new Map();
    return (o.get(r) || o.set(r, /* @__PURE__ */ new Map()).get(r)).set(i, s), s;
  }
  #E(t, n, r) {
    const i = t.hasPlaceholder() ? /* @__PURE__ */ new Map() : null, s = this.matchTypeWithPlaceholders(t.leftType, n, i);
    if (!s) return;
    const o = this.matchTypeWithPlaceholders(t.rightType, r, i);
    if (o)
      return (t.operator === "==" || t.operator === "!=") && !s.matchesBoth(o) ? !1 : t.hasPlaceholder() ? {
        handler: t.handler,
        leftType: s,
        rightType: o,
        returnType: t.returnType.templated(this, i)
      } : t;
  }
  matchTypeWithPlaceholders(t, n, r) {
    if (!t.hasPlaceholder()) return n.matches(t) ? n : null;
    const i = n.kind === "dyn";
    return this.#l(t, n, r, i) && (i || n.matches(t.templated(this, r))) ? n : null;
  }
  #x(t, n, r) {
    const i = r.get(t);
    return i ? i.kind === "dyn" || n.kind === "dyn" ? !0 : i.matchesBoth(n) : r.set(t, n) && !0;
  }
  #l(t, n, r, i = !1) {
    if (!t.hasPlaceholder()) return !0;
    if (!n) return !1;
    const s = i || n.kind === "dyn";
    switch (n = n.unwrappedType, t.kind) {
      case "param": {
        const o = s ? ft.dyn : n;
        return this.#x(t.name, o, r);
      }
      case "list":
        return n.name === "dyn" && (n = t), n.kind !== "list" ? !1 : this.#l(
          t.valueType,
          n.valueType,
          r,
          s
        );
      case "map":
        return n.name === "dyn" && (n = t), n.kind !== "map" ? !1 : this.#l(
          t.keyType,
          n.keyType,
          r,
          s
        ) && this.#l(
          t.valueType,
          n.valueType,
          r,
          s
        );
      case "optional":
        return n.name === "dyn" && (n = t), n.kind !== "optional" ? !1 : this.#l(
          t.valueType,
          n.valueType,
          r,
          s
        );
    }
    return !0;
  }
  #T(t) {
    return typeof t == "string" ? { type: t } : t.id ? b2(t) : t;
  }
  #S(t, n, r, i = !1) {
    try {
      const s = this.#T(n[r]);
      if (typeof s?.type != "string") throw new Error("unsupported declaration");
      return this.#s(s.type, i);
    } catch (s) {
      throw s.message = `Field '${r}' in type '${t}' has unsupported declaration: ${JSON.stringify(n[r])}`, s;
    }
  }
  #v(t, n) {
    if (!n) return;
    const r = /* @__PURE__ */ Object.create(null);
    for (const i of $n(n)) r[i] = this.#S(t, n, i);
    return r;
  }
  clone(t) {
    return new ih({
      objectTypes: this.objectTypes,
      objectTypesByConstructor: this.objectTypesByConstructor,
      typeDeclarations: this.#n,
      operatorDeclarations: this.#r,
      functionDeclarations: this.#i,
      variables: this.variables,
      constants: this.constants,
      unlistedVariablesAreDyn: t.unlistedVariablesAreDyn,
      enableOptionalTypes: t.enableOptionalTypes
    });
  }
  /** @param {string} signature */
  #k(t, n) {
    const r = t.match(/^(?:([a-zA-Z0-9.<>]+)\.)?(\w+)\((.*?)\):\s*(.+)$/);
    if (!r) throw new Error(`Invalid signature: ${t}`);
    const [, i, s, o, a] = r;
    try {
      return new d2({
        name: s,
        receiverType: i ? this.getType(i) : null,
        returnType: this.getType(a.trim()),
        argTypes: Yg(o).map((c) => this.getFunctionType(c)),
        handler: n
      });
    } catch (c) {
      throw new Error(`Invalid function declaration: ${t}: ${c.message}`);
    }
  }
  /**
   * @param {FunctionDeclaration} a
   * @param {FunctionDeclaration} b
   */
  #A(t, n) {
    return t.name !== n.name || t.argTypes.length !== n.argTypes.length || (t.receiverType || n.receiverType) && (!t.receiverType || !n.receiverType) ? !1 : !(t.receiverType !== n.receiverType && t.receiverType !== Ye && n.receiverType !== Ye) && (n.macro || t.macro || n.argTypes.every((i, s) => {
      const o = t.argTypes[s];
      return i === o || i === Oa || o === Oa || i === Ye || o === Ye;
    }));
  }
  /** @param {FunctionDeclaration} newDec */
  #$(t) {
    for (const [, n] of this.#i)
      if (this.#A(n, t))
        throw new Error(
          `Function signature '${t.signature}' overlaps with existing overload '${n.signature}'.`
        );
  }
  registerFunctionOverload(t, n) {
    const r = typeof n == "function" ? n : n?.handler, i = this.#k(t, r);
    this.#$(i), this.#i.set(i.signature, i), this.#a.clear(), this.#o.clear();
  }
  registerOperatorOverload(t, n) {
    const r = t.match(/^([-!])([\w.<>]+)(?::\s*([\w.<>]+))?$/);
    if (r) {
      const [, u, l, f] = r;
      return this.unaryOverload(u, l, n, f);
    }
    const i = t.match(
      /^([\w.<>]+) ([-+*%/]|==|!=|<|<=|>|>=|in) ([\w.<>]+)(?::\s*([\w.<>]+))?$/
    );
    if (!i) throw new Error(`Operator overload invalid: ${t}`);
    const [, s, o, a, c] = i;
    return this.binaryOverload(s, o, a, n, c);
  }
  unaryOverload(t, n, r, i) {
    const s = this.assertType(n, "type", `${t}${n}`), o = this.assertType(
      i || n,
      "return type",
      `${t}${n}: ${i || n}`
    ), a = new Us({ operator: `${t}_`, leftType: s, returnType: o, handler: r });
    if (this.#d(a))
      throw new Error(`Operator overload already registered: ${t}${n}`);
    this.#r.set(a.signature, a), this.#p();
  }
  #d(t) {
    for (const [, n] of this.#r) if (t.equals(n)) return !0;
    return !1;
  }
  binaryOverload(t, n, r, i, s) {
    s ??= Zg(n) ? "bool" : t;
    const o = `${t} ${n} ${r}: ${s}`, a = this.assertType(t, "left type", o), c = this.assertType(r, "right type", o), u = this.assertType(s, "return type", o);
    if (Zg(n) && u.type !== "bool")
      throw new Error(`Comparison operator '${n}' must return 'bool', got '${u.type}'`);
    const l = new Us({ operator: n, leftType: a, rightType: c, returnType: u, handler: i });
    if (l.hasPlaceholder() && !(c.hasPlaceholder() && a.hasPlaceholder()))
      throw new Error(
        `Operator overload with placeholders must use them in both left and right types: ${o}`
      );
    if (this.#d(l))
      throw new Error(`Operator overload already registered: ${l.signature}`);
    if (n === "==") {
      const f = [
        new Us({
          operator: "!=",
          leftType: a,
          rightType: c,
          handler(h, g, d, p) {
            return !i(h, g, d, p);
          },
          returnType: u
        })
      ];
      a !== c && f.push(
        new Us({
          operator: "==",
          leftType: c,
          rightType: a,
          handler(h, g, d, p) {
            return i(g, h, d, p);
          },
          returnType: u
        }),
        new Us({
          operator: "!=",
          leftType: c,
          rightType: a,
          handler(h, g, d, p) {
            return !i(g, h, d, p);
          },
          returnType: u
        })
      );
      for (const h of f)
        if (this.#d(h))
          throw new Error(`Operator overload already registered: ${h.signature}`);
      for (const h of f) this.#r.set(h.signature, h);
    }
    this.#r.set(l.signature, l), this.#p();
  }
}
function Zg(e) {
  return e === "<" || e === "<=" || e === ">" || e === ">=" || e === "==" || e === "!=" || e === "in";
}
function m2(e) {
  return new ih(e);
}
class Xg {
  #t;
  #e;
  #n;
  constructor(t, n) {
    if (this.#t = t.variables, this.#e = t.constants, n != null) {
      if (typeof n != "object") throw new tt("Context must be an object");
      this.#n = n, n instanceof Map ? this.getValue = this.#i : this.getValue = this.#r;
    }
  }
  #r(t) {
    const n = this.#n[t];
    return n !== void 0 ? n : this.#e.get(t);
  }
  #i(t) {
    const n = this.#n.get(t);
    return n !== void 0 ? n : this.#t.get(t);
  }
  getType(t) {
    return this.#t.get(t);
  }
  getValue(t) {
    return this.#e.get(t);
  }
  forkWithVariable(t, n) {
    return new Bc(this, t, n);
  }
}
class Bc {
  #t;
  accuType;
  accuValue;
  iterValue;
  constructor(t, n, r) {
    this.#t = t, this.iterVar = n, this.iterType = r;
  }
  forkWithVariable(t, n) {
    return new Bc(this, t, n);
  }
  reuse(t) {
    if (!this.async) return (this.#t = t) && this;
    const n = new Bc(t, this.iterVar, this.iterType);
    return n.accuType = this.accuType, n;
  }
  setIterValue(t) {
    return this.iterValue = t, this;
  }
  setAccuType(t) {
    return this.accuType = t, this;
  }
  setAccuValue(t) {
    return this.accuValue = t, this;
  }
  getValue(t) {
    return this.iterVar === t ? this.iterValue : this.#t.getValue(t);
  }
  getType(t) {
    return this.iterVar === t ? this.iterType : this.#t.getType(t);
  }
}
function b2(e) {
  let t;
  if (e.map) {
    const n = ll(e.keyType, e.resolvedKeyType), r = ll(e.type, e.resolvedType);
    t = `map<${n}, ${r}>`;
  } else
    t = ll(e.type, e.resolvedType);
  return { type: e.repeated ? `list<${t}>` : t };
}
function ll(e, t) {
  switch (e) {
    case "string":
      return "string";
    case "bytes":
      return "bytes";
    case "bool":
      return "bool";
    // protobufjs uses JavaScript numbers for all numeric types
    case "double":
    case "float":
    case "int32":
    case "int64":
    case "sint32":
    case "sint64":
    case "sfixed32":
    case "sfixed64":
    case "uint32":
    case "uint64":
    case "fixed32":
    case "fixed64":
      return "double";
    default:
      switch (t?.constructor.name) {
        case "Type":
          return t.fullName.slice(1);
        case "Enum":
          return "int";
      }
      return e?.includes(".") ? e : "dyn";
  }
}
class X0 {
  dynType = ft.dyn;
  optionalType = ft.optional;
  stringType = ft.string;
  intType = ft.int;
  doubleType = ft.double;
  boolType = ft.bool;
  nullType = ft.null;
  listType = ft.list;
  mapType = ft.map;
  constructor(t) {
    this.opts = t.opts, this.objectTypes = t.objectTypes, this.objectTypesByConstructor = t.objectTypesByConstructor, this.registry = t.registry;
  }
  /**
   * Get a TypeDeclaration instance for a type name
   * @param {string} typeName - The type name (e.g., 'string', 'int', 'dyn')
   * @returns {TypeDeclaration} The type declaration instance
   */
  getType(t) {
    return this.registry.getType(t);
  }
  debugType(t) {
    switch (typeof t) {
      case "string":
        return this.stringType;
      case "bigint":
        return this.intType;
      case "number":
        return this.doubleType;
      case "boolean":
        return this.boolType;
      case "object":
        if (t === null) return this.nullType;
        switch (t.constructor) {
          case void 0:
          case Object:
          case Map:
            return this.mapType;
          case Array:
          case Set:
            return this.listType;
          default:
            return this.objectTypesByConstructor.get(t.constructor)?.type || Qg(this, t.constructor?.name || typeof t);
        }
      default:
        Qg(this, typeof t);
    }
  }
}
function Qg(e, t) {
  throw new e.Error(`Unsupported type: ${t}`);
}
function Ba(e, t, n, r, i) {
  return n instanceof Promise ? r instanceof Promise ? Promise.all([n, r]).then((s) => i(e, t, s[0], s[1])) : n.then((s) => i(e, t, s, r)) : r.then((s) => i(e, t, n, s));
}
function Jg(e, t, n) {
  const r = e.check(t.args[0], n);
  return t.op === "[]" && e.check(t.args[1], n), r.kind !== "optional" ? e.checkAccessOnType(t, n, r) : e.registry.getOptionalType(e.checkAccessOnType(t, n, r.valueType, !0));
}
function ty(e, t, n) {
  const r = e.check(t.args[0], n);
  t.op === "[?]" && e.check(t.args[1], n);
  const i = r.kind === "optional" ? r.valueType : r;
  return e.registry.getOptionalType(e.checkAccessOnType(t, n, i, !0));
}
function ey(e, t, n, r, i) {
  const s = e.check(r, t);
  if (s === n || n.isEmpty()) return s;
  if (s.isEmpty()) return n;
  let o;
  throw i === 0 ? o = "List elements must have the same type," : i === 1 ? o = "Map key uses wrong type," : i === 2 && (o = "Map value uses wrong type,"), new e.Error(
    `${o} expected type '${e.formatType(n)}' but found '${e.formatType(s)}'`,
    r
  );
}
function ny(e, t, n, r) {
  return n.unify(e.registry, e.check(r, t)) || e.dynType;
}
function E2(e, t, n) {
  const r = e.debugRuntimeType(t, n.checkedType);
  return new e.Error(`${n.meta.label || "Ternary condition must be bool"}, got '${r}'`, n);
}
function ry(e, t, n, r) {
  if (r === !0) return e.eval(t.args[1], n);
  if (r === !1) return e.eval(t.args[2], n);
  throw E2(e, r, t.args[0]);
}
function iy(e, t, n) {
  if (t.staticHandler) return t.staticHandler.handler(n, t, e);
  const r = e.debugRuntimeType(n, t.args.checkedType), i = e.registry.findUnaryOverload(t.op, r);
  if (i) return i.handler(n);
  throw new e.Error(`no such overload: ${t.op[0]}${r}`, t);
}
function sy(e, t, n) {
  const r = e.eval(t.args, n);
  return r instanceof Promise ? r.then((i) => iy(e, t, i)) : iy(e, t, r);
}
function oy(e, t, n, r) {
  if (t.staticHandler) return t.staticHandler.handler(n, r, t, e);
  const i = e.debugOperandType(n, t.args[0].checkedType), s = e.debugOperandType(r, t.args[1].checkedType), o = e.registry.findBinaryOverload(t.op, i, s);
  if (o) return o.handler(n, r, t, e);
  throw new e.Error(`no such overload: ${i} ${t.op} ${s}`, t);
}
function sh(e, t, n) {
  const r = e.debugRuntimeType(t, n.checkedType);
  return new e.Error(`Logical operator requires bool operands, got '${r}'`, n);
}
function Q0(e, t, n) {
  return t instanceof Error ? t : sh(e, t, n);
}
function Ii(e, t, n, r, i) {
  if (i === e) return e;
  if (i === !e) {
    if (r === i) return i;
    throw Q0(t, r, n.args[0]);
  }
  if (i instanceof Promise) return i.then((s) => x2(e, t, n, r, s));
  throw sh(t, i, n.args[1]);
}
function x2(e, t, n, r, i) {
  if (i === e) return e;
  if (typeof i != "boolean") throw sh(t, i, n.args[1]);
  if (typeof r != "boolean") throw Q0(t, r, n.args[0]);
  return !e;
}
function ay(e, t, n) {
  const r = e.check(t.args[0], n), i = e.check(t.args[1], n);
  if (!r.isDynOrBool())
    throw new e.Error(
      `Logical operator requires bool operands, got '${e.formatType(r)}'`,
      t
    );
  if (!i.isDynOrBool())
    throw new e.Error(
      `Logical operator requires bool operands, got '${e.formatType(i)}'`,
      t
    );
  return e.boolType;
}
function cy(e, t, n) {
  const r = t.op, i = e.check(t.args, n);
  if (i.kind === "dyn") return r === "!_" ? e.boolType : i;
  const s = e.registry.findUnaryOverload(r, i);
  if (!s) throw new e.Error(`no such overload: ${r[0]}${e.formatType(i)}`, t);
  return (t.staticHandler = s).returnType;
}
function T2(e, t, n) {
  const r = t.op, i = e.check(t.args[0], n), s = e.check(t.args[1], n);
  i.hasDyn() || s.hasDyn() || (t.staticHandler = e.registry.findBinaryOverload(r, i, s));
  const o = t.staticHandler?.returnType || e.registry.checkBinaryOverload(r, i, s);
  if (o) return o;
  throw new e.Error(
    `no such overload: ${e.formatType(i)} ${r} ${e.formatType(s)}`,
    t
  );
}
function S2(e, t, n) {
  const r = t.args, i = e.eval(r[0], n), s = e.eval(r[1], n);
  return i instanceof Promise || s instanceof Promise ? Ba(e, t, i, s, oy) : oy(e, t, i, s);
}
function uy(e, t, n) {
  if (t.staticHandler) return t.staticHandler.handler.apply(e, n);
  const [r, i] = t.args, s = i.length, o = t.functionCandidates ??= e.registry.getFunctionCandidates(
    !1,
    r,
    s
  ), a = t.argTypes ??= new Array(s);
  let c = s;
  for (; c--; ) a[c] = e.debugOperandType(n[c], i[c].checkedType);
  const u = o.findMatch(a);
  if (u) return u.handler.apply(e, n);
  throw new e.Error(
    `found no matching overload for '${r}(${a.map((l) => l.unwrappedType).join(", ")})'`,
    t
  );
}
function ly(e, t, n, r) {
  if (t.staticHandler) return t.staticHandler.handler.call(e, n, ...r);
  const [i, s, o] = t.args, a = t.functionCandidates ??= e.registry.getFunctionCandidates(
    !0,
    i,
    o.length
  );
  let c = r.length;
  const u = t.argTypes ??= new Array(c);
  for (; c--; ) u[c] = e.debugOperandType(r[c], o[c].checkedType);
  const l = e.debugRuntimeType(n, s.checkedType || e.dynType), f = a.findMatch(u, l);
  if (f) return f.handler.call(e, n, ...r);
  throw new e.Error(
    `found no matching overload for '${l.type}.${i}(${u.map((h) => h.unwrappedType).join(", ")})'`,
    t
  );
}
function fl(e, t, n, r = t.length) {
  if (r === 0) return [];
  let i;
  const s = new Array(r);
  for (; r--; ) (s[r] = e.eval(t[r], n)) instanceof Promise && (i ??= !0);
  return i ? Promise.all(s) : s;
}
function fy(e) {
  const t = {};
  for (let n = 0; n < e.length; n++) {
    const [r, i] = e[n];
    r === "__proto__" || r === "constructor" || r === "prototype" || (t[r] = i);
  }
  return t;
}
function v2(e, t, n) {
  const r = e.check(t, n);
  if (r.kind === "dyn") return r;
  if (r.kind === "list") return r.valueType;
  if (r.kind === "map") return r.keyType;
  throw new e.Error(
    `Expression of type '${e.formatType(
      r
    )}' cannot be range of a comprehension (must be list, map, or dynamic).`,
    t
  );
}
function k2(e, t, n) {
  if (n instanceof Set) return [...n];
  if (n instanceof Map) return [...n.keys()];
  if (n && typeof n == "object") return $n(n);
  throw new e.Error(
    `Expression of type '${e.debugType(
      n
    )}' cannot be range of a comprehension (must be list, map, or dynamic).`,
    t.iterable
  );
}
function dy(e, t, n, r) {
  Ia(r) || (r = k2(e, t, r));
  const i = e.eval(t.init, n = t.iterCtx.reuse(n)), s = t.errorsAreFatal ? J0 : eE;
  return (n === t.iterCtx ? s : s.async)(e, n, t, r, n.accuValue = i, 0);
}
function J0(e, t, n, r, i, s) {
  const o = n.condition, a = n.step, c = r.length;
  for (; s < c && !(o && !o(i)); )
    if (i = e.eval(a, t.setIterValue(r[s++])), i instanceof Promise) return tE(e, t, n, r, i, s);
  return n.result(i);
}
async function tE(e, t, n, r, i, s) {
  t === n.iterCtx && (t.async = !0);
  const o = n.condition, a = n.step, c = r.length;
  for (i = await i; s < c; ) {
    if (o && !o(i)) return n.result(i);
    i = e.eval(a, t.setIterValue(r[s++])), i instanceof Promise && (i = await i);
  }
  return n.result(i);
}
function eE(e, t, n, r, i, s, o, a) {
  const c = n.condition, u = n.step, l = r.length;
  for (; s < l; ) {
    if (!c(i)) return n.result(i);
    if (a = e.tryEval(u, t.setIterValue(r[s++])), a instanceof Promise) return nE(e, t, n, r, i, s, o, a);
    a instanceof Error && (o ??= a) || (i = a);
  }
  if (o && c(i)) throw o;
  return n.result(i);
}
async function nE(e, t, n, r, i, s, o, a) {
  t === n.iterCtx && (t.async = !0);
  const c = n.condition, u = n.step, l = r.length;
  for (a = await a, a instanceof Error ? o ??= a : i = a; s < l; ) {
    if (!c(i)) return n.result(i);
    a = e.tryEval(u, t.setIterValue(r[s++])), a instanceof Promise && (a = await a), !(a instanceof Error && (o ??= a)) && (i = a);
  }
  if (o && c(i)) throw o;
  return n.result(i);
}
J0.async = tE;
eE.async = nE;
function ea(e, t, n, r) {
  return e.optionalType.field(n, r, t, e);
}
function na(e, t, n, r) {
  return e.debugType(n).field(n, r, t, e);
}
const X = {
  value: {
    check(e, t) {
      return e.debugType(t.args);
    },
    evaluate(e, t) {
      return t.args;
    }
  },
  id: {
    check(e, t, n) {
      const r = n.getType(t.args);
      if (r !== void 0) return r;
      throw new e.Error(`Unknown variable: ${t.args}`, t);
    },
    evaluate(e, t, n) {
      const r = t.checkedType || n.getType(t.args), i = r && n.getValue(t.args);
      if (i === void 0) throw new e.Error(`Unknown variable: ${t.args}`, t);
      const s = e.debugType(i);
      switch (r) {
        case s:
        case ft.dyn:
          return i;
        default:
          if (r.matches(s)) return i;
      }
      throw new e.Error(`Variable '${t.args}' is not of type '${r}', got '${s}'`, t);
    }
  },
  ".": {
    alias: "fieldAccess",
    check: Jg,
    evaluate(e, t, n) {
      const r = t.args, i = e.eval(r[0], n);
      return i instanceof Promise ? i.then((s) => na(e, t, s, r[1])) : na(e, t, i, r[1]);
    }
  },
  ".?": {
    alias: "optionalFieldAccess",
    check: ty,
    evaluate(e, t, n) {
      const r = t.args, i = e.eval(r[0], n);
      return i instanceof Promise ? i.then((s) => ea(e, t, s, r[1])) : ea(e, t, i, r[1]);
    }
  },
  "[]": {
    alias: "bracketAccess",
    check: Jg,
    evaluate(e, t, n) {
      const r = t.args, i = e.eval(r[0], n), s = e.eval(r[1], n);
      return i instanceof Promise || s instanceof Promise ? Ba(e, t, i, s, na) : na(e, t, i, s);
    }
  },
  "[?]": {
    alias: "optionalBracketAccess",
    check: ty,
    evaluate(e, t, n) {
      const r = t.args, i = e.eval(r[0], n), s = e.eval(r[1], n);
      return i instanceof Promise || s instanceof Promise ? Ba(e, t, i, s, ea) : ea(e, t, i, s);
    }
  },
  call: {
    check(e, t, n) {
      const [r, i] = t.args, s = t.functionCandidates ??= e.registry.getFunctionCandidates(
        !1,
        r,
        i.length
      ), o = i.map((c) => e.check(c, n)), a = s.findMatch(o);
      if (!a)
        throw new e.Error(
          `found no matching overload for '${r}(${e.formatTypeList(o)})'`,
          t
        );
      return o.some((c) => c.hasDyn()) || (t.staticHandler = a), a.returnType;
    },
    evaluate(e, t, n) {
      const r = fl(e, t.args[1], n);
      return r instanceof Promise ? r.then((i) => uy(e, t, i)) : uy(e, t, r);
    }
  },
  rcall: {
    check(e, t, n) {
      const [r, i, s] = t.args, o = e.check(i, n), a = t.functionCandidates ??= e.registry.getFunctionCandidates(
        !0,
        r,
        s.length
      ), c = s.map((l) => e.check(l, n));
      if (o.kind === "dyn" && a.returnType) return a.returnType;
      const u = a.findMatch(c, o);
      if (!u)
        throw new e.Error(
          `found no matching overload for '${o.type}.${r}(${e.formatTypeList(
            c
          )})'`,
          t
        );
      return !o.hasPlaceholder() && !c.some((l) => l.hasDyn()) && (t.staticHandler = u), u.returnType;
    },
    evaluate(e, t, n) {
      const r = e.eval(t.args[1], n), i = fl(e, t.args[2], n);
      return r instanceof Promise || i instanceof Promise ? Ba(e, t, r, i, ly) : ly(e, t, r, i);
    }
  },
  list: {
    check(e, t, n) {
      const r = t.args, i = r.length;
      if (i === 0) return e.getType("list<T>");
      let s = e.check(r[0], n);
      const o = e.opts.homogeneousAggregateLiterals ? ey : ny;
      for (let a = 1; a < i; a++) s = o(e, n, s, r[a], 0);
      return e.registry.getListType(s);
    },
    evaluate(e, t, n) {
      return fl(e, t.args, n);
    }
  },
  map: {
    check(e, t, n) {
      const r = t.args, i = r.length;
      if (i === 0) return e.getType("map<K, V>");
      const s = e.opts.homogeneousAggregateLiterals ? ey : ny;
      let o = e.check(r[0][0], n), a = e.check(r[0][1], n);
      for (let c = 1; c < i; c++) {
        const u = r[c];
        o = s(e, n, o, u[0], 1), a = s(e, n, a, u[1], 2);
      }
      return e.registry.getMapType(o, a);
    },
    evaluate(e, t, n) {
      const r = t.args, i = r.length, s = new Array(i);
      let o;
      for (let a = 0; a < i; a++) {
        const c = r[a], u = e.eval(c[0], n), l = e.eval(c[1], n);
        u instanceof Promise || l instanceof Promise ? (s[a] = Promise.all([u, l]), o ??= !0) : s[a] = [u, l];
      }
      return o ? Promise.all(s).then(fy) : fy(s);
    }
  },
  comprehension: {
    check(e, t, n) {
      const r = t.args;
      r.iterCtx = n.forkWithVariable(r.iterVarName, v2(e, r.iterable, n)).setAccuType(e.check(r.init, n));
      const i = e.check(r.step, r.iterCtx);
      return r.kind === "quantifier" ? e.boolType : i;
    },
    evaluate(e, t, n) {
      const r = t.args, i = e.eval(r.iterable, n);
      return i instanceof Promise ? i.then((s) => dy(e, r, n, s)) : dy(e, r, n, i);
    }
  },
  accuValue: {
    check(e, t, n) {
      return n.accuType;
    },
    evaluate(e, t, n) {
      return n.accuValue;
    }
  },
  accuInc: {
    check(e, t, n) {
      return n.accuType;
    },
    evaluate(e, t, n) {
      return n.accuValue += 1;
    }
  },
  accuPush: {
    check(e, t, n) {
      const r = n.accuType, i = e.check(t.args, n);
      return r.kind === "list" && r.valueType.kind !== "param" ? r : e.registry.getListType(i);
    },
    evaluate(e, t, n) {
      const r = n.accuValue, i = e.eval(t.args, n);
      return i instanceof Promise ? i.then((s) => r.push(s) && r) : (r.push(i), r);
    }
  },
  "?:": {
    alias: "ternary",
    check(e, t, n) {
      const [r, i, s] = t.args, o = e.check(r, n);
      if (!o.isDynOrBool())
        throw new e.Error(
          `${r.meta.label || "Ternary condition must be bool"}, got '${e.formatType(o)}'`,
          r
        );
      const a = e.check(i, n), c = e.check(s, n), u = a.unify(e.registry, c);
      if (u) return u;
      throw new e.Error(
        `Ternary branches must have the same type, got '${e.formatType(
          a
        )}' and '${e.formatType(c)}'`,
        t
      );
    },
    evaluate(e, t, n) {
      const r = e.eval(t.args[0], n);
      return r instanceof Promise ? r.then((i) => ry(e, t, n, i)) : ry(e, t, n, r);
    }
  },
  "||": {
    check: ay,
    evaluate(e, t, n) {
      const r = t.args, i = e.tryEval(r[0], n);
      if (i === !0) return !0;
      if (i === !1) {
        const s = e.eval(r[1], n);
        return typeof s == "boolean" ? s : Ii(!0, e, t, i, s);
      }
      return i instanceof Promise ? i.then(
        (s) => s === !0 ? s : Ii(!0, e, t, s, e.eval(r[1], n))
      ) : Ii(!0, e, t, i, e.eval(r[1], n));
    }
  },
  "&&": {
    check: ay,
    evaluate(e, t, n) {
      const r = t.args, i = e.tryEval(r[0], n);
      if (i === !1) return !1;
      if (i === !0) {
        const s = e.eval(r[1], n);
        return typeof s == "boolean" ? s : Ii(!1, e, t, i, s);
      }
      return i instanceof Promise ? i.then(
        (s) => s === !1 ? s : Ii(!1, e, t, s, e.eval(r[1], n))
      ) : Ii(!1, e, t, i, e.eval(r[1], n));
    }
  },
  "!_": { alias: "unaryNot", check: cy, evaluate: sy },
  "-_": { alias: "unaryMinus", check: cy, evaluate: sy }
}, A2 = ["!=", "==", "in", "+", "-", "*", "/", "%", "<", "<=", ">", ">="];
for (const e of A2) X[e] = { check: T2, evaluate: S2 };
for (const e of $n(X)) {
  const t = X[e];
  t.name = e, t.alias && (X[t.alias] = t);
}
const M = {
  EOF: 0,
  NUMBER: 1,
  STRING: 2,
  BOOLEAN: 3,
  NULL: 4,
  IDENTIFIER: 5,
  PLUS: 6,
  MINUS: 7,
  MULTIPLY: 8,
  DIVIDE: 9,
  MODULO: 10,
  EQ: 11,
  NE: 12,
  LT: 13,
  LE: 14,
  GT: 15,
  GE: 16,
  AND: 17,
  OR: 18,
  NOT: 19,
  IN: 20,
  LPAREN: 21,
  RPAREN: 22,
  LBRACKET: 23,
  RBRACKET: 24,
  LBRACE: 25,
  RBRACE: 26,
  DOT: 27,
  COMMA: 28,
  COLON: 29,
  QUESTION: 30,
  BYTES: 31
}, ra = {
  [M.EQ]: X["=="],
  [M.PLUS]: X["+"],
  [M.MINUS]: X["-"],
  [M.MULTIPLY]: X["*"],
  [M.DIVIDE]: X["/"],
  [M.MODULO]: X["%"],
  [M.LE]: X["<="],
  [M.LT]: X["<"],
  [M.GE]: X[">="],
  [M.GT]: X[">"],
  [M.NE]: X["!="],
  [M.IN]: X.in
}, Ca = {};
for (const e in M) Ca[M[e]] = e;
const rE = new Uint8Array(128);
for (const e of "0123456789abcdefABCDEF") rE[e.charCodeAt(0)] = 1;
const hy = {
  "\\": "\\",
  "?": "?",
  '"': '"',
  "'": "'",
  "`": "`",
  a: "\x07",
  b: "\b",
  f: "\f",
  n: `
`,
  r: "\r",
  t: "	",
  v: "\v"
};
class yu {
  #t;
  constructor(t, n, r, i) {
    this.#t = { input: t, pos: n, evaluate: r.evaluate, check: r.check }, this.op = r.name, this.args = i;
  }
  get meta() {
    return this.#t;
  }
  check(t, n, r) {
    const i = this.#t;
    return i.alternate ? t.check(i.alternate, r) : i.macro ? i.macro.typeCheck(t, i.macro, r) : i.check(t, n, r);
  }
  evaluate(t, n, r) {
    const i = this.#t;
    return i.alternate ? this.evaluate = this.#e : i.macro ? this.evaluate = this.#n : this.evaluate = i.evaluate, this.evaluate(t, n, r);
  }
  #e(t, n, r) {
    return (n = this.#t.alternate).evaluate(t, n, r);
  }
  #n(t, n, r) {
    return (n = this.#t.macro).evaluate(t, n, r);
  }
  setMeta(t, n) {
    return this.#t[t] = n, this;
  }
  get input() {
    return this.#t.input;
  }
  get pos() {
    return this.#t.pos;
  }
  toOldStructure() {
    const t = Array.isArray(this.args) ? this.args : [this.args];
    return [this.op, ...t.map((n) => n instanceof yu ? n.toOldStructure() : n)];
  }
}
class $2 {
  input;
  pos;
  length;
  tokenPos;
  tokenType;
  tokenValue;
  reset(t) {
    return this.pos = 0, this.input = t, this.length = t.length, t;
  }
  token(t, n, r) {
    return this.tokenPos = t, this.tokenType = n, this.tokenValue = r, this;
  }
  // Read next token
  nextToken() {
    for (; ; ) {
      const { pos: t, input: n, length: r } = this;
      if (t >= r) return this.token(t, M.EOF);
      const i = n[t];
      switch (i) {
        // Whitespaces
        case " ":
        case "	":
        case `
`:
        case "\r":
          this.pos++;
          continue;
        // Operators
        case "=":
          if (n[t + 1] !== "=") break;
          return this.token((this.pos += 2) - 2, M.EQ);
        case "&":
          if (n[t + 1] !== "&") break;
          return this.token((this.pos += 2) - 2, M.AND);
        case "|":
          if (n[t + 1] !== "|") break;
          return this.token((this.pos += 2) - 2, M.OR);
        case "+":
          return this.token(this.pos++, M.PLUS);
        case "-":
          return this.token(this.pos++, M.MINUS);
        case "*":
          return this.token(this.pos++, M.MULTIPLY);
        case "/":
          if (n[t + 1] === "/") {
            for (; this.pos < r && this.input[this.pos] !== `
`; ) this.pos++;
            continue;
          }
          return this.token(this.pos++, M.DIVIDE);
        case "%":
          return this.token(this.pos++, M.MODULO);
        case "<":
          return n[t + 1] === "=" ? this.token((this.pos += 2) - 2, M.LE) : this.token(this.pos++, M.LT);
        case ">":
          return n[t + 1] === "=" ? this.token((this.pos += 2) - 2, M.GE) : this.token(this.pos++, M.GT);
        case "!":
          return n[t + 1] === "=" ? this.token((this.pos += 2) - 2, M.NE) : this.token(this.pos++, M.NOT);
        case "(":
          return this.token(this.pos++, M.LPAREN);
        case ")":
          return this.token(this.pos++, M.RPAREN);
        case "[":
          return this.token(this.pos++, M.LBRACKET);
        case "]":
          return this.token(this.pos++, M.RBRACKET);
        case "{":
          return this.token(this.pos++, M.LBRACE);
        case "}":
          return this.token(this.pos++, M.RBRACE);
        case ".":
          return this.token(this.pos++, M.DOT);
        case ",":
          return this.token(this.pos++, M.COMMA);
        case ":":
          return this.token(this.pos++, M.COLON);
        case "?":
          return this.token(this.pos++, M.QUESTION);
        case '"':
        case "'":
          return this.readString(i);
        // Check for string prefixes (b, B, r, R followed by quote)
        case "b":
        case "B":
        case "r":
        case "R": {
          const s = n[t + 1];
          return s === '"' || s === "'" ? ++this.pos && this.readString(s, i) : this.readIdentifier();
        }
        default: {
          const s = i.charCodeAt(0);
          if (s <= 57 && s >= 48) return this.readNumber();
          if (this._isIdentifierCharCode(s)) return this.readIdentifier();
        }
      }
      throw new bt(`Unexpected character: ${i}`, { pos: t, input: n });
    }
  }
  // Characters: 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_
  _isIdentifierCharCode(t) {
    return t < 48 || t > 122 ? !1 : t >= 97 || t >= 65 && t <= 90 || t <= 57 || t === 95;
  }
  _parseAsDouble(t, n) {
    const r = Number(this.input.substring(t, n));
    if (Number.isFinite(r)) return this.token(t, M.NUMBER, r);
    throw new bt(`Invalid number: ${r}`, { pos: t, input: this.input });
  }
  _parseAsBigInt(t, n, r, i) {
    const s = this.input.substring(t, n);
    if (i === "u" || i === "U") {
      this.pos++;
      try {
        return this.token(t, M.NUMBER, new ti(s));
      } catch {
      }
    } else
      try {
        return this.token(t, M.NUMBER, BigInt(s));
      } catch {
      }
    throw new bt(r ? `Invalid hex integer: ${s}` : `Invalid integer: ${s}`, {
      pos: t,
      input: this.input
    });
  }
  _readDigits(t, n, r, i) {
    for (; r < n && (i = t.charCodeAt(r)) && !(i > 57 || i < 48); ) r++;
    return r;
  }
  _readExponent(t, n, r) {
    let i = r < n && t[r];
    if (i === "e" || i === "E") {
      i = ++r < n && t[r], (i === "-" || i === "+") && r++;
      const s = r;
      if (r = this._readDigits(t, n, r), s === r) throw new bt("Invalid exponent", { pos: r, input: t });
    }
    return r;
  }
  readNumber() {
    const { input: t, length: n, pos: r } = this;
    let i = r;
    if (t[i] === "0" && (t[i + 1] === "x" || t[i + 1] === "X")) {
      for (i += 2; i < n && rE[t[i].charCodeAt(0)]; ) i++;
      return this._parseAsBigInt(r, this.pos = i, !0, t[i]);
    }
    if (i = this._readDigits(t, n, i), i + 1 < n) {
      let s = !1, o = t[i] === "." ? this._readDigits(t, n, i + 1) : i + 1;
      if (o !== i + 1 && (s = !0) && (i = o), o = this._readExponent(t, n, i), o !== i && (s = !0) && (i = o), s) return this._parseAsDouble(r, this.pos = i);
    }
    return this._parseAsBigInt(r, this.pos = i, !1, t[i]);
  }
  readString(t, n) {
    const { input: r, pos: i } = this;
    return r[i + 1] === t && r[i + 2] === t ? this.readTripleQuotedString(t, n) : this.readSingleQuotedString(t, n);
  }
  _closeQuotedString(t, n, r) {
    switch (n) {
      case "b":
      case "B": {
        const i = this.processEscapes(t, !0), s = new Uint8Array(i.length);
        for (let o = 0; o < i.length; o++) s[o] = i.charCodeAt(o) & 255;
        return this.token(r - 1, M.BYTES, s);
      }
      case "r":
      case "R":
        return this.token(r - 1, M.STRING, t);
      default: {
        const i = this.processEscapes(t, !1);
        return this.token(r, M.STRING, i);
      }
    }
  }
  readSingleQuotedString(t, n) {
    const { input: r, length: i, pos: s } = this;
    let o, a = this.pos + 1;
    for (; a < i && (o = r[a]); ) {
      switch (o) {
        case t:
          const c = r.slice(s + 1, a);
          return this.pos = ++a, this._closeQuotedString(c, n, s);
        case `
`:
        case "\r":
          throw new bt("Newlines not allowed in single-quoted strings", { pos: s, input: r });
        case "\\":
          a++;
      }
      a++;
    }
    throw new bt("Unterminated string", { pos: s, input: r });
  }
  readTripleQuotedString(t, n) {
    const { input: r, length: i, pos: s } = this;
    let o, a = this.pos + 3;
    for (; a < i && (o = r[a]); ) {
      switch (o) {
        case t:
          if (r[a + 1] === t && r[a + 2] === t) {
            const c = r.slice(s + 3, a);
            return this.pos = a + 3, this._closeQuotedString(c, n, s);
          }
          break;
        case "\\":
          a++;
      }
      a++;
    }
    throw new bt("Unterminated triple-quoted string", { pos: s, input: r });
  }
  processEscapes(t, n) {
    if (!t.includes("\\")) return t;
    let r = "", i = 0;
    for (; i < t.length; ) {
      if (t[i] !== "\\" || i + 1 >= t.length) {
        r += t[i++];
        continue;
      }
      const s = t[i + 1];
      if (hy[s])
        r += hy[s], i += 2;
      else if (s === "u") {
        if (n) throw new bt("\\u not allowed in bytes literals");
        const o = t.substring(i + 2, i += 6);
        if (!/^[0-9a-fA-F]{4}$/.test(o)) throw new bt(`Invalid Unicode escape: \\u${o}`);
        const a = Number.parseInt(o, 16);
        if (a >= 55296 && a <= 57343) throw new bt(`Invalid Unicode surrogate: \\u${o}`);
        r += String.fromCharCode(a);
      } else if (s === "U") {
        if (n) throw new bt("\\U not allowed in bytes literals");
        const o = t.substring(i + 2, i += 10);
        if (!/^[0-9a-fA-F]{8}$/.test(o)) throw new bt(`Invalid Unicode escape: \\U${o}`);
        const a = Number.parseInt(o, 16);
        if (a > 1114111) throw new bt(`Invalid Unicode escape: \\U${o}`);
        if (a >= 55296 && a <= 57343) throw new bt(`Invalid Unicode surrogate: \\U${o}`);
        r += String.fromCodePoint(a);
      } else if (s === "x" || s === "X") {
        const o = t.substring(i + 2, i += 4);
        if (!/^[0-9a-fA-F]{2}$/.test(o)) throw new bt(`Invalid hex escape: \\${s}${o}`);
        r += String.fromCharCode(Number.parseInt(o, 16));
      } else if (s >= "0" && s <= "7") {
        const o = t.substring(i + 1, i += 4);
        if (!/^[0-7]{3}$/.test(o)) throw new bt("Octal escape must be 3 digits");
        const a = Number.parseInt(o, 8);
        if (a > 255) throw new bt(`Octal escape out of range: \\${o}`);
        r += String.fromCharCode(a);
      } else
        throw new bt(`Invalid escape sequence: \\${s}`);
    }
    return r;
  }
  readIdentifier() {
    const { pos: t, input: n, length: r } = this;
    let i = t;
    for (; i < r && this._isIdentifierCharCode(n[i].charCodeAt(0)); ) i++;
    const s = n.substring(t, this.pos = i);
    switch (s) {
      case "true":
        return this.token(t, M.BOOLEAN, !0);
      case "false":
        return this.token(t, M.BOOLEAN, !1);
      case "null":
        return this.token(t, M.NULL, null);
      case "in":
        return this.token(t, M.IN);
      default:
        return this.token(t, M.IDENTIFIER, s);
    }
  }
}
class I2 {
  lexer = null;
  input = null;
  maxDepthRemaining = null;
  astNodesRemaining = null;
  type = null;
  pos = null;
  constructor(t, n) {
    this.limits = t, this.registry = n, this.lexer = new $2();
  }
  #t(t, n = this.pos) {
    throw new bt(`Exceeded ${t} (${this.limits[t]})`, {
      pos: n,
      input: this.input
    });
  }
  #e(t, n, r) {
    const i = new yu(this.input, t, n, r);
    return this.astNodesRemaining-- || this.#t("maxAstNodes", t), i;
  }
  #n(t = this.pos) {
    const n = this.lexer.nextToken();
    return this.pos = n.tokenPos, this.type = n.tokenType, t;
  }
  // The value of the current token is accessed less regularly,
  // so we use a getter to reduce assignment overhead
  get value() {
    return this.lexer.tokenValue;
  }
  consume(t) {
    if (this.type === t) return this.#n();
    throw new bt(
      `Expected ${Ca[t]}, got ${Ca[this.type]}`,
      { pos: this.pos, input: this.input }
    );
  }
  match(t) {
    return this.type === t;
  }
  // Parse entry point
  parse(t) {
    if (typeof t != "string") throw new bt("Expression must be a string");
    this.input = this.lexer.reset(t), this.#n(), this.maxDepthRemaining = this.limits.maxDepth, this.astNodesRemaining = this.limits.maxAstNodes;
    const n = this.parseExpression();
    if (this.match(M.EOF)) return n;
    throw new bt(`Unexpected character: '${this.input[this.lexer.pos - 1]}'`, {
      pos: this.pos,
      input: this.input
    });
  }
  #r(t, n, r) {
    const [i, s, o] = n === X.rcall ? r : [r[0], null, r[1]], a = this.registry.findMacro(i, !!s, o.length), c = this.#e(t, n, r);
    if (!a) return c;
    const u = a.handler({ ast: c, args: o, receiver: s, methodName: i, parser: this });
    return u.callAst ? c.setMeta("alternate", u.callAst) : c.setMeta("macro", u), c;
  }
  // Expression ::= LogicalOr ('?' Expression ':' Expression)?
  parseExpression() {
    this.maxDepthRemaining-- || this.#t("maxDepth");
    const t = this.parseLogicalOr();
    if (!this.match(M.QUESTION)) return ++this.maxDepthRemaining && t;
    const n = this.#n(), r = this.parseExpression();
    this.consume(M.COLON);
    const i = this.parseExpression();
    return this.maxDepthRemaining++, this.#e(n, X.ternary, [t, r, i]);
  }
  // LogicalOr ::= LogicalAnd ('||' LogicalAnd)*
  parseLogicalOr() {
    let t = this.parseLogicalAnd();
    for (; this.match(M.OR); )
      t = this.#e(this.#n(), X["||"], [t, this.parseLogicalAnd()]);
    return t;
  }
  // LogicalAnd ::= Equality ('&&' Equality)*
  parseLogicalAnd() {
    let t = this.parseEquality();
    for (; this.match(M.AND); )
      t = this.#e(this.#n(), X["&&"], [t, this.parseEquality()]);
    return t;
  }
  // Equality ::= Relational (('==' | '!=') Relational)*
  parseEquality() {
    let t = this.parseRelational();
    for (; this.match(M.EQ) || this.match(M.NE); ) {
      const n = ra[this.type];
      t = this.#e(this.#n(), n, [t, this.parseRelational()]);
    }
    return t;
  }
  // Relational ::= Additive (('<' | '<=' | '>' | '>=' | 'in') Additive)*
  parseRelational() {
    let t = this.parseAdditive();
    for (; this.match(M.LT) || this.match(M.LE) || this.match(M.GT) || this.match(M.GE) || this.match(M.IN); ) {
      const n = ra[this.type];
      t = this.#e(this.#n(), n, [t, this.parseAdditive()]);
    }
    return t;
  }
  // Additive ::= Multiplicative (('+' | '-') Multiplicative)*
  parseAdditive() {
    let t = this.parseMultiplicative();
    for (; this.match(M.PLUS) || this.match(M.MINUS); ) {
      const n = ra[this.type];
      t = this.#e(this.#n(), n, [t, this.parseMultiplicative()]);
    }
    return t;
  }
  // Multiplicative ::= Unary (('*' | '/' | '%') Unary)*
  parseMultiplicative() {
    let t = this.parseUnary();
    for (; this.match(M.MULTIPLY) || this.match(M.DIVIDE) || this.match(M.MODULO); ) {
      const n = ra[this.type];
      t = this.#e(this.#n(), n, [t, this.parseUnary()]);
    }
    return t;
  }
  // Unary ::= ('!' | '-')* Postfix
  parseUnary() {
    return this.type === M.NOT ? this.#e(this.#n(), X.unaryNot, this.parseUnary()) : this.type === M.MINUS ? this.#e(this.#n(), X.unaryMinus, this.parseUnary()) : this.parsePostfix();
  }
  // Postfix ::= Primary (('.' IDENTIFIER ('(' ArgumentList ')')? | '[' Expression ']'))*
  parsePostfix() {
    let t = this.parsePrimary();
    const n = this.maxDepthRemaining;
    for (; ; ) {
      if (this.match(M.DOT)) {
        const r = this.#n();
        this.maxDepthRemaining-- || this.#t("maxDepth", r);
        const i = this.match(M.QUESTION) && this.registry.enableOptionalTypes && this.#n() ? X.optionalFieldAccess : X.fieldAccess, s = this.value, o = this.consume(M.IDENTIFIER);
        if (i === X.fieldAccess && this.match(M.LPAREN) && this.#n()) {
          const a = this.parseArgumentList();
          this.consume(M.RPAREN), t = this.#r(o, X.rcall, [s, t, a]);
        } else
          t = this.#e(o, i, [t, s]);
        continue;
      }
      if (this.match(M.LBRACKET)) {
        const r = this.#n();
        this.maxDepthRemaining-- || this.#t("maxDepth", r);
        const i = this.match(M.QUESTION) && this.registry.enableOptionalTypes && this.#n() ? X.optionalBracketAccess : X.bracketAccess, s = this.parseExpression();
        this.consume(M.RBRACKET), t = this.#e(r, i, [t, s]);
        continue;
      }
      break;
    }
    return this.maxDepthRemaining = n, t;
  }
  // Primary ::= NUMBER | STRING | BOOLEAN | NULL | IDENTIFIER | '(' Expression ')' | Array | Object
  parsePrimary() {
    switch (this.type) {
      case M.NUMBER:
      case M.STRING:
      case M.BYTES:
      case M.BOOLEAN:
      case M.NULL:
        return this.#i();
      case M.IDENTIFIER:
        return this.#o();
      case M.LPAREN:
        return this.#a();
      case M.LBRACKET:
        return this.parseList();
      case M.LBRACE:
        return this.parseMap();
    }
    throw new bt(`Unexpected token: ${Ca[this.type]}`, {
      pos: this.pos,
      input: this.input
    });
  }
  #i() {
    return this.#n(this.#e(this.pos, X.value, this.value));
  }
  #o() {
    const t = this.value, n = this.consume(M.IDENTIFIER);
    if (Oc.has(t))
      throw new bt(`Reserved identifier: ${t}`, {
        pos: n,
        input: this.input
      });
    if (!this.match(M.LPAREN)) return this.#e(n, X.id, t);
    this.#n();
    const r = this.parseArgumentList();
    return this.consume(M.RPAREN), this.#r(n, X.call, [t, r]);
  }
  #a() {
    this.consume(M.LPAREN);
    const t = this.parseExpression();
    return this.consume(M.RPAREN), t;
  }
  parseList() {
    const t = this.consume(M.LBRACKET), n = [];
    let r = this.limits.maxListElements;
    if (!this.match(M.RBRACKET))
      for (n.push(this.parseExpression()), r-- || this.#t("maxListElements", n.at(-1).pos); this.match(M.COMMA) && (this.#n(), !this.match(M.RBRACKET)); )
        n.push(this.parseExpression()), r-- || this.#t("maxListElements", n.at(-1).pos);
    return this.consume(M.RBRACKET), this.#e(t, X.list, n);
  }
  parseMap() {
    const t = this.consume(M.LBRACE), n = [];
    let r = this.limits.maxMapEntries;
    if (!this.match(M.RBRACE))
      for (n.push(this.parseProperty()), r-- || this.#t("maxMapEntries", n.at(-1)[0].pos); this.match(M.COMMA) && (this.#n(), !this.match(M.RBRACE)); )
        n.push(this.parseProperty()), r-- || this.#t("maxMapEntries", n.at(-1)[0].pos);
    return this.consume(M.RBRACE), this.#e(t, X.map, n);
  }
  parseProperty() {
    return [this.parseExpression(), (this.consume(M.COLON), this.parseExpression())];
  }
  parseArgumentList() {
    const t = [];
    let n = this.limits.maxCallArguments;
    if (!this.match(M.RPAREN))
      for (t.push(this.parseExpression()), n-- || this.#t("maxCallArguments", t.at(-1).pos); this.match(M.COMMA) && (this.#n(), !this.match(M.RPAREN)); )
        t.push(this.parseExpression()), n-- || this.#t("maxCallArguments", t.at(-1).pos);
    return t;
  }
}
const wu = (e) => e;
function mu(e, t) {
  if (e.op === "id") return e.args;
  throw new bt(t, e);
}
function St(e, t, n) {
  return new yu(e.input, e.pos, t, n);
}
function py(e) {
  const t = e ? "map(var, filter, transform)" : "map(var, transform)", n = `${t} invalid predicate iteration variable`, r = `${t} filter predicate must return bool`;
  return ({ args: i, receiver: s, ast: o }) => {
    const [a, c, u] = e ? i : [i[0], null, i[1]];
    let l = St(u, X.accuPush, u);
    if (c) {
      const f = St(c, X.accuValue);
      l = St(c, X.ternary, [c.setMeta("label", r), l, f]);
    }
    return {
      callAst: St(o, X.comprehension, {
        errorsAreFatal: !0,
        iterable: s,
        iterVarName: mu(a, n),
        init: St(o, X.list, []),
        step: l,
        result: wu
      })
    };
  };
}
function O2() {
  const e = "filter(var, predicate)", t = `${e} invalid predicate iteration variable`, n = `${e} predicate must return bool`;
  return ({ args: r, receiver: i, ast: s }) => {
    const o = mu(r[0], t), a = St(s, X.accuValue), c = r[1].setMeta("label", n), u = St(s, X.accuPush, St(s, X.id, o)), l = St(c, X.ternary, [c, u, a]);
    return {
      callAst: St(s, X.comprehension, {
        errorsAreFatal: !0,
        iterable: i,
        iterVarName: o,
        init: St(s, X.list, []),
        step: l,
        result: wu
      })
    };
  };
}
function dl(e) {
  const t = `${e.name}(var, predicate) invalid predicate iteration variable`, n = `${e.name}(var, predicate) predicate must return bool`;
  return ({ args: r, receiver: i, ast: s }) => {
    const o = r[1].setMeta("label", n), a = e.transform({ args: r, ast: s, predicate: o, opts: e });
    return {
      callAst: St(s, X.comprehension, {
        kind: "quantifier",
        errorsAreFatal: e.errorsAreFatal || !1,
        iterable: i,
        iterVarName: mu(r[0], t),
        init: a.init,
        condition: a.condition,
        step: a.step,
        result: a.result || wu
      })
    };
  };
}
function B2() {
  const e = "has() invalid argument";
  function t(r, i, s) {
    const o = i.macroHasProps;
    let a = o.length, c = r.eval(o[--a], s), u;
    for (; a--; ) {
      const l = o[a];
      if (l.op === ".?" && (u ??= !0), c = r.debugType(c).fieldLazy(c, l.args[1], l, r), c === void 0) {
        if (!(!u && a && l.op === ".")) break;
        throw new tt(`No such key: ${l.args[1]}`, l);
      }
    }
    return c !== void 0;
  }
  function n(r, i, s) {
    let o = i.args[0];
    if (o.op !== ".") throw new r.Error(e, o);
    if (!i.macroHasProps) {
      const a = [];
      for (; o.op === "." || o.op === ".?"; ) o = a.push(o) && o.args[0];
      if (o.op !== "id") throw new r.Error(e, o);
      r.check(o, s), a.push(o), i.macroHasProps = a;
    }
    return r.getType("bool");
  }
  return function({ args: r }) {
    return { args: r, evaluate: t, typeCheck: n };
  };
}
function C2(e) {
  e.registerFunctionOverload("has(ast): bool", B2()), e.registerFunctionOverload(
    "list.all(ast, ast): bool",
    dl({
      name: "all",
      transform({ ast: o, predicate: a, opts: c }) {
        return {
          init: St(o, X.value, !0),
          condition: wu,
          step: St(a, X.ternary, [
            a,
            St(a, X.value, !0),
            St(a, X.value, !1)
          ])
        };
      }
    })
  ), e.registerFunctionOverload(
    "list.exists(ast, ast): bool",
    dl({
      name: "exists",
      condition(o) {
        return !o;
      },
      transform({ ast: o, predicate: a, opts: c }) {
        return {
          init: St(o, X.value, !1),
          condition: c.condition,
          step: St(a, X.ternary, [
            a,
            St(a, X.value, !0),
            St(a, X.value, !1)
          ])
        };
      }
    })
  ), e.registerFunctionOverload(
    "list.exists_one(ast, ast): bool",
    dl({
      name: "exists_one",
      errorsAreFatal: !0,
      result(o) {
        return o === 1;
      },
      transform({ ast: o, predicate: a, opts: c }) {
        const u = St(o, X.accuValue);
        return {
          init: St(o, X.value, 0),
          step: St(a, X.ternary, [a, St(o, X.accuInc), u]),
          result: c.result
        };
      }
    })
  ), e.registerFunctionOverload("list.map(ast, ast): list<dyn>", py(!1)), e.registerFunctionOverload("list.map(ast, ast, ast): list<dyn>", py(!0)), e.registerFunctionOverload("list.filter(ast, ast): list<dyn>", O2());
  function t(o, a, c, u) {
    const l = o.eval(a.exp, c = a.bindCtx.reuse(c).setIterValue(u));
    return l instanceof Promise && c === a.bindCtx && (c.async = !0), l;
  }
  class n {
  }
  const r = new n();
  e.registerType("CelNamespace", n), e.registerConstant("cel", "CelNamespace", r);
  function i(o, a, c) {
    return a.bindCtx = c.forkWithVariable(a.var, o.check(a.val, c)), o.check(a.exp, a.bindCtx);
  }
  function s(o, a, c) {
    const u = o.eval(a.val, c);
    return u instanceof Promise ? u.then((l) => t(o, a, c, l)) : t(o, a, c, u);
  }
  e.registerFunctionOverload("CelNamespace.bind(ast, dyn, ast): dyn", ({ args: o }) => ({
    var: mu(o[0], "invalid variable argument"),
    val: o[1],
    exp: o[2],
    bindCtx: void 0,
    typeCheck: i,
    evaluate: s
  }));
}
function R2(e) {
  const t = e.unaryOverload.bind(e), n = e.binaryOverload.bind(e);
  function r(u, l) {
    if (u <= 9223372036854775807n && u >= -9223372036854775808n) return u;
    throw new tt(`integer overflow: ${u}`, l);
  }
  t("!", "bool", (u) => !u), t("-", "int", (u) => -u), n("dyn<int>", "==", "double", (u, l) => u == l), n("dyn<int>", "==", "uint", (u, l) => u == l.valueOf()), n("int", "*", "int", (u, l, f) => r(u * l, f)), n("int", "+", "int", (u, l, f) => r(u + l, f)), n("int", "-", "int", (u, l, f) => r(u - l, f)), n("int", "/", "int", (u, l, f) => {
    if (l === 0n) throw new tt("division by zero", f);
    return u / l;
  }), n("int", "%", "int", (u, l, f) => {
    if (l === 0n) throw new tt("modulo by zero", f);
    return u % l;
  }), t("-", "double", (u) => -u), n("dyn<double>", "==", "int", (u, l) => u == l), n("dyn<double>", "==", "uint", (u, l) => u == l.valueOf()), n("double", "*", "double", (u, l) => u * l), n("double", "+", "double", (u, l) => u + l), n("double", "-", "double", (u, l) => u - l), n("double", "/", "double", (u, l) => u / l), n("string", "+", "string", (u, l) => u + l), n("list<V>", "+", "list<V>", (u, l) => [...u, ...l]), n("bytes", "+", "bytes", (u, l) => {
    if (!u.length) return l;
    if (!l.length) return u;
    const f = new Uint8Array(u.length + l.length);
    return f.set(u, 0), f.set(l, u.length), f;
  });
  const i = "google.protobuf.Duration";
  n(i, "+", i, (u, l) => u.addDuration(l)), n(i, "-", i, (u, l) => u.subtractDuration(l)), n(i, "==", i, (u, l) => u.seconds === l.seconds && u.nanos === l.nanos);
  const s = "google.protobuf.Timestamp";
  n(s, "==", s, (u, l) => u.getTime() === l.getTime()), n(s, "-", s, (u, l) => Ir.fromMilliseconds(u.getTime() - l.getTime()), i), n(s, "-", i, (u, l) => l.subtractTimestamp(u)), n(s, "+", i, (u, l) => l.extendTimestamp(u)), n(i, "+", s, (u, l) => u.extendTimestamp(l));
  function o(u, l, f, h) {
    if (l instanceof Set && l.has(u)) return !0;
    for (const g of l) if (_s(u, g, f, h)) return !0;
    return !1;
  }
  function a(u, l) {
    return l instanceof Map ? l.get(u) !== void 0 : Of(l, u) ? l[u] !== void 0 : !1;
  }
  function c(u, l, f, h) {
    return o(u, l, f, h);
  }
  n("V", "in", "list<V>", c), n("K", "in", "map<K, V>", a);
  for (const u of ["type", "null", "bool", "string", "int", "double"])
    n(u, "==", u, (l, f) => l === f);
  n("bytes", "==", "bytes", (u, l) => {
    if (u === l) return !0;
    let f = u.length;
    if (f !== l.length) return !1;
    for (; f--; ) if (u[f] !== l[f]) return !1;
    return !0;
  }), n("list<V>", "==", "list<V>", (u, l, f, h) => {
    if (u === l) return !0;
    if (Ia(u) && Ia(l)) {
      const p = u.length;
      if (p !== l.length) return !1;
      for (let y = 0; y < p; y++)
        if (!_s(u[y], l[y], f, h)) return !1;
      return !0;
    }
    if (u instanceof Set && l instanceof Set) {
      if (u.size !== l.size) return !1;
      for (const p of u) if (!l.has(p)) return !1;
      return !0;
    }
    const g = u instanceof Set ? l : u, d = u instanceof Set ? u : l;
    if (!Ia(g) || g.length !== d?.size) return !1;
    for (let p = 0; p < g.length; p++) if (!d.has(g[p])) return !1;
    return !0;
  }), n("map<K, V>", "==", "map<K, V>", (u, l, f, h) => {
    if (u === l) return !0;
    if (u instanceof Map && l instanceof Map) {
      if (u.size !== l.size) return !1;
      for (const [p, y] of u)
        if (!(l.has(p) && _s(y, l.get(p), f, h))) return !1;
      return !0;
    }
    if (u instanceof Map || l instanceof Map) {
      const p = u instanceof Map ? l : u, y = u instanceof Map ? u : l, x = $n(p);
      if (y.size !== x.length) return !1;
      for (const [S, A] of y)
        if (!(S in p && _s(A, p[S], f, h))) return !1;
      return !0;
    }
    const g = $n(u), d = $n(l);
    if (g.length !== d.length) return !1;
    for (let p = 0; p < g.length; p++) {
      const y = g[p];
      if (!(y in l && _s(u[y], l[y], f, h))) return !1;
    }
    return !0;
  }), n("uint", "==", "uint", (u, l) => u.valueOf() === l.valueOf()), n("dyn<uint>", "==", "double", (u, l) => u.valueOf() == l), n("dyn<uint>", "==", "int", (u, l) => u.valueOf() == l), n("uint", "+", "uint", (u, l) => new ti(u.valueOf() + l.valueOf())), n("uint", "-", "uint", (u, l) => new ti(u.valueOf() - l.valueOf())), n("uint", "*", "uint", (u, l) => new ti(u.valueOf() * l.valueOf())), n("uint", "/", "uint", (u, l, f) => {
    if (l.valueOf() === 0n) throw new tt("division by zero", f);
    return new ti(u.valueOf() / l.valueOf());
  }), n("uint", "%", "uint", (u, l, f) => {
    if (l.valueOf() === 0n) throw new tt("modulo by zero", f);
    return new ti(u.valueOf() % l.valueOf());
  });
  for (const [u, l] of [
    ["bool", "bool"],
    ["int", "int"],
    ["uint", "uint"],
    ["double", "double"],
    ["string", "string"],
    ["google.protobuf.Timestamp", "google.protobuf.Timestamp"],
    ["google.protobuf.Duration", "google.protobuf.Duration"],
    ["int", "uint"],
    ["int", "double"],
    ["double", "int"],
    ["double", "uint"],
    ["uint", "int"],
    ["uint", "double"]
  ])
    n(u, "<", l, (f, h) => f < h), n(u, "<=", l, (f, h) => f <= h), n(u, ">", l, (f, h) => f > h), n(u, ">=", l, (f, h) => f >= h);
}
function _s(e, t, n, r) {
  if (e === t) return !0;
  switch (typeof e) {
    case "string":
      return !1;
    case "bigint":
      return typeof t == "number" ? e == t : !1;
    case "number":
      return typeof t == "bigint" ? e == t : !1;
    case "boolean":
      return !1;
    case "object":
      if (typeof t != "object" || e === null || t === null) return !1;
      const i = r.objectTypesByConstructor.get(e.constructor)?.type, s = r.objectTypesByConstructor.get(t.constructor)?.type;
      if (!i || i !== s) return !1;
      const o = r.registry.findBinaryOverload("==", i, s);
      return o ? o.handler(e, t, n, r) : !1;
  }
  throw new tt(`Cannot compare values of type ${typeof e}`, n);
}
const P2 = (/* @__PURE__ */ new Map()).set("A", "dyn").set("T", "dyn").set("K", "dyn").set("V", "dyn");
class gy extends X0 {
  constructor(t, n) {
    super(t), this.isEvaluating = n, this.Error = n ? tt : e2;
  }
  /**
   * Check an expression and return its inferred type
   * @param {Array|any} ast - The AST node to check
   * @returns {Object} The inferred type declaration
   * @throws {TypeError} If type checking fails
   */
  check(t, n) {
    return t.checkedType ??= t.check(this, t, n);
  }
  checkAccessOnType(t, n, r, i = !1) {
    if (r.kind === "dyn") return r;
    const s = (t.op === "[]" || t.op === "[?]" ? this.check(t.args[1], n) : this.stringType).type;
    if (r.kind === "list") {
      if (s !== "int" && s !== "dyn")
        throw new this.Error(`List index must be int, got '${s}'`, t);
      return r.valueType;
    }
    if (r.kind === "map") return r.valueType;
    const o = this.objectTypes.get(r.name);
    if (o) {
      if (!(s === "string" || s === "dyn"))
        throw new this.Error(
          `Cannot index type '${r.name}' with type '${s}'`,
          t
        );
      if (o.fields) {
        const a = t.op === "." || t.op === ".?" ? t.args[1] : void 0;
        if (a) {
          const c = o.fields[a];
          if (c) return c;
          if (i) return this.dynType;
          throw new this.Error(`No such key: ${a}`, t);
        }
      }
      return this.dynType;
    }
    throw new this.Error(`Cannot index type '${this.formatType(r)}'`, t);
  }
  formatType(t) {
    return t.hasPlaceholder() ? t.templated(this.registry, P2).name : t.name;
  }
  formatTypeList(t) {
    return t.map((n) => this.formatType(n)).join(", ");
  }
}
const oh = jr({
  maxAstNodes: 1e5,
  maxDepth: 250,
  maxListElements: 1e3,
  maxMapEntries: 1e3,
  maxCallArguments: 32
}), N2 = new Set($n(oh));
function L2(e, t = oh) {
  const n = e ? $n(e) : void 0;
  if (!n?.length) return t;
  const r = { ...t };
  for (const i of n) {
    if (!N2.has(i)) throw new TypeError(`Unknown limits option: ${i}`);
    const s = e[i];
    typeof s == "number" && (r[i] = s);
  }
  return jr(r);
}
const U2 = jr({
  unlistedVariablesAreDyn: !1,
  homogeneousAggregateLiterals: !0,
  enableOptionalTypes: !1,
  limits: oh
});
function hl(e, t, n) {
  const r = e?.[n] ?? t?.[n];
  if (typeof r != "boolean") throw new TypeError(`Invalid option: ${n}`);
  return r;
}
function _2(e, t = U2) {
  return e ? jr({
    unlistedVariablesAreDyn: hl(e, t, "unlistedVariablesAreDyn"),
    homogeneousAggregateLiterals: hl(e, t, "homogeneousAggregateLiterals"),
    enableOptionalTypes: hl(e, t, "enableOptionalTypes"),
    limits: L2(e.limits, t.limits)
  }) : t;
}
const bu = m2({ enableOptionalTypes: !1 });
o2(bu);
R2(bu);
C2(bu);
const yy = /* @__PURE__ */ new WeakMap();
class Ti {
  #t;
  #e;
  #n;
  #r;
  #i;
  constructor(t, n) {
    this.opts = _2(t, n?.opts), this.#t = (n instanceof Ti ? yy.get(n) : bu).clone(this.opts);
    const r = {
      objectTypes: this.#t.objectTypes,
      objectTypesByConstructor: this.#t.objectTypesByConstructor,
      registry: this.#t,
      opts: this.opts
    };
    this.#n = new gy(r), this.#r = new gy(r, !0), this.#e = new D2(r), this.#i = new I2(this.opts.limits, this.#t), yy.set(this, this.#t), Object.freeze(this);
  }
  clone(t) {
    return new Ti(t, this);
  }
  registerFunction(t, n) {
    return this.#t.registerFunctionOverload(t, n), this;
  }
  registerOperator(t, n) {
    return this.#t.registerOperatorOverload(t, n), this;
  }
  registerType(t, n) {
    return this.#t.registerType(t, n), this;
  }
  registerVariable(t, n) {
    return this.#t.registerVariable(t, n), this;
  }
  registerConstant(t, n, r) {
    return this.#t.registerConstant(t, n, r), this;
  }
  hasVariable(t) {
    return this.#t.variables.has(t);
  }
  check(t) {
    try {
      return this.#o(this.#i.parse(t));
    } catch (n) {
      return { valid: !1, error: n };
    }
  }
  #o(t) {
    try {
      const n = this.#n.check(t, new Xg(this.#t));
      return { valid: !0, type: this.#a(n) };
    } catch (n) {
      return { valid: !1, error: n };
    }
  }
  #a(t) {
    return t.name === "list<dyn>" ? "list" : t.name === "map<dyn, dyn>" ? "map" : t.name;
  }
  parse(t) {
    const n = this.#i.parse(t), r = this.#c.bind(this, n);
    return r.check = this.#o.bind(this, n), r.ast = n, r;
  }
  evaluate(t, n) {
    return this.#c(this.#i.parse(t), n);
  }
  #c(t, n) {
    return n = new Xg(this.#t, n), t.checkedType || this.#r.check(t, n), this.#e.eval(t, n);
  }
}
class D2 extends X0 {
  constructor(t) {
    super(t), this.Error = tt;
  }
  #t(t, n) {
    const r = t instanceof Array ? t[0] : t.values().next().value;
    return r === void 0 ? n : this.registry.getListType(this.debugRuntimeType(r, n.valueType));
  }
  #e(t) {
    if (t instanceof Map) return t.entries().next().value;
    for (const n in t) return [n, t[n]];
  }
  #n(t, n) {
    const r = this.#e(t);
    return r ? this.registry.getMapType(
      this.debugRuntimeType(r[0], n.keyType),
      this.debugRuntimeType(r[1], n.valueType)
    ) : n;
  }
  debugOperandType(t, n) {
    return n?.hasNoDynTypes() ? n : this.debugRuntimeType(t, n).wrappedType;
  }
  debugRuntimeType(t, n) {
    if (n?.hasNoDynTypes()) return n;
    const r = this.debugType(t);
    switch (r.kind) {
      case "list":
        return this.#t(t, r);
      case "map":
        return this.#n(t, r);
      default:
        return r;
    }
  }
  tryEval(t, n) {
    try {
      const r = this.eval(t, n);
      return r instanceof Promise ? r.catch((i) => i) : r;
    } catch (r) {
      return r;
    }
  }
  eval(t, n) {
    return t.evaluate(this, t, n);
  }
}
new Ti({
  unlistedVariablesAreDyn: !0
});
const ah = "amount", V2 = "expiry", M2 = "birth", F2 = "weight", H2 = "inputType", W2 = "script", ys = {
  signature: "now(): double",
  implementation: () => Math.floor(Date.now() / 1e3)
}, wy = new Ti().registerVariable(ah, "double").registerVariable(W2, "string").registerFunction(ys.signature, ys.implementation), K2 = new Ti().registerVariable(ah, "double").registerVariable(V2, "double").registerVariable(M2, "double").registerVariable(F2, "double").registerVariable(H2, "string").registerFunction(ys.signature, ys.implementation), j2 = new Ti().registerVariable(ah, "double").registerFunction(ys.signature, ys.implementation);
class pe {
  constructor(t) {
    this.value = t;
  }
  get satoshis() {
    return this.value ? Math.ceil(this.value) : 0;
  }
  add(t) {
    return new pe(this.value + t.value);
  }
}
pe.ZERO = new pe(0);
class z2 {
  /**
   * Creates a new Estimator with the given config
   * @param config - Configuration containing CEL programs for fee calculation
   */
  constructor(t) {
    this.config = t, this.intentOffchainInput = t.offchainInput ? ia(t.offchainInput, K2) : void 0, this.intentOnchainInput = t.onchainInput ? ia(t.onchainInput, j2) : void 0, this.intentOffchainOutput = t.offchainOutput ? ia(t.offchainOutput, wy) : void 0, this.intentOnchainOutput = t.onchainOutput ? ia(t.onchainOutput, wy) : void 0;
  }
  /**
   * Evaluates the fee for a given vtxo input
   * @param input - The offchain input to evaluate
   * @returns The fee amount for this input
   */
  evalOffchainInput(t) {
    if (!this.intentOffchainInput)
      return pe.ZERO;
    const n = q2(t);
    return new pe(this.intentOffchainInput.program(n));
  }
  /**
   * Evaluates the fee for a given boarding input
   * @param input - The onchain input to evaluate
   * @returns The fee amount for this input
   */
  evalOnchainInput(t) {
    if (!this.intentOnchainInput)
      return pe.ZERO;
    const n = {
      amount: Number(t.amount)
    };
    return new pe(this.intentOnchainInput.program(n));
  }
  /**
   * Evaluates the fee for a given vtxo output
   * @param output - The output to evaluate
   * @returns The fee amount for this output
   */
  evalOffchainOutput(t) {
    if (!this.intentOffchainOutput)
      return pe.ZERO;
    const n = my(t);
    return new pe(this.intentOffchainOutput.program(n));
  }
  /**
   * Evaluates the fee for a given collaborative exit output
   * @param output - The output to evaluate
   * @returns The fee amount for this output
   */
  evalOnchainOutput(t) {
    if (!this.intentOnchainOutput)
      return pe.ZERO;
    const n = my(t);
    return new pe(this.intentOnchainOutput.program(n));
  }
  /**
   * Evaluates the fee for a given set of inputs and outputs
   * @param offchainInputs - Array of offchain inputs to evaluate
   * @param onchainInputs - Array of onchain inputs to evaluate
   * @param offchainOutputs - Array of offchain outputs to evaluate
   * @param onchainOutputs - Array of onchain outputs to evaluate
   * @returns The total fee amount
   */
  eval(t, n, r, i) {
    let s = pe.ZERO;
    for (const o of t)
      s = s.add(this.evalOffchainInput(o));
    for (const o of n)
      s = s.add(this.evalOnchainInput(o));
    for (const o of r)
      s = s.add(this.evalOffchainOutput(o));
    for (const o of i)
      s = s.add(this.evalOnchainOutput(o));
    return s;
  }
}
function q2(e) {
  const t = {
    amount: Number(e.amount),
    inputType: e.type,
    weight: e.weight
  };
  return e.expiry && (t.expiry = Math.floor(e.expiry.getTime() / 1e3)), e.birth && (t.birth = Math.floor(e.birth.getTime() / 1e3)), t;
}
function my(e) {
  return {
    amount: Number(e.amount),
    script: e.script
  };
}
function ia(e, t) {
  const n = t.parse(e), r = n.check();
  if (!r.valid)
    throw new Error(`type check failed: ${r.error?.message ?? "unknown error"}`);
  if (r.type !== "double")
    throw new Error(`expected return type double, got ${r.type}`);
  return { program: n, text: e };
}
const Ds = {
  commitmentTxid: "",
  boardingTxid: "",
  arkTxid: ""
};
async function G2(e, t, n, r) {
  const i = [...e].sort((u, l) => u.createdAt.getTime() - l.createdAt.getTime()), s = [];
  let o = [];
  for (const u of i)
    if (u.status.isLeaf ? !n.has(u.virtualStatus.commitmentTxIds[0]) && i.filter((l) => l.settledBy === u.virtualStatus.commitmentTxIds[0]).length === 0 && o.push({
      key: {
        ...Ds,
        commitmentTxid: u.virtualStatus.commitmentTxIds[0]
      },
      tag: "batch",
      type: Mn.TxReceived,
      amount: u.value,
      settled: u.status.isLeaf || u.isSpent,
      createdAt: u.createdAt.getTime()
    }) : i.filter((l) => l.arkTxId === u.txid).length === 0 && o.push({
      key: { ...Ds, arkTxid: u.txid },
      tag: "offchain",
      type: Mn.TxReceived,
      amount: u.value,
      settled: u.status.isLeaf || u.isSpent,
      createdAt: u.createdAt.getTime()
    }), u.isSpent) {
      if (u.arkTxId && !s.some((l) => l.key.arkTxid === u.arkTxId)) {
        const l = i.filter((p) => p.txid === u.arkTxId), h = i.filter((p) => p.arkTxId === u.arkTxId).reduce((p, y) => p + y.value, 0);
        let g = 0, d = 0;
        if (l.length > 0) {
          const p = l.reduce((y, x) => y + x.value, 0);
          g = h - p, d = l[0].createdAt.getTime();
        } else
          g = h, d = r ? await r(u.arkTxId) : u.createdAt.getTime() + 1;
        s.push({
          key: { ...Ds, arkTxid: u.arkTxId },
          tag: "offchain",
          type: Mn.TxSent,
          amount: g,
          settled: !0,
          createdAt: d
        });
      }
      if (u.settledBy && !n.has(u.settledBy) && !s.some((l) => l.key.commitmentTxid === u.settledBy)) {
        const l = i.filter((g) => g.status.isLeaf && g.virtualStatus.commitmentTxIds?.every((d) => u.settledBy === d)), h = i.filter((g) => g.settledBy === u.settledBy).reduce((g, d) => g + d.value, 0);
        if (l.length > 0) {
          const g = l.reduce((d, p) => d + p.value, 0);
          h > g && s.push({
            key: { ...Ds, commitmentTxid: u.settledBy },
            tag: "exit",
            type: Mn.TxSent,
            amount: h - g,
            settled: !0,
            createdAt: l[0].createdAt.getTime()
          });
        } else
          s.push({
            key: { ...Ds, commitmentTxid: u.settledBy },
            tag: "exit",
            type: Mn.TxSent,
            amount: h,
            settled: !0,
            // TODO: fetch commitment tx with /v1/indexer/commitmentTx/<commitmentTxid> to know when the tx was made
            createdAt: u.createdAt.getTime() + 1
          });
      }
    }
  return [...t.map((u) => ({ ...u, tag: "boarding" })), ...s, ...o].sort((u, l) => l.createdAt - u.createdAt);
}
const wn = "vtxos", mn = "utxos", bn = "transactions", wr = "walletState", Me = "contracts", by = "contractsCollections", iE = 2;
function sE(e) {
  if (!e.objectStoreNames.contains(wn)) {
    const t = e.createObjectStore(wn, {
      keyPath: ["address", "txid", "vout"]
    });
    t.indexNames.contains("address") || t.createIndex("address", "address", {
      unique: !1
    }), t.indexNames.contains("txid") || t.createIndex("txid", "txid", { unique: !1 }), t.indexNames.contains("value") || t.createIndex("value", "value", { unique: !1 }), t.indexNames.contains("status") || t.createIndex("status", "status", {
      unique: !1
    }), t.indexNames.contains("virtualStatus") || t.createIndex("virtualStatus", "virtualStatus", {
      unique: !1
    }), t.indexNames.contains("createdAt") || t.createIndex("createdAt", "createdAt", {
      unique: !1
    }), t.indexNames.contains("isSpent") || t.createIndex("isSpent", "isSpent", {
      unique: !1
    }), t.indexNames.contains("isUnrolled") || t.createIndex("isUnrolled", "isUnrolled", {
      unique: !1
    }), t.indexNames.contains("spentBy") || t.createIndex("spentBy", "spentBy", {
      unique: !1
    }), t.indexNames.contains("settledBy") || t.createIndex("settledBy", "settledBy", {
      unique: !1
    }), t.indexNames.contains("arkTxId") || t.createIndex("arkTxId", "arkTxId", {
      unique: !1
    });
  }
  if (!e.objectStoreNames.contains(mn)) {
    const t = e.createObjectStore(mn, {
      keyPath: ["address", "txid", "vout"]
    });
    t.indexNames.contains("address") || t.createIndex("address", "address", {
      unique: !1
    }), t.indexNames.contains("txid") || t.createIndex("txid", "txid", { unique: !1 }), t.indexNames.contains("value") || t.createIndex("value", "value", { unique: !1 }), t.indexNames.contains("status") || t.createIndex("status", "status", {
      unique: !1
    });
  }
  if (!e.objectStoreNames.contains(bn)) {
    const t = e.createObjectStore(bn, {
      keyPath: [
        "address",
        "keyBoardingTxid",
        "keyCommitmentTxid",
        "keyArkTxid"
      ]
    });
    t.indexNames.contains("address") || t.createIndex("address", "address", {
      unique: !1
    }), t.indexNames.contains("type") || t.createIndex("type", "type", {
      unique: !1
    }), t.indexNames.contains("amount") || t.createIndex("amount", "amount", {
      unique: !1
    }), t.indexNames.contains("settled") || t.createIndex("settled", "settled", {
      unique: !1
    }), t.indexNames.contains("createdAt") || t.createIndex("createdAt", "createdAt", {
      unique: !1
    }), t.indexNames.contains("arkTxid") || t.createIndex("arkTxid", "key.arkTxid", {
      unique: !1
    });
  }
  if (e.objectStoreNames.contains(wr) || e.createObjectStore(wr, {
    keyPath: "key"
  }), !e.objectStoreNames.contains(Me)) {
    const t = e.createObjectStore(Me, {
      keyPath: "script"
    });
    t.indexNames.contains("type") || t.createIndex("type", "type", {
      unique: !1
    }), t.indexNames.contains("state") || t.createIndex("state", "state", {
      unique: !1
    });
  }
  e.objectStoreNames.contains(by) || e.createObjectStore(by, {
    keyPath: "key"
  });
}
const Cc = ([e, t]) => ({
  cb: C.encode(Tn.encode(e)),
  s: C.encode(t)
}), Y2 = (e) => ({
  ...e,
  tapTree: C.encode(e.tapTree),
  forfeitTapLeafScript: Cc(e.forfeitTapLeafScript),
  intentTapLeafScript: Cc(e.intentTapLeafScript),
  extraWitness: e.extraWitness?.map(C.encode)
}), Z2 = (e) => ({
  ...e,
  tapTree: C.encode(e.tapTree),
  forfeitTapLeafScript: Cc(e.forfeitTapLeafScript),
  intentTapLeafScript: Cc(e.intentTapLeafScript),
  extraWitness: e.extraWitness?.map(C.encode)
}), Rc = (e) => {
  const t = Tn.decode(C.decode(e.cb)), n = C.decode(e.s);
  return [t, n];
}, X2 = (e) => ({
  ...e,
  createdAt: new Date(e.createdAt),
  tapTree: C.decode(e.tapTree),
  forfeitTapLeafScript: Rc(e.forfeitTapLeafScript),
  intentTapLeafScript: Rc(e.intentTapLeafScript),
  extraWitness: e.extraWitness?.map(C.decode)
}), Q2 = (e) => ({
  ...e,
  tapTree: C.decode(e.tapTree),
  forfeitTapLeafScript: Rc(e.forfeitTapLeafScript),
  intentTapLeafScript: Rc(e.intentTapLeafScript),
  extraWitness: e.extraWitness?.map(C.decode)
});
function J2() {
  if (typeof globalThis < "u")
    return typeof globalThis.self == "object" && globalThis.self !== null ? { globalObject: globalThis.self } : typeof globalThis.window == "object" && globalThis.window !== null ? { globalObject: globalThis.window } : { globalObject: globalThis };
  throw new Error("Global object not found");
}
const to = /* @__PURE__ */ new Map(), fi = /* @__PURE__ */ new Map();
async function oE(e, t, n) {
  const { globalObject: r } = J2();
  if (!r.indexedDB)
    throw new Error("IndexedDB is not available in this environment");
  const i = to.get(e);
  if (i) {
    if (i.version !== t)
      throw new Error(`Database "${e}" already opened with version ${i.version}; requested ${t}`);
    return fi.set(e, (fi.get(e) ?? 0) + 1), i.promise;
  }
  const s = new Promise((o, a) => {
    const c = r.indexedDB.open(e, t);
    c.onerror = () => {
      to.delete(e), fi.delete(e), a(c.error);
    }, c.onsuccess = () => {
      o(c.result);
    }, c.onupgradeneeded = () => {
      const u = c.result;
      n(u);
    }, c.onblocked = () => {
      console.warn("Database upgrade blocked - close other tabs/connections");
    };
  });
  return to.set(e, { version: t, promise: s }), fi.set(e, 1), s;
}
async function aE(e) {
  const t = to.get(e);
  if (!t)
    return !1;
  const n = (fi.get(e) ?? 1) - 1;
  if (n > 0)
    return fi.set(e, n), !1;
  fi.delete(e), to.delete(e);
  try {
    (await t.promise).close();
  } catch {
  }
  return !0;
}
const cE = "arkade-service-worker";
class uE {
  constructor(t = cE) {
    this.dbName = t, this.db = null;
  }
  async clear() {
    try {
      const t = await this.getDB();
      return new Promise((n, r) => {
        const i = t.transaction([Me], "readwrite"), s = i.objectStore(Me), o = i.objectStore(Me), a = s.clear(), c = o.clear();
        let u = 0;
        const l = () => {
          u++, u === 2 && n();
        };
        a.onsuccess = l, c.onsuccess = l, a.onerror = () => r(a.error), c.onerror = () => r(c.error);
      });
    } catch (t) {
      throw console.error("Failed to clear contract data:", t), t;
    }
  }
  async getContracts(t) {
    try {
      const r = (await this.getDB()).transaction([Me], "readonly").objectStore(Me);
      if (!t || Object.keys(t).length === 0)
        return new Promise((o, a) => {
          const c = r.getAll();
          c.onerror = () => a(c.error), c.onsuccess = () => o(c.result ?? []);
        });
      const i = eO(t);
      if (i.has("script")) {
        const o = i.get("script"), a = await Promise.all(o.map((c) => new Promise((u, l) => {
          const f = r.get(c);
          f.onerror = () => l(f.error), f.onsuccess = () => u(f.result);
        })));
        return this.applyContractFilter(a, i);
      }
      if (i.has("state")) {
        const o = await this.getContractsByIndexValues(r, "state", i.get("state"));
        return this.applyContractFilter(o, i);
      }
      if (i.has("type")) {
        const o = await this.getContractsByIndexValues(r, "type", i.get("type"));
        return this.applyContractFilter(o, i);
      }
      const s = await new Promise((o, a) => {
        const c = r.getAll();
        c.onerror = () => a(c.error), c.onsuccess = () => o(c.result ?? []);
      });
      return this.applyContractFilter(s, i);
    } catch (n) {
      return console.error("Failed to get contracts:", n), [];
    }
  }
  async saveContract(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const a = n.transaction([Me], "readwrite").objectStore(Me).put(t);
        a.onerror = () => i(a.error), a.onsuccess = () => r();
      });
    } catch (n) {
      throw console.error("Failed to save contract:", n), n;
    }
  }
  async deleteContract(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const o = n.transaction([Me], "readwrite").objectStore(Me), a = o.get(t);
        a.onerror = () => i(a.error), a.onsuccess = () => {
          const c = o.delete(t);
          c.onerror = () => i(c.error), c.onsuccess = () => r();
        };
      });
    } catch (n) {
      throw console.error(`Failed to delete contract ${t}:`, n), n;
    }
  }
  getContractsByIndexValues(t, n, r) {
    if (r.length === 0)
      return Promise.resolve([]);
    const i = t.index(n), s = r.map((o) => new Promise((a, c) => {
      const u = i.getAll(o);
      u.onerror = () => c(u.error), u.onsuccess = () => a(u.result ?? []);
    }));
    return Promise.all(s).then((o) => o.flatMap((a) => a));
  }
  applyContractFilter(t, n) {
    return t.filter((r) => !(r === void 0 || n.has("script") && !n.get("script")?.includes(r.script) || n.has("state") && !n.get("state")?.includes(r.state) || n.has("type") && !n.get("type")?.includes(r.type)));
  }
  async getDB() {
    return this.db ? this.db : (this.db = await oE(this.dbName, iE, sE), this.db);
  }
  async [Symbol.asyncDispose]() {
    this.db && (await aE(this.dbName), this.db = null);
  }
}
const tO = ["script", "state", "type"];
function eO(e) {
  const t = /* @__PURE__ */ new Map();
  return tO.forEach((n) => {
    e?.[n] && (Array.isArray(e[n]) ? t.set(n, e[n]) : t.set(n, [e[n]]));
  }), t;
}
class lE {
  constructor(t = cE) {
    this.dbName = t, this.db = null;
  }
  async clear() {
    try {
      const t = await this.getDB();
      return new Promise((n, r) => {
        const i = t.transaction([
          wn,
          mn,
          bn,
          wr
        ], "readwrite"), s = i.objectStore(wn), o = i.objectStore(mn), a = i.objectStore(bn), c = i.objectStore(wr), u = [
          s.clear(),
          o.clear(),
          a.clear(),
          c.clear()
        ];
        let l = 0;
        const f = () => {
          l++, l === u.length && n();
        };
        u.forEach((h) => {
          h.onsuccess = f, h.onerror = () => r(h.error);
        });
      });
    } catch (t) {
      throw console.error("Failed to clear wallet data:", t), t;
    }
  }
  async [Symbol.asyncDispose]() {
    this.db && (await aE(this.dbName), this.db = null);
  }
  async getVtxos(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const c = n.transaction([wn], "readonly").objectStore(wn).index("address").getAll(t);
        c.onerror = () => i(c.error), c.onsuccess = () => {
          const l = (c.result || []).map(X2);
          r(l);
        };
      });
    } catch (n) {
      return console.error(`Failed to get VTXOs for address ${t}:`, n), [];
    }
  }
  async saveVtxos(t, n) {
    try {
      const r = await this.getDB();
      return new Promise((i, s) => {
        const o = r.transaction([wn], "readwrite"), a = o.objectStore(wn), c = n.map((u) => new Promise((l, f) => {
          const h = Y2(u), g = {
            address: t,
            ...h
          }, d = a.put(g);
          d.onerror = () => f(d.error), d.onsuccess = () => l();
        }));
        Promise.all(c).then(() => i()).catch(s), o.onerror = () => s(o.error);
      });
    } catch (r) {
      throw console.error(`Failed to save VTXOs for address ${t}:`, r), r;
    }
  }
  async deleteVtxos(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const c = n.transaction([wn], "readwrite").objectStore(wn).index("address").openCursor(IDBKeyRange.only(t));
        c.onerror = () => i(c.error), c.onsuccess = () => {
          const u = c.result;
          u ? (u.delete(), u.continue()) : r();
        };
      });
    } catch (n) {
      throw console.error(`Failed to clear VTXOs for address ${t}:`, n), n;
    }
  }
  async getUtxos(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const c = n.transaction([mn], "readonly").objectStore(mn).index("address").getAll(t);
        c.onerror = () => i(c.error), c.onsuccess = () => {
          const l = (c.result || []).map(Q2);
          r(l);
        };
      });
    } catch (n) {
      return console.error(`Failed to get UTXOs for address ${t}:`, n), [];
    }
  }
  async saveUtxos(t, n) {
    try {
      const r = await this.getDB();
      return new Promise((i, s) => {
        const o = r.transaction([mn], "readwrite"), a = o.objectStore(mn), c = n.map((u) => new Promise((l, f) => {
          const h = Z2(u), g = {
            address: t,
            ...h
          }, d = a.put(g);
          d.onerror = () => f(d.error), d.onsuccess = () => l();
        }));
        Promise.all(c).then(() => i()).catch(s), o.onerror = () => s(o.error);
      });
    } catch (r) {
      throw console.error(`Failed to save UTXOs for address ${t}:`, r), r;
    }
  }
  async deleteUtxos(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const c = n.transaction([mn], "readwrite").objectStore(mn).index("address").openCursor(IDBKeyRange.only(t));
        c.onerror = () => i(c.error), c.onsuccess = () => {
          const u = c.result;
          u ? (u.delete(), u.continue()) : r();
        };
      });
    } catch (n) {
      throw console.error(`Failed to clear UTXOs for address ${t}:`, n), n;
    }
  }
  async getTransactionHistory(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const c = n.transaction([bn], "readonly").objectStore(bn).index("address").getAll(t);
        c.onerror = () => i(c.error), c.onsuccess = () => {
          const u = c.result || [];
          r(u.sort((l, f) => l.createdAt - f.createdAt));
        };
      });
    } catch (n) {
      return console.error(`Failed to get transaction history for address ${t}:`, n), [];
    }
  }
  async saveTransactions(t, n) {
    try {
      const r = await this.getDB();
      return new Promise((i, s) => {
        const o = r.transaction([bn], "readwrite"), a = o.objectStore(bn);
        n.forEach((c) => {
          const u = {
            address: t,
            ...c,
            keyBoardingTxid: c.key.boardingTxid,
            keyCommitmentTxid: c.key.commitmentTxid,
            keyArkTxid: c.key.arkTxid
          };
          a.put(u);
        }), o.oncomplete = () => i(), o.onerror = () => s(o.error), o.onabort = () => s(new Error("Transaction aborted"));
      });
    } catch (r) {
      throw console.error(`Failed to save transactions for address ${t}:`, r), r;
    }
  }
  async deleteTransactions(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const c = n.transaction([bn], "readwrite").objectStore(bn).index("address").openCursor(IDBKeyRange.only(t));
        c.onerror = () => i(c.error), c.onsuccess = () => {
          const u = c.result;
          u ? (u.delete(), u.continue()) : r();
        };
      });
    } catch (n) {
      throw console.error(`Failed to clear transactions for address ${t}:`, n), n;
    }
  }
  async getWalletState() {
    try {
      const t = await this.getDB();
      return new Promise((n, r) => {
        const o = t.transaction([wr], "readonly").objectStore(wr).get("state");
        o.onerror = () => r(o.error), o.onsuccess = () => {
          const a = o.result;
          a && a.data ? n(a.data) : n(null);
        };
      });
    } catch (t) {
      return console.error("Failed to get wallet state:", t), null;
    }
  }
  async saveWalletState(t) {
    try {
      const n = await this.getDB();
      return new Promise((r, i) => {
        const o = n.transaction([wr], "readwrite").objectStore(wr), a = {
          key: "state",
          data: t
        }, c = o.put(a);
        c.onerror = () => i(c.error), c.onsuccess = () => r();
      });
    } catch (n) {
      throw console.error("Failed to save wallet state:", n), n;
    }
  }
  async getDB() {
    return this.db ? this.db : (this.db = await oE(this.dbName, iE, sE), this.db);
  }
}
class nO {
  constructor(t) {
    this.contracts = /* @__PURE__ */ new Map(), this.isWatching = !1, this.connectionState = "disconnected", this.reconnectAttempts = 0, this.config = {
      failsafePollIntervalMs: 6e4,
      // 1 minute
      reconnectDelayMs: 1e3,
      // 1 second
      maxReconnectDelayMs: 3e4,
      // 30 seconds
      maxReconnectAttempts: 0,
      // unlimited
      ...t
    };
  }
  /**
   * Add a contract to be watched.
   *
   * Active contracts are immediately subscribed. All contracts are polled
   * to discover any existing VTXOs (which may cause them to be watched
   * even if inactive).
   */
  async addContract(t) {
    const n = {
      contract: t,
      lastKnownVtxos: /* @__PURE__ */ new Map()
    };
    this.contracts.set(t.script, n), this.isWatching && (await this.pollContracts([t.script]), await this.tryUpdateSubscription());
  }
  /**
   * Update an existing contract.
   */
  async updateContract(t) {
    const n = this.contracts.get(t.script);
    if (!n)
      throw new Error(`Contract ${t.script} not found`);
    n.contract = t, this.isWatching && await this.tryUpdateSubscription();
  }
  /**
   * Remove a contract from watching.
   */
  async removeContract(t) {
    this.contracts.get(t) && (this.contracts.delete(t), this.isWatching && await this.tryUpdateSubscription());
  }
  /**
   * Get all in-memory contracts.
   */
  getAllContracts() {
    return Array.from(this.contracts.values()).map((t) => t.contract);
  }
  /**
   * Get all active in-memory contracts.
   */
  getActiveContracts() {
    return this.getAllContracts().filter((t) => t.state === "active");
  }
  /**
   * Get scripts that should be watched.
   *
   * Returns scripts for:
   * - All active contracts
   * - All contracts with known VTXOs (regardless of state)
   *
   * This ensures we continue monitoring contracts even after they're
   * deactivated, as long as they have unspent VTXOs.
   */
  getScriptsToWatch() {
    const t = /* @__PURE__ */ new Set();
    for (const [, n] of this.contracts) {
      if (n.contract.state === "active") {
        t.add(n.contract.script);
        continue;
      }
      n.lastKnownVtxos.size > 0 && t.add(n.contract.script);
    }
    return Array.from(t);
  }
  /**
   * Get VTXOs for contracts, grouped by contract script.
   * Uses Repository.
   */
  async getContractVtxos(t) {
    const { contractScripts: n, includeSpent: r } = t, i = this.config.walletRepository, o = Array.from(this.contracts.values()).filter((c) => !(n && !n.includes(c.contract.script))).map(async (c) => {
      const u = await i.getVtxos(c.contract.address);
      if (u.length > 0) {
        const l = u.map((h) => ({
          ...h,
          contractScript: c.contract.script
        })), f = r ? l : l.filter((h) => !h.isSpent);
        return [[c.contract.script, f]];
      }
      return [];
    }), a = await Promise.all(o);
    return new Map(a.flat(1));
  }
  /**
   * Start watching for VTXO events across all active contracts.
   */
  async startWatching(t) {
    if (this.isWatching)
      throw new Error("Already watching");
    return this.eventCallback = t, this.isWatching = !0, this.abortController = new AbortController(), this.reconnectAttempts = 0, await this.connect(), this.startFailsafePolling(), () => this.stopWatching();
  }
  /**
   * Stop watching for events.
   */
  async stopWatching() {
    if (this.isWatching = !1, this.connectionState = "disconnected", this.abortController?.abort(), this.reconnectTimeoutId && (clearTimeout(this.reconnectTimeoutId), this.reconnectTimeoutId = void 0), this.failsafePollIntervalId && (clearInterval(this.failsafePollIntervalId), this.failsafePollIntervalId = void 0), this.subscriptionId) {
      try {
        await this.config.indexerProvider.unsubscribeForScripts(this.subscriptionId);
      } catch {
      }
      this.subscriptionId = void 0;
    }
    this.eventCallback = void 0;
  }
  /**
   * Check if currently watching.
   */
  isCurrentlyWatching() {
    return this.isWatching;
  }
  /**
   * Get current connection state.
   */
  getConnectionState() {
    return this.connectionState;
  }
  /**
   * Force a poll of all active contracts.
   * Useful for manual refresh or after app resume.
   */
  async forcePoll() {
    this.isWatching && await this.pollAllContracts();
  }
  /**
   * Check for expired contracts, update their state, and emit events.
   */
  checkExpiredContracts() {
    const t = Date.now();
    for (const n of this.contracts.values()) {
      const r = n.contract;
      r.state === "active" && r.expiresAt && r.expiresAt <= t && (r.state = "inactive", this.eventCallback?.({
        type: "contract_expired",
        contractScript: r.script,
        contract: r,
        timestamp: t
      }));
    }
  }
  /**
   * Connect to the subscription.
   */
  async connect() {
    if (this.isWatching) {
      this.connectionState = "connecting";
      try {
        await this.updateSubscription(), await this.pollAllContracts(), this.connectionState = "connected", this.reconnectAttempts = 0, this.listenLoop().catch((t) => {
          console.error(t), this.connectionState = "disconnected", this.eventCallback?.({
            type: "connection_reset",
            timestamp: Date.now()
          }), this.scheduleReconnect();
        });
      } catch (t) {
        console.error("ContractWatcher connection failed:", t), this.connectionState = "disconnected", this.eventCallback?.({
          type: "connection_reset",
          timestamp: Date.now()
        }), this.scheduleReconnect();
      }
    }
  }
  /**
   * Schedule a reconnection attempt.
   */
  scheduleReconnect() {
    if (!this.isWatching)
      return;
    if (this.config.maxReconnectAttempts > 0 && this.reconnectAttempts >= this.config.maxReconnectAttempts) {
      console.error(`ContractWatcher: Max reconnection attempts (${this.config.maxReconnectAttempts}) reached`);
      return;
    }
    this.connectionState = "reconnecting", this.reconnectAttempts++;
    const t = Math.min(this.config.reconnectDelayMs * Math.pow(2, this.reconnectAttempts - 1), this.config.maxReconnectDelayMs);
    this.reconnectTimeoutId = setTimeout(() => {
      this.reconnectTimeoutId = void 0, this.connect();
    }, t);
  }
  /**
   * Start the failsafe polling interval.
   */
  startFailsafePolling() {
    this.failsafePollIntervalId && clearInterval(this.failsafePollIntervalId), this.failsafePollIntervalId = setInterval(() => {
      this.isWatching && this.pollAllContracts().catch((t) => {
        console.error("ContractWatcher failsafe poll failed:", t);
      });
    }, this.config.failsafePollIntervalMs);
  }
  /**
   * Poll all active contracts for current state.
   */
  async pollAllContracts() {
    const t = this.getActiveContracts().map((n) => n.script);
    t.length !== 0 && await this.pollContracts(t);
  }
  /**
   * Poll specific contracts and emit events for changes.
   */
  async pollContracts(t) {
    if (!this.eventCallback)
      return;
    const n = Date.now();
    try {
      const r = await this.getContractVtxos({
        contractScripts: t,
        includeSpent: !1
        // only spendable ones!
      });
      for (const i of t) {
        const s = this.contracts.get(i);
        if (!s)
          continue;
        const o = r.get(i) || [], a = new Set(o.map((l) => `${l.txid}:${l.vout}`)), c = [];
        for (const l of o) {
          const f = `${l.txid}:${l.vout}`;
          s.lastKnownVtxos.has(f) || (c.push(l), s.lastKnownVtxos.set(f, l));
        }
        const u = [];
        for (const [l, f] of s.lastKnownVtxos)
          a.has(l) || (u.push(f), s.lastKnownVtxos.delete(l));
        c.length > 0 && this.emitVtxoEvent(i, c, "vtxo_received", n), u.length > 0 && this.emitVtxoEvent(i, u, "vtxo_spent", n);
      }
    } catch (r) {
      console.error("ContractWatcher poll failed:", r);
    }
  }
  async tryUpdateSubscription() {
    try {
      await this.updateSubscription();
    } catch {
    }
  }
  /**
   * Update the subscription with scripts that should be watched.
   *
   * Watches both active contracts and contracts with VTXOs.
   */
  async updateSubscription() {
    const t = this.getScriptsToWatch();
    if (t.length === 0) {
      if (this.subscriptionId) {
        try {
          await this.config.indexerProvider.unsubscribeForScripts(this.subscriptionId);
        } catch {
        }
        this.subscriptionId = void 0;
      }
      return;
    }
    this.subscriptionId = await this.config.indexerProvider.subscribeForScripts(t, this.subscriptionId);
  }
  /**
   * Main listening loop for subscription events.
   */
  async listenLoop() {
    if (!this.subscriptionId || !this.abortController || !this.isWatching) {
      this.isWatching && (this.connectionState = "disconnected", this.scheduleReconnect());
      return;
    }
    const t = this.config.indexerProvider.getSubscription(this.subscriptionId, this.abortController.signal);
    for await (const n of t) {
      if (!this.isWatching)
        break;
      this.handleSubscriptionUpdate(n);
    }
    this.isWatching && (this.connectionState = "disconnected", this.scheduleReconnect());
  }
  /**
   * Handle a subscription update.
   */
  handleSubscriptionUpdate(t) {
    if (!this.eventCallback)
      return;
    const n = Date.now(), r = t.scripts || [];
    t.newVtxos?.length && this.processSubscriptionVtxos(t.newVtxos, r, "vtxo_received", n), t.spentVtxos?.length && this.processSubscriptionVtxos(t.spentVtxos, r, "vtxo_spent", n);
  }
  /**
   * Process VTXOs from subscription and route to correct contracts.
   * Uses the scripts from the subscription response to determine contract ownership.
   */
  processSubscriptionVtxos(t, n, r, i) {
    if (n.length === 1) {
      const s = n[0];
      if (s) {
        const o = this.contracts.get(s);
        if (o)
          for (const a of t) {
            const c = `${a.txid}:${a.vout}`;
            r === "vtxo_received" ? o.lastKnownVtxos.set(c, a) : r === "vtxo_spent" && o.lastKnownVtxos.delete(c);
          }
        this.emitVtxoEvent(s, t, r, i);
      }
      return;
    }
    for (const s of n) {
      const o = s;
      if (o) {
        const a = this.contracts.get(o);
        if (a)
          for (const c of t) {
            const u = `${c.txid}:${c.vout}`;
            r === "vtxo_received" ? a.lastKnownVtxos.set(u, c) : a.lastKnownVtxos.delete(u);
          }
        this.emitVtxoEvent(o, t, r, i);
      }
    }
  }
  /**
   * Emit a VTXO event for a contract.
   */
  emitVtxoEvent(t, n, r, i) {
    if (!this.eventCallback)
      return;
    const s = this.contracts.get(t);
    switch (this.checkExpiredContracts(), r) {
      case "vtxo_received":
        if (!s)
          return;
        this.eventCallback({
          type: "vtxo_received",
          vtxos: n.map((o) => ({
            ...o,
            contractScript: t,
            // These fields may not be available from basic VirtualCoin
            forfeitTapLeafScript: void 0,
            intentTapLeafScript: void 0,
            tapTree: void 0
          })),
          contractScript: t,
          contract: s.contract,
          timestamp: i
        });
        return;
      case "vtxo_spent":
        if (!s)
          return;
        this.eventCallback({
          type: "vtxo_spent",
          vtxos: n.map((o) => ({
            ...o,
            contractScript: t,
            // These fields may not be available from basic VirtualCoin
            forfeitTapLeafScript: void 0,
            intentTapLeafScript: void 0,
            tapTree: void 0
          })),
          contractScript: t,
          contract: s.contract,
          timestamp: i
        });
        return;
      case "contract_expired":
        if (!s)
          return;
        this.eventCallback({
          type: "contract_expired",
          contractScript: t,
          contract: s.contract,
          timestamp: i
        });
        return;
      default:
        return;
    }
  }
}
class rO {
  constructor() {
    this.handlers = /* @__PURE__ */ new Map();
  }
  /**
   * Register a contract handler.
   *
   * @param handler - The handler to register
   * @throws If a handler for this type is already registered
   */
  register(t) {
    if (this.handlers.has(t.type))
      throw new Error(`Contract handler for type '${t.type}' is already registered`);
    this.handlers.set(t.type, t);
  }
  /**
   * Get a handler by type.
   *
   * @param type - The contract type
   * @returns The handler, or undefined if not found
   */
  get(t) {
    return this.handlers.get(t);
  }
  /**
   * Get a handler by type, throwing if not found.
   *
   * @param type - The contract type
   * @returns The handler
   * @throws If no handler is registered for this type
   */
  getOrThrow(t) {
    const n = this.get(t);
    if (!n)
      throw new Error(`No contract handler registered for type '${t}'`);
    return n;
  }
  /**
   * Check if a handler is registered.
   *
   * @param type - The contract type
   */
  has(t) {
    return this.handlers.has(t);
  }
  /**
   * Get all registered types.
   */
  getRegisteredTypes() {
    return Array.from(this.handlers.keys());
  }
  /**
   * Unregister a handler (mainly for testing).
   */
  unregister(t) {
    return this.handlers.delete(t);
  }
  /**
   * Clear all handlers (mainly for testing).
   */
  clear() {
    this.handlers.clear();
  }
}
const eo = new rO();
function no(e) {
  return us.encode(e.type === "blocks" ? { blocks: Number(e.value) } : { seconds: Number(e.value) });
}
function ro(e) {
  const t = us.decode(e);
  if ("blocks" in t && t.blocks !== void 0)
    return { type: "blocks", value: BigInt(t.blocks) };
  if ("seconds" in t && t.seconds !== void 0)
    return { type: "seconds", value: BigInt(t.seconds) };
  throw new Error(`Invalid BIP68 sequence: ${e}`);
}
function pl(e, t) {
  if (t.role === "sender" || t.role === "receiver")
    return t.role;
  if (t.walletPubKey) {
    if (t.walletPubKey === e.params.sender)
      return "sender";
    if (t.walletPubKey === e.params.receiver)
      return "receiver";
  }
}
function _i(e, t) {
  if (t === void 0)
    return !0;
  if (!e.vtxo)
    return !1;
  const n = ro(t);
  if (n.type === "blocks")
    return e.blockHeight === void 0 || e.vtxo.status.block_height === void 0 ? !1 : e.blockHeight - e.vtxo.status.block_height >= Number(n.value);
  if (n.type === "seconds") {
    const r = e.vtxo.status.block_time;
    return r === void 0 ? !1 : e.currentTime / 1e3 - r >= Number(n.value);
  }
  return !1;
}
const iO = {
  type: "default",
  createScript(e) {
    const t = this.deserializeParams(e);
    return new gi.Script(t);
  },
  serializeParams(e) {
    return {
      pubKey: C.encode(e.pubKey),
      serverPubKey: C.encode(e.serverPubKey),
      csvTimelock: no(e.csvTimelock).toString()
    };
  },
  deserializeParams(e) {
    const t = e.csvTimelock ? ro(Number(e.csvTimelock)) : gi.Script.DEFAULT_TIMELOCK;
    return {
      pubKey: C.decode(e.pubKey),
      serverPubKey: C.decode(e.serverPubKey),
      csvTimelock: t
    };
  },
  selectPath(e, t, n) {
    if (n.collaborative)
      return { leaf: e.forfeit() };
    const r = t.params.csvTimelock ? Number(t.params.csvTimelock) : void 0;
    return _i(n, r) ? {
      leaf: e.exit(),
      sequence: r
    } : null;
  },
  getAllSpendingPaths(e, t, n) {
    const r = [];
    n.collaborative && r.push({ leaf: e.forfeit() });
    const i = { leaf: e.exit() };
    return t.params.csvTimelock && (i.sequence = Number(t.params.csvTimelock)), r.push(i), r;
  },
  getSpendablePaths(e, t, n) {
    const r = [];
    n.collaborative && r.push({ leaf: e.forfeit() });
    const i = t.params.csvTimelock ? Number(t.params.csvTimelock) : void 0;
    if (_i(n, i)) {
      const s = { leaf: e.exit() };
      i !== void 0 && (s.sequence = i), r.push(s);
    }
    return r;
  }
}, sO = {
  type: "vhtlc",
  createScript(e) {
    const t = this.deserializeParams(e);
    return new Sf.Script(t);
  },
  serializeParams(e) {
    return {
      sender: C.encode(e.sender),
      receiver: C.encode(e.receiver),
      server: C.encode(e.server),
      hash: C.encode(e.preimageHash),
      refundLocktime: e.refundLocktime.toString(),
      claimDelay: no(e.unilateralClaimDelay).toString(),
      refundDelay: no(e.unilateralRefundDelay).toString(),
      refundNoReceiverDelay: no(e.unilateralRefundWithoutReceiverDelay).toString()
    };
  },
  deserializeParams(e) {
    return {
      sender: C.decode(e.sender),
      receiver: C.decode(e.receiver),
      server: C.decode(e.server),
      preimageHash: C.decode(e.hash),
      refundLocktime: BigInt(e.refundLocktime),
      unilateralClaimDelay: ro(Number(e.claimDelay)),
      unilateralRefundDelay: ro(Number(e.refundDelay)),
      unilateralRefundWithoutReceiverDelay: ro(Number(e.refundNoReceiverDelay))
    };
  },
  /**
   * Select spending path based on context.
   *
   * Role is determined from `context.role` or by matching `context.walletPubKey`
   * against sender/receiver in contract params.
   */
  selectPath(e, t, n) {
    const r = pl(t, n), i = t.params?.preimage, s = BigInt(t.params.refundLocktime), o = Math.floor(n.currentTime / 1e3);
    if (!r)
      return null;
    if (n.collaborative)
      return r === "receiver" && i ? {
        leaf: e.claim(),
        extraWitness: [C.decode(i)]
      } : r === "sender" && BigInt(o) >= s ? {
        leaf: e.refundWithoutReceiver()
      } : null;
    if (r === "receiver" && i) {
      const a = Number(t.params.claimDelay);
      return _i(n, a) ? {
        leaf: e.unilateralClaim(),
        extraWitness: [C.decode(i)],
        sequence: a
      } : null;
    }
    if (r === "sender") {
      const a = Number(t.params.refundNoReceiverDelay);
      return _i(n, a) ? {
        leaf: e.unilateralRefundWithoutReceiver(),
        sequence: a
      } : null;
    }
    return null;
  },
  /**
   * Get all possible spending paths (no timelock checks).
   *
   * Role is determined from `context.role` or by matching `context.walletPubKey`
   * against sender/receiver in contract params.
   */
  getAllSpendingPaths(e, t, n) {
    const r = pl(t, n), i = [];
    if (!r)
      return i;
    const s = t.params?.preimage;
    if (n.collaborative)
      r === "receiver" && s && i.push({
        leaf: e.claim(),
        extraWitness: [C.decode(s)]
      }), r === "sender" && i.push({
        leaf: e.refundWithoutReceiver()
      });
    else {
      if (r === "receiver" && s) {
        const o = Number(t.params.claimDelay);
        i.push({
          leaf: e.unilateralClaim(),
          extraWitness: [C.decode(s)],
          sequence: o
        });
      }
      if (r === "sender") {
        const o = Number(t.params.refundNoReceiverDelay);
        i.push({
          leaf: e.unilateralRefundWithoutReceiver(),
          sequence: o
        });
      }
    }
    return i;
  },
  getSpendablePaths(e, t, n) {
    const r = pl(t, n), i = [];
    if (!r)
      return i;
    const s = t.params?.preimage, o = BigInt(t.params.refundLocktime), a = Math.floor(n.currentTime / 1e3);
    if (n.collaborative)
      return r === "receiver" && s && i.push({
        leaf: e.claim(),
        extraWitness: [C.decode(s)]
      }), r === "sender" && BigInt(a) >= o && i.push({
        leaf: e.refundWithoutReceiver()
      }), i;
    if (r === "receiver" && s) {
      const c = Number(t.params.claimDelay);
      _i(n, c) && i.push({
        leaf: e.unilateralClaim(),
        extraWitness: [C.decode(s)],
        sequence: c
      });
    }
    if (r === "sender") {
      const c = Number(t.params.refundNoReceiverDelay);
      _i(n, c) && i.push({
        leaf: e.unilateralRefundWithoutReceiver(),
        sequence: c
      });
    }
    return i;
  }
};
eo.register(iO);
eo.register(sO);
class ch {
  constructor(t) {
    this.initialized = !1, this.eventCallbacks = /* @__PURE__ */ new Set(), this.config = t, this.watcher = new nO({
      indexerProvider: t.indexerProvider,
      walletRepository: t.walletRepository,
      ...t.watcherConfig
    });
  }
  /**
   * Static factory method for creating a new ContractManager.
   * Initialize the manager by loading persisted contracts and starting to watch.
   *
   * After initialization, the manager automatically watches all active contracts
   * and contracts with VTXOs. Use `onContractEvent()` to register event callbacks.
   *
   * @param config ContractManagerConfig
   */
  static async create(t) {
    const n = new ch(t);
    return await n.initialize(), n;
  }
  async initialize() {
    if (this.initialized)
      return;
    const t = await this.config.contractRepository.getContracts();
    await this.getVtxosForContracts(t);
    const n = Date.now();
    for (const r of t)
      r.state === "active" && r.expiresAt && r.expiresAt <= n && (r.state = "inactive", await this.config.contractRepository.saveContract(r)), await this.watcher.addContract(r);
    this.initialized = !0, this.stopWatcherFn = await this.watcher.startWatching((r) => {
      this.handleContractEvent(r);
    });
  }
  /**
   * Create and register a new contract.
   *
   * @param params - Contract parameters
   * @returns The created contract
   */
  async createContract(t) {
    const n = eo.get(t.type);
    if (!n)
      throw new Error(`No handler registered for contract type '${t.type}'`);
    try {
      const s = n.createScript(t.params), o = C.encode(s.pkScript);
      if (o !== t.script)
        throw new Error(`Script mismatch: provided script does not match script derived from params. Expected ${o}, got ${t.script}`);
    } catch (s) {
      throw s instanceof Error && s.message.includes("mismatch") ? s : new Error(`Invalid params for contract type '${t.type}': ${s instanceof Error ? s.message : String(s)}`);
    }
    const [r] = await this.getContracts({ script: t.script });
    if (r) {
      if (r.type === t.type)
        return r;
      throw new Error(`Contract with script ${t.script} already exists with with type ${r.type}.`);
    }
    const i = {
      ...t,
      createdAt: Date.now(),
      state: t.state || "active"
    };
    return await this.config.contractRepository.saveContract(i), await this.getVtxosForContracts([i]), await this.watcher.addContract(i), i;
  }
  /**
   * Get contracts with optional filters.
   *
   * @param filter - Optional filter criteria
   * @returns Filtered contracts TODO: filter spent/unspent
   *
   * @example
   * ```typescript
   * // Get all VHTLC contracts
   * const vhtlcs = await manager.getContracts({ type: 'vhtlc' });
   *
   * // Get all active contracts
   * const active = await manager.getContracts({ state: 'active' });
   * ```
   */
  async getContracts(t) {
    const n = this.buildContractsDbFilter(t ?? {});
    return await this.config.contractRepository.getContracts(n);
  }
  async getContractsWithVtxos(t) {
    const n = await this.getContracts(t), r = await this.getVtxosForContracts(n);
    return n.map((i) => ({
      contract: i,
      vtxos: r.get(i.script) ?? []
    }));
  }
  buildContractsDbFilter(t) {
    return {
      script: t.script,
      state: t.state,
      type: t.type
    };
  }
  /**
   * Update a contract.
   * Nested fields like `params` and `metadata` are replaced with the provided values.
   * If you need to preserve existing fields, merge them manually.
   *
   * @param script - Contract script
   * @param updates - Fields to update
   */
  async updateContract(t, n) {
    const i = (await this.config.contractRepository.getContracts({
      script: t
    }))[0];
    if (!i)
      throw new Error(`Contract ${t} not found`);
    const s = {
      ...i,
      ...n
    };
    return await this.config.contractRepository.saveContract(s), await this.watcher.updateContract(s), s;
  }
  /**
   * Update a contract's params.
   * This method preserves existing params by merging the provided values.
   *
   * @param script - Contract script
   * @param updates - The new values to merge with existing params
   */
  async updateContractParams(t, n) {
    const i = (await this.config.contractRepository.getContracts({
      script: t
    }))[0];
    if (!i)
      throw new Error(`Contract ${t} not found`);
    const s = {
      ...i,
      params: { ...i.params, ...n }
    };
    return await this.config.contractRepository.saveContract(s), await this.watcher.updateContract(s), s;
  }
  /**
   * Set a contract's state.
   */
  async setContractState(t, n) {
    await this.updateContract(t, { state: n });
  }
  /**
   * Delete a contract.
   *
   * @param script - Contract script
   */
  async deleteContract(t) {
    await this.config.contractRepository.deleteContract(t), await this.watcher.removeContract(t);
  }
  /**
   * Get currently spendable paths for a contract.
   *
   * @param contractScript - The contract script
   * @param options - Options for getting spendable paths
   */
  async getSpendablePaths(t) {
    const { contractScript: n, collaborative: r = !0, walletPubKey: i, vtxo: s } = t, [o] = await this.getContracts({ script: n });
    if (!o)
      return [];
    const a = eo.get(o.type);
    if (!a)
      return [];
    const c = a.createScript(o.params), u = {
      collaborative: r,
      currentTime: Date.now(),
      walletPubKey: i,
      vtxo: s
    };
    return a.getSpendablePaths(c, o, u);
  }
  async getAllSpendingPaths(t) {
    const { contractScript: n, collaborative: r = !0, walletPubKey: i } = t, [s] = await this.getContracts({ script: n });
    if (!s)
      return [];
    const o = eo.get(s.type);
    if (!o)
      return [];
    const a = o.createScript(s.params), c = {
      collaborative: r,
      currentTime: Date.now(),
      walletPubKey: i
    };
    return o.getAllSpendingPaths(a, s, c);
  }
  /**
   * Register a callback for contract events.
   *
   * The manager automatically watches after `initialize()`. This method
   * allows registering callbacks to receive events.
   *
   * @param callback - Event callback
   * @returns Unsubscribe function to remove this callback
   *
   * @example
   * ```typescript
   * const unsubscribe = manager.onContractEvent((event) => {
   *   console.log(`${event.type} on ${event.contractScript}`);
   * });
   *
   * // Later: stop receiving events
   * unsubscribe();
   * ```
   */
  onContractEvent(t) {
    return this.eventCallbacks.add(t), () => {
      this.eventCallbacks.delete(t);
    };
  }
  /**
   * Check if currently watching.
   */
  async isWatching() {
    return this.watcher.isCurrentlyWatching();
  }
  /**
   * Emit an event to all registered callbacks.
   */
  emitEvent(t) {
    for (const n of this.eventCallbacks)
      try {
        n(t);
      } catch (r) {
        console.error("Error in contract event callback:", r);
      }
  }
  /**
   * Handle events from the watcher.
   */
  async handleContractEvent(t) {
    switch (t.type) {
      // Every time there is a VTXO event for a contract, refresh all its VTXOs
      case "vtxo_received":
      case "vtxo_spent":
        await this.fetchContractVxosFromIndexer([t.contract], !0);
        break;
      case "connection_reset":
        const n = this.watcher.getActiveContracts();
        await this.fetchContractVxosFromIndexer(n, !1);
        break;
      case "contract_expired":
        await this.config.contractRepository.saveContract(t.contract);
    }
    this.emitEvent(t);
  }
  async getVtxosForContracts(t) {
    return t.length === 0 ? /* @__PURE__ */ new Map() : await this.fetchContractVxosFromIndexer(t, !1);
  }
  async fetchContractVxosFromIndexer(t, n) {
    const r = await this.fetchContractVtxosBulk(t, n), i = /* @__PURE__ */ new Map();
    for (const [s, o] of r) {
      i.set(s, o);
      const a = t.find((c) => c.script === s);
      a && await this.config.walletRepository.saveVtxos(a.address, o);
    }
    return i;
  }
  async fetchContractVtxosBulk(t, n) {
    const r = /* @__PURE__ */ new Map();
    return await Promise.all(t.map(async (i) => {
      const s = await this.fetchContractVtxosPaginated(i, n);
      r.set(i.script, s);
    })), r;
  }
  async fetchContractVtxosPaginated(t, n, r) {
    const s = [];
    let o = 0, a = !0;
    const c = n ? {} : { spendableOnly: !0 };
    for (; a; ) {
      const { vtxos: u, page: l } = await this.config.indexerProvider.getVtxos({
        scripts: [t.script],
        ...c,
        pageIndex: o,
        pageSize: 100
      });
      for (const f of u) {
        const h = this.config.extendVtxo(f);
        s.push({
          ...h,
          contractScript: t.script
        });
      }
      a = l ? u.length === 100 : !1, o++;
    }
    return s;
  }
  /**
   * Dispose of the ContractManager and release all resources.
   *
   * Stops the watcher, clears callbacks, and marks
   * the manager as uninitialized.
   *
   * Implements the disposable pattern for cleanup.
   */
  dispose() {
    this.stopWatcherFn?.(), this.stopWatcherFn = void 0, this.eventCallbacks.clear(), this.initialized = !1;
  }
  /**
   * Symbol.dispose implementation for using with `using` keyword.
   * @example
   * ```typescript
   * {
   *   using manager = await wallet.getContractManager();
   *   // ... use manager
   * } // automatically disposed
   * ```
   */
  [Symbol.dispose]() {
    this.stopWatcherFn?.(), this.stopWatcherFn = void 0, this.eventCallbacks.clear(), this.initialized = !1;
  }
}
function oO(e) {
  return typeof e == "object" && e !== null && "toReadonly" in e && typeof e.toReadonly == "function";
}
class yi {
  constructor(t, n, r, i, s, o, a, c, u, l, f) {
    this.identity = t, this.network = n, this.onchainProvider = r, this.indexerProvider = i, this.arkServerPublicKey = s, this.offchainTapscript = o, this.boardingTapscript = a, this.dustAmount = c, this.walletRepository = u, this.contractRepository = l, this.watcherConfig = f;
  }
  /**
   * Protected helper to set up shared wallet configuration.
   * Extracts common logic used by both ReadonlyWallet.create() and Wallet.create().
   */
  static async setupWalletConfig(t, n) {
    const r = t.arkProvider || (() => {
      if (!t.arkServerUrl)
        throw new Error("Either arkProvider or arkServerUrl must be provided");
      return new M0(t.arkServerUrl);
    })(), i = t.arkServerUrl || r.serverUrl;
    if (!i)
      throw new Error("Could not determine arkServerUrl from provider");
    const s = t.indexerUrl || i, o = t.indexerProvider || new K0(s), a = await r.getInfo(), c = vI(a.network), u = t.esploraUrl || AI[a.network], l = t.onchainProvider || new $I(u);
    if (t.exitTimelock) {
      const { value: A, type: R } = t.exitTimelock;
      if (A < 512n && R !== "blocks" || A >= 512n && R !== "seconds")
        throw new Error("invalid exitTimelock");
    }
    const f = t.exitTimelock ?? {
      value: a.unilateralExitDelay,
      type: a.unilateralExitDelay < 512n ? "blocks" : "seconds"
    };
    if (t.boardingTimelock) {
      const { value: A, type: R } = t.boardingTimelock;
      if (A < 512n && R !== "blocks" || A >= 512n && R !== "seconds")
        throw new Error("invalid boardingTimelock");
    }
    const h = t.boardingTimelock ?? {
      value: a.boardingExitDelay,
      type: a.boardingExitDelay < 512n ? "blocks" : "seconds"
    }, g = C.decode(a.signerPubkey).slice(1), d = new gi.Script({
      pubKey: n,
      serverPubKey: g,
      csvTimelock: f
    }), p = new gi.Script({
      pubKey: n,
      serverPubKey: g,
      csvTimelock: h
    }), y = d, x = t.storage?.walletRepository ?? new lE(), S = t.storage?.contractRepository ?? new uE();
    return {
      arkProvider: r,
      indexerProvider: o,
      onchainProvider: l,
      network: c,
      networkName: a.network,
      serverPubKey: g,
      offchainTapscript: y,
      boardingTapscript: p,
      dustAmount: a.dust,
      walletRepository: x,
      contractRepository: S,
      info: a
    };
  }
  static async create(t) {
    const n = await t.identity.xOnlyPublicKey();
    if (!n)
      throw new Error("Invalid configured public key");
    const r = await yi.setupWalletConfig(t, n);
    return new yi(t.identity, r.network, r.onchainProvider, r.indexerProvider, r.serverPubKey, r.offchainTapscript, r.boardingTapscript, r.dustAmount, r.walletRepository, r.contractRepository, t.watcherConfig);
  }
  get arkAddress() {
    return this.offchainTapscript.address(this.network.hrp, this.arkServerPublicKey);
  }
  /**
   * Get the contract script for the wallet's default address.
   * This is the pkScript hex, used to identify the wallet in ContractManager.
   */
  get defaultContractScript() {
    return C.encode(this.offchainTapscript.pkScript);
  }
  async getAddress() {
    return this.arkAddress.encode();
  }
  async getBoardingAddress() {
    return this.boardingTapscript.onchainAddress(this.network);
  }
  async getBalance() {
    const [t, n] = await Promise.all([
      this.getBoardingUtxos(),
      this.getVtxos()
    ]);
    let r = 0, i = 0;
    for (const l of t)
      l.status.confirmed ? r += l.value : i += l.value;
    let s = 0, o = 0, a = 0;
    s = n.filter((l) => l.virtualStatus.state === "settled").reduce((l, f) => l + f.value, 0), o = n.filter((l) => l.virtualStatus.state === "preconfirmed").reduce((l, f) => l + f.value, 0), a = n.filter((l) => qi(l) && l.virtualStatus.state === "swept").reduce((l, f) => l + f.value, 0);
    const c = r + i, u = s + o + a;
    return {
      boarding: {
        confirmed: r,
        unconfirmed: i,
        total: c
      },
      settled: s,
      preconfirmed: o,
      available: s + o,
      recoverable: a,
      total: c + u
    };
  }
  // TODO: use contract manager (and repo) will be offline-first
  async getVtxos(t) {
    const n = await this.getAddress(), i = (await this.getVirtualCoins(t)).map((s) => jn(this, s));
    return await this.walletRepository.saveVtxos(n, i), i;
  }
  async getVirtualCoins(t = { withRecoverable: !0, withUnrolled: !1 }) {
    const n = [C.encode(this.offchainTapscript.pkScript)], i = (await this.indexerProvider.getVtxos({ scripts: n })).vtxos;
    let s = i.filter(qi);
    if (t.withRecoverable || (s = s.filter((o) => !eh(o) && !F0(o))), t.withUnrolled) {
      const o = i.filter((a) => !qi(a));
      s.push(...o.filter((a) => a.isUnrolled));
    }
    return s;
  }
  async getTransactionHistory() {
    const t = await this.indexerProvider.getVtxos({
      scripts: [C.encode(this.offchainTapscript.pkScript)]
    }), { boardingTxs: n, commitmentsToIgnore: r } = await this.getBoardingTxs(), i = (s) => this.indexerProvider.getVtxos({ outpoints: [{ txid: s, vout: 0 }] }).then((o) => o.vtxos[0]?.createdAt.getTime() || 0);
    return G2(t.vtxos, n, r, i);
  }
  async getBoardingTxs() {
    const t = [], n = /* @__PURE__ */ new Set(), r = await this.getBoardingAddress(), i = await this.onchainProvider.getTransactions(r);
    for (const a of i)
      for (let c = 0; c < a.vout.length; c++) {
        const u = a.vout[c];
        if (u.scriptpubkey_address === r) {
          const f = (await this.onchainProvider.getTxOutspends(a.txid))[c];
          f?.spent && n.add(f.txid), t.push({
            txid: a.txid,
            vout: c,
            value: Number(u.value),
            status: {
              confirmed: a.status.confirmed,
              block_time: a.status.block_time
            },
            isUnrolled: !0,
            virtualStatus: {
              state: f?.spent ? "spent" : "settled",
              commitmentTxIds: f?.spent ? [f.txid] : void 0
            },
            createdAt: a.status.confirmed ? new Date(a.status.block_time * 1e3) : /* @__PURE__ */ new Date(0)
          });
        }
      }
    const s = [], o = [];
    for (const a of t) {
      const c = {
        key: {
          boardingTxid: a.txid,
          commitmentTxid: "",
          arkTxid: ""
        },
        amount: a.value,
        type: Mn.TxReceived,
        settled: a.virtualStatus.state === "spent",
        createdAt: a.status.block_time ? new Date(a.status.block_time * 1e3).getTime() : 0
      };
      a.status.block_time ? o.push(c) : s.push(c);
    }
    return {
      boardingTxs: [...s, ...o],
      commitmentsToIgnore: n
    };
  }
  async getBoardingUtxos() {
    const t = await this.getBoardingAddress(), r = (await this.onchainProvider.getCoins(t)).map((i) => $f(this, i));
    return await this.walletRepository.saveUtxos(t, r), r;
  }
  async notifyIncomingFunds(t) {
    const n = await this.getAddress(), r = await this.getBoardingAddress();
    let i, s;
    if (this.onchainProvider && r) {
      const a = (c) => c.vout.findIndex((u) => u.scriptpubkey_address === r);
      i = await this.onchainProvider.watchAddresses([r], (c) => {
        const u = c.filter((l) => a(l) !== -1).map((l) => {
          const { txid: f, status: h } = l, g = a(l), d = Number(l.vout[g].value);
          return { txid: f, vout: g, value: d, status: h };
        });
        t({
          type: "utxo",
          coins: u
        });
      });
    }
    if (this.indexerProvider && n) {
      const a = this.offchainTapscript, c = await this.indexerProvider.subscribeForScripts([
        C.encode(a.pkScript)
      ]), u = new AbortController(), l = this.indexerProvider.getSubscription(c, u.signal);
      s = async () => {
        u.abort(), await this.indexerProvider?.unsubscribeForScripts(c);
      }, (async () => {
        try {
          for await (const f of l)
            (f.newVtxos?.length > 0 || f.spentVtxos?.length > 0) && t({
              type: "vtxo",
              newVtxos: f.newVtxos.map((h) => jn(this, h)),
              spentVtxos: f.spentVtxos.map((h) => jn(this, h))
            });
        } catch (f) {
          console.error("Subscription error:", f);
        }
      })();
    }
    return () => {
      i?.(), s?.();
    };
  }
  async fetchPendingTxs() {
    const t = [C.encode(this.offchainTapscript.pkScript)];
    let { vtxos: n } = await this.indexerProvider.getVtxos({
      scripts: t
    });
    return n.filter((r) => r.virtualStatus.state !== "swept" && r.virtualStatus.state !== "settled" && r.arkTxId !== void 0).map((r) => r.arkTxId);
  }
  // ========================================================================
  // Contract Management
  // ========================================================================
  /**
   * Get the ContractManager for managing contracts including the wallet's default address.
   *
   * The ContractManager handles:
   * - The wallet's default receiving address (as a "default" contract)
   * - External contracts (Boltz swaps, HTLCs, etc.)
   * - Multi-contract watching with resilient connections
   *
   * @example
   * ```typescript
   * const manager = await wallet.getContractManager();
   *
   * // Create a contract for a Boltz swap
   * const contract = await manager.createContract({
   *   label: "Boltz Swap",
   *   type: "vhtlc",
   *   params: { ... },
   *   script: swapScript,
   *   address: swapAddress,
   * });
   *
   * // Start watching for events (includes wallet's default address)
   * const stop = await manager.onContractEvent((event) => {
   *   console.log(`${event.type} on ${event.contractScript}`);
   * });
   * ```
   */
  async getContractManager() {
    if (this._contractManager)
      return this._contractManager;
    if (this._contractManagerInitializing)
      return this._contractManagerInitializing;
    this._contractManagerInitializing = this.initializeContractManager();
    try {
      const t = await this._contractManagerInitializing;
      return this._contractManager = t, t;
    } catch (t) {
      throw this._contractManagerInitializing = void 0, t;
    } finally {
      this._contractManagerInitializing = void 0;
    }
  }
  async initializeContractManager() {
    const t = await ch.create({
      indexerProvider: this.indexerProvider,
      contractRepository: this.contractRepository,
      walletRepository: this.walletRepository,
      extendVtxo: (r) => jn(this, r),
      getDefaultAddress: () => this.getAddress(),
      watcherConfig: this.watcherConfig
    }), n = this.offchainTapscript.options.csvTimelock ?? gi.Script.DEFAULT_TIMELOCK;
    return await t.createContract({
      type: "default",
      params: {
        pubKey: C.encode(this.offchainTapscript.options.pubKey),
        serverPubKey: C.encode(this.offchainTapscript.options.serverPubKey),
        csvTimelock: no(n).toString()
      },
      script: this.defaultContractScript,
      address: await this.getAddress(),
      state: "active"
    }), t;
  }
}
class ws extends yi {
  constructor(t, n, r, i, s, o, a, c, u, l, f, h, g, d, p, y, x) {
    super(t, n, i, o, a, c, u, g, d, p, x), this.networkName = r, this.arkProvider = s, this.serverUnrollScript = l, this.forfeitOutputScript = f, this.forfeitPubkey = h, this.identity = t, this.renewalConfig = {
      enabled: y?.enabled ?? !1,
      ...GI,
      ...y
    };
  }
  static async create(t) {
    const n = await t.identity.xOnlyPublicKey();
    if (!n)
      throw new Error("Invalid configured public key");
    const r = await yi.setupWalletConfig(t, n);
    let i;
    try {
      const c = C.decode(r.info.checkpointTapscript);
      i = xe.decode(c);
    } catch {
      throw new Error("Invalid checkpointTapscript from server");
    }
    const s = C.decode(r.info.forfeitPubkey).slice(1), o = Gn(r.network).decode(r.info.forfeitAddress), a = It.encode(o);
    return new ws(t.identity, r.network, r.networkName, r.onchainProvider, r.arkProvider, r.indexerProvider, r.serverPubKey, r.offchainTapscript, r.boardingTapscript, i, a, s, r.dustAmount, r.walletRepository, r.contractRepository, t.renewalConfig, t.watcherConfig);
  }
  /**
   * Convert this wallet to a readonly wallet.
   *
   * @returns A readonly wallet with the same configuration but readonly identity
   * @example
   * ```typescript
   * const wallet = await Wallet.create({ identity: SingleKey.fromHex('...'), ... });
   * const readonlyWallet = await wallet.toReadonly();
   *
   * // Can query balance and addresses
   * const balance = await readonlyWallet.getBalance();
   * const address = await readonlyWallet.getAddress();
   *
   * // But cannot send transactions (type error)
   * // readonlyWallet.sendBitcoin(...); // TypeScript error
   * ```
   */
  async toReadonly() {
    const t = oO(this.identity) ? await this.identity.toReadonly() : this.identity;
    return new yi(t, this.network, this.onchainProvider, this.indexerProvider, this.arkServerPublicKey, this.offchainTapscript, this.boardingTapscript, this.dustAmount, this.walletRepository, this.contractRepository, this.watcherConfig);
  }
  async sendBitcoin(t) {
    if (t.amount <= 0)
      throw new Error("Amount must be positive");
    if (!cO(t.address))
      throw new Error("Invalid Ark address " + t.address);
    const n = await this.getVirtualCoins({
      withRecoverable: !1
    });
    let r;
    if (t.selectedVtxos) {
      const d = t.selectedVtxos.map((y) => y.value).reduce((y, x) => y + x, 0);
      if (d < t.amount)
        throw new Error("Selected VTXOs do not cover specified amount");
      const p = d - t.amount;
      r = {
        inputs: t.selectedVtxos,
        changeAmount: BigInt(p)
      };
    } else
      r = uO(n, t.amount);
    const i = this.offchainTapscript.forfeit();
    if (!i)
      throw new Error("Selected leaf not found");
    const s = pi.decode(t.address), a = [
      {
        script: BigInt(t.amount) < this.dustAmount ? s.subdustPkScript : s.pkScript,
        amount: BigInt(t.amount)
      }
    ];
    if (r.changeAmount > 0n) {
      const d = r.changeAmount < this.dustAmount ? this.arkAddress.subdustPkScript : this.arkAddress.pkScript;
      a.push({
        script: d,
        amount: BigInt(r.changeAmount)
      });
    }
    const c = this.offchainTapscript.encode(), u = WI(r.inputs.map((d) => ({
      ...d,
      tapLeafScript: i,
      tapTree: c
    })), a, this.serverUnrollScript), l = await this.identity.sign(u.arkTx), { arkTxid: f, signedCheckpointTxs: h } = await this.arkProvider.submitTx(ut.encode(l.toPSBT()), u.checkpoints.map((d) => ut.encode(d.toPSBT()))), g = await Promise.all(h.map(async (d) => {
      const p = Xt.fromPSBT(ut.decode(d)), y = await this.identity.sign(p);
      return ut.encode(y.toPSBT());
    }));
    await this.arkProvider.finalizeTx(f, g);
    try {
      const d = [], p = /* @__PURE__ */ new Set();
      let y = Number.MAX_SAFE_INTEGER;
      for (const [A, R] of r.inputs.entries()) {
        const N = jn(this, R), F = h[A], w = Xt.fromPSBT(ut.decode(F));
        if (d.push({
          ...N,
          virtualStatus: { ...N.virtualStatus, state: "spent" },
          spentBy: w.id,
          arkTxId: f,
          isSpent: !0
        }), N.virtualStatus.commitmentTxIds)
          for (const K of N.virtualStatus.commitmentTxIds)
            p.add(K);
        N.virtualStatus.batchExpiry && (y = Math.min(y, N.virtualStatus.batchExpiry));
      }
      const x = Date.now(), S = this.arkAddress.encode();
      if (r.changeAmount > 0n && y !== Number.MAX_SAFE_INTEGER) {
        const A = {
          txid: f,
          vout: a.length - 1,
          createdAt: new Date(x),
          forfeitTapLeafScript: this.offchainTapscript.forfeit(),
          intentTapLeafScript: this.offchainTapscript.forfeit(),
          isUnrolled: !1,
          isSpent: !1,
          tapTree: this.offchainTapscript.encode(),
          value: Number(r.changeAmount),
          virtualStatus: {
            state: "preconfirmed",
            commitmentTxIds: Array.from(p),
            batchExpiry: y
          },
          status: {
            confirmed: !1
          }
        };
        await this.walletRepository.saveVtxos(S, [A]);
      }
      await this.walletRepository.saveVtxos(S, d), await this.walletRepository.saveTransactions(S, [
        {
          key: {
            boardingTxid: "",
            commitmentTxid: "",
            arkTxid: f
          },
          amount: t.amount,
          type: Mn.TxSent,
          settled: !1,
          createdAt: Date.now()
        }
      ]);
    } catch (d) {
      console.warn("error saving offchain tx to repository", d);
    } finally {
      return f;
    }
  }
  async settle(t, n) {
    if (t?.inputs) {
      for (const d of t.inputs)
        if (typeof d == "string")
          try {
            Lt.fromString(d);
          } catch {
            throw new Error(`Invalid arknote "${d}"`);
          }
    }
    if (!t) {
      const { fees: d } = await this.arkProvider.getInfo(), p = new z2(d.intentFee);
      let y = 0;
      const S = xe.decode(C.decode(this.boardingTapscript.exitScript)).params.timelock, A = (await this.getBoardingUtxos()).filter((W) => !zI(W, S)), R = [];
      for (const W of A) {
        const B = p.evalOnchainInput({
          amount: BigInt(W.value)
        });
        B.value >= W.value || (R.push(W), y += W.value - B.satoshis);
      }
      const N = await this.getVtxos({ withRecoverable: !0 }), F = [];
      for (const W of N) {
        const B = p.evalOffchainInput({
          amount: BigInt(W.value),
          type: W.virtualStatus.state === "swept" ? "recoverable" : "vtxo",
          weight: 0,
          birth: W.createdAt,
          expiry: W.virtualStatus.batchExpiry ? new Date(W.virtualStatus.batchExpiry * 1e3) : /* @__PURE__ */ new Date()
        });
        B.value >= W.value || (F.push(W), y += W.value - B.satoshis);
      }
      const w = [...R, ...F];
      if (w.length === 0)
        throw new Error("No inputs found");
      const K = {
        address: await this.getAddress(),
        amount: BigInt(y)
      }, U = p.evalOffchainOutput({
        amount: K.amount,
        script: C.encode(pi.decode(K.address).pkScript)
      });
      if (K.amount -= BigInt(U.satoshis), K.amount <= this.dustAmount)
        throw new Error("Output amount is below dust limit");
      t = {
        inputs: w,
        outputs: [K]
      };
    }
    const r = [], i = [];
    let s = !1;
    for (const [d, p] of t.outputs.entries()) {
      let y;
      try {
        y = pi.decode(p.address).pkScript, s = !0;
      } catch {
        const x = Gn(this.network).decode(p.address);
        y = It.encode(x), r.push(d);
      }
      i.push({
        amount: p.amount,
        script: y
      });
    }
    let o;
    const a = [];
    s && (o = this.identity.signerSession(), a.push(C.encode(await o.getPublicKey())));
    const [c, u] = await Promise.all([
      this.makeRegisterIntentSignature(t.inputs, i, r, a),
      this.makeDeleteIntentSignature(t.inputs)
    ]), l = await this.safeRegisterIntent(c), f = [
      ...a,
      ...t.inputs.map((d) => `${d.txid}:${d.vout}`)
    ], h = this.createBatchHandler(l, t.inputs, o), g = new AbortController();
    try {
      const d = this.arkProvider.getEventStream(g.signal, f);
      return await If.join(d, h, {
        abortController: g,
        skipVtxoTreeSigning: !s,
        eventCallback: n ? (p) => Promise.resolve(n(p)) : void 0
      });
    } catch (d) {
      throw await this.arkProvider.deleteIntent(u).catch(() => {
      }), d;
    } finally {
      g.abort();
    }
  }
  async handleSettlementFinalizationEvent(t, n, r, i) {
    const s = [], o = await this.getVirtualCoins();
    let a = Xt.fromPSBT(ut.decode(t.commitmentTx)), c = !1, u = 0;
    const l = i?.leaves() || [];
    for (const f of n) {
      const h = o.find((A) => A.txid === f.txid && A.vout === f.vout);
      if (!h) {
        for (let A = 0; A < a.inputsLength; A++) {
          const R = a.getInput(A);
          if (!R.txid || R.index === void 0)
            throw new Error("The server returned incomplete data. No settlement input found in the PSBT");
          if (C.encode(R.txid) === f.txid && R.index === f.vout) {
            a.updateInput(A, {
              tapLeafScript: [f.forfeitTapLeafScript]
            }), a = await this.identity.sign(a, [
              A
            ]), c = !0;
            break;
          }
        }
        continue;
      }
      if (eh(h) || H0(h, this.dustAmount))
        continue;
      if (l.length === 0)
        throw new Error("connectors not received");
      if (u >= l.length)
        throw new Error("not enough connectors received");
      const g = l[u], d = g.id, p = g.getOutput(0);
      if (!p)
        throw new Error("connector output not found");
      const y = p.amount, x = p.script;
      if (!y || !x)
        throw new Error("invalid connector output");
      u++;
      let S = RI([
        {
          txid: f.txid,
          index: f.vout,
          witnessUtxo: {
            amount: BigInt(h.value),
            script: Ne.decode(f.tapTree).pkScript
          },
          sighashType: _r.DEFAULT,
          tapLeafScript: [f.forfeitTapLeafScript]
        },
        {
          txid: d,
          index: 0,
          witnessUtxo: {
            amount: y,
            script: x
          }
        }
      ], r);
      S = await this.identity.sign(S, [0]), s.push(ut.encode(S.toPSBT()));
    }
    (s.length > 0 || c) && await this.arkProvider.submitSignedForfeitTxs(s, c ? ut.encode(a.toPSBT()) : void 0);
  }
  /**
   * @implements Batch.Handler interface.
   * @param intentId - The intent ID.
   * @param inputs - The inputs of the intent.
   * @param session - The musig2 signing session, if not provided, the signing will be skipped.
   */
  createBatchHandler(t, n, r) {
    let i;
    return {
      onBatchStarted: async (s) => {
        const o = new TextEncoder().encode(t), a = Bt(o), c = C.encode(a);
        let u = !0;
        for (const f of s.intentIdHashes)
          if (f === c) {
            if (!this.arkProvider)
              throw new Error("Ark provider not configured");
            await this.arkProvider.confirmRegistration(t), u = !1;
          }
        if (u)
          return { skip: u };
        const l = xe.encode({
          timelock: {
            value: s.batchExpiry,
            type: s.batchExpiry >= 512n ? "seconds" : "blocks"
          },
          pubkeys: [this.forfeitPubkey]
        }).script;
        return i = Ki(l), { skip: !1 };
      },
      onTreeSigningStarted: async (s, o) => {
        if (!r)
          return { skip: !0 };
        if (!i)
          throw new Error("Sweep tap tree root not set");
        const a = s.cosignersPublicKeys.map((d) => d.slice(2)), u = (await r.getPublicKey()).subarray(1);
        if (!a.includes(C.encode(u)))
          return { skip: !0 };
        const l = Xt.fromPSBT(ut.decode(s.unsignedCommitmentTx));
        HI(o, l, i);
        const f = l.getOutput(0);
        if (!f?.amount)
          throw new Error("Shared output not found");
        await r.init(o, i, f.amount);
        const h = C.encode(await r.getPublicKey()), g = await r.getNonces();
        return await this.arkProvider.submitTreeNonces(s.id, h, g), { skip: !1 };
      },
      onTreeNonces: async (s) => {
        if (!r)
          return { fullySigned: !0 };
        const { hasAllNonces: o } = await r.aggregatedNonces(s.txid, s.nonces);
        if (!o)
          return { fullySigned: !1 };
        const a = await r.sign(), c = C.encode(await r.getPublicKey());
        return await this.arkProvider.submitTreeSignatures(s.id, c, a), { fullySigned: !0 };
      },
      onBatchFinalization: async (s, o, a) => {
        if (!this.forfeitOutputScript)
          throw new Error("Forfeit output script not set");
        a && FI(s.commitmentTx, a), await this.handleSettlementFinalizationEvent(s, n, this.forfeitOutputScript, a);
      }
    };
  }
  async safeRegisterIntent(t) {
    try {
      return await this.arkProvider.registerIntent(t);
    } catch (n) {
      if (n instanceof V0 && n.code === 0 && n.message.includes("duplicated input")) {
        const r = await this.getVtxos({
          withRecoverable: !0
        }), i = await this.makeDeleteIntentSignature(r);
        return await this.arkProvider.deleteIntent(i), this.arkProvider.registerIntent(t);
      }
      throw n;
    }
  }
  async makeRegisterIntentSignature(t, n, r, i) {
    const s = this.prepareIntentProofInputs(t), o = {
      type: "register",
      onchain_output_indexes: r,
      valid_at: 0,
      expire_at: 0,
      cosigners_public_keys: i
    }, a = $r.create(o, s, n), c = await this.identity.sign(a);
    return {
      proof: ut.encode(c.toPSBT()),
      message: o
    };
  }
  async makeDeleteIntentSignature(t) {
    const n = this.prepareIntentProofInputs(t), r = {
      type: "delete",
      expire_at: 0
    }, i = $r.create(r, n, []), s = await this.identity.sign(i);
    return {
      proof: ut.encode(s.toPSBT()),
      message: r
    };
  }
  async makeGetPendingTxIntentSignature(t) {
    const n = this.prepareIntentProofInputs(t), r = {
      type: "get-pending-tx",
      expire_at: 0
    }, i = $r.create(r, n, []), s = await this.identity.sign(i);
    return {
      proof: ut.encode(s.toPSBT()),
      message: r
    };
  }
  /**
   * Finalizes pending transactions by retrieving them from the server and finalizing each one.
   * @param vtxos - Optional list of VTXOs to use instead of retrieving them from the server
   * @returns Array of transaction IDs that were finalized
   */
  async finalizePendingTxs(t) {
    if (!t || t.length === 0) {
      const s = [C.encode(this.offchainTapscript.pkScript)];
      let { vtxos: o } = await this.indexerProvider.getVtxos({
        scripts: s
      });
      if (o = o.filter((a) => a.virtualStatus.state !== "swept" && a.virtualStatus.state !== "settled"), o.length === 0)
        return { finalized: [], pending: [] };
      t = o.map((a) => jn(this, a));
    }
    const r = [], i = [];
    for (let s = 0; s < t.length; s += 20) {
      const o = t.slice(s, s + 20), a = await this.makeGetPendingTxIntentSignature(o), c = await this.arkProvider.getPendingTxs(a);
      for (const u of c) {
        i.push(u.arkTxid);
        try {
          const l = await Promise.all(u.signedCheckpointTxs.map(async (f) => {
            const h = Xt.fromPSBT(ut.decode(f)), g = await this.identity.sign(h);
            return ut.encode(g.toPSBT());
          }));
          await this.arkProvider.finalizeTx(u.arkTxid, l), r.push(u.arkTxid);
        } catch (l) {
          console.error(`Failed to finalize transaction ${u.arkTxid}:`, l);
        }
      }
    }
    return { finalized: r, pending: i };
  }
  prepareIntentProofInputs(t) {
    const n = [];
    for (const r of t) {
      const i = Ne.decode(r.tapTree), s = aO(r.intentTapLeafScript), o = [L0.encode(r.tapTree)];
      r.extraWitness && o.push(iI.encode(r.extraWitness)), n.push({
        txid: C.decode(r.txid),
        index: r.vout,
        witnessUtxo: {
          amount: BigInt(r.value),
          script: i.pkScript
        },
        sequence: s,
        tapLeafScript: [r.intentTapLeafScript],
        unknown: o
      });
    }
    return n;
  }
}
ws.MIN_FEE_RATE = 1;
function aO(e) {
  let t;
  try {
    const n = e[1], r = n.subarray(0, n.length - 1);
    try {
      const i = xe.decode(r).params;
      t = us.encode(i.timelock.type === "blocks" ? { blocks: Number(i.timelock.value) } : { seconds: Number(i.timelock.value) });
    } catch {
      const i = ps.decode(r).params;
      t = Number(i.absoluteTimelock);
    }
  } catch {
  }
  return t;
}
function cO(e) {
  try {
    return pi.decode(e), !0;
  } catch {
    return !1;
  }
}
function uO(e, t) {
  const n = [...e].sort((o, a) => {
    const c = o.virtualStatus.batchExpiry || Number.MAX_SAFE_INTEGER, u = a.virtualStatus.batchExpiry || Number.MAX_SAFE_INTEGER;
    return c !== u ? c - u : a.value - o.value;
  }), r = [];
  let i = 0;
  for (const o of n)
    if (r.push(o), i += o.value, i >= t)
      break;
  if (i === t)
    return { inputs: r, changeAmount: 0n };
  if (i < t)
    throw new Error("Insufficient funds");
  const s = BigInt(i - t);
  return {
    inputs: r,
    changeAmount: s
  };
}
class lO {
  constructor(t, n, { messageHandlers: r, tickIntervalMs: i = 1e4, debug: s = !1, buildServices: o }) {
    this.walletRepository = t, this.contractRepository = n, this.running = !1, this.tickTimeout = null, this.tickInProgress = !1, this.debug = !1, this.initialized = !1, this.handlers = new Map(r.map((a) => [a.messageTag, a])), this.tickIntervalMs = i, this.debug = s, this.buildServicesFn = o ?? this.buildServices.bind(this);
  }
  async start() {
    this.running || (this.running = !0, this.debug && console.log("MessageBus starting"), self.addEventListener("message", this.onMessage.bind(this)), self.addEventListener("install", () => {
      self.skipWaiting();
    }), self.addEventListener("activate", () => {
      self.clients.claim(), this.initialized && this.runTick();
    }));
  }
  async stop() {
    this.debug && console.log("MessageBus stopping"), this.running = !1, this.tickInProgress = !1, this.initialized = !1, this.tickTimeout !== null && (self.clearTimeout(this.tickTimeout), this.tickTimeout = null), self.removeEventListener("message", this.onMessage.bind(this)), await Promise.all(Array.from(this.handlers.values()).map((t) => t.stop()));
  }
  scheduleNextTick() {
    this.running && this.tickTimeout === null && (this.tickInProgress || (this.tickTimeout = self.setTimeout(() => this.runTick(), this.tickIntervalMs)));
  }
  async runTick() {
    if (this.running && !this.tickInProgress) {
      this.tickInProgress = !0, this.tickTimeout !== null && (self.clearTimeout(this.tickTimeout), this.tickTimeout = null);
      try {
        const t = Date.now();
        for (const n of this.handlers.values())
          try {
            const r = await n.tick(t);
            this.debug && console.log(`[${n.messageTag}] outgoing tick response:`, r), r && r.length > 0 && self.clients.matchAll({
              includeUncontrolled: !0,
              type: "window"
            }).then((i) => {
              for (const s of r)
                i.forEach((o) => {
                  o.postMessage(s);
                });
            });
          } catch (r) {
            this.debug && console.error(`[${n.messageTag}] tick failed`, r);
          }
      } finally {
        this.tickInProgress = !1, this.scheduleNextTick();
      }
    }
  }
  async waitForInit(t) {
    if (this.initialized)
      return;
    const n = await this.buildServicesFn(t);
    for (const r of this.handlers.values())
      this.debug && console.log(`Starting updater: ${r.messageTag}`), await r.start(n, {
        walletRepository: this.walletRepository
      });
    this.scheduleNextTick(), this.initialized = !0;
  }
  async buildServices(t) {
    const n = new M0(t.arkServer.url), r = {
      walletRepository: this.walletRepository,
      contractRepository: this.contractRepository
    };
    if ("privateKey" in t.wallet) {
      const i = Qs.fromHex(t.wallet.privateKey), s = await ws.create({
        identity: i,
        arkServerUrl: t.arkServer.url,
        arkServerPublicKey: t.arkServer.publicKey,
        storage: r
      });
      return { wallet: s, arkProvider: n, readonlyWallet: s };
    } else if ("publicKey" in t.wallet) {
      const i = pu.fromPublicKey(C.decode(t.wallet.publicKey));
      return { readonlyWallet: await yi.create({
        identity: i,
        arkServerUrl: t.arkServer.url,
        arkServerPublicKey: t.arkServer.publicKey,
        storage: r
      }), arkProvider: n };
    } else
      throw new Error("Missing privateKey or publicKey in configuration object");
  }
  async onMessage(t) {
    const { id: n, tag: r, broadcast: i } = t.data;
    if (r === "INITIALIZE_MESSAGE_BUS") {
      this.debug && console.log("Init Command received"), await this.waitForInit(t.data.config), t.source?.postMessage({ id: n, tag: r }), this.debug && console.log("MessageBus initialized");
      return;
    }
    if (!this.initialized) {
      this.debug && console.warn("Event received before initialization, dropping", t.data);
      return;
    }
    if (!n || !r) {
      this.debug && console.error("Invalid message received, missing required fields:", t.data), t.source?.postMessage({
        id: n,
        tag: r ?? "unknown",
        error: new TypeError("Invalid message received, missing required fields")
      });
      return;
    }
    if (i) {
      const o = Array.from(this.handlers.values());
      (await Promise.allSettled(o.map((c) => c.handleMessage(t.data)))).forEach((c, u) => {
        const l = o[u];
        if (c.status === "fulfilled") {
          const f = c.value;
          f && t.source?.postMessage(f);
        } else {
          this.debug && console.error(`[${l.messageTag}] handleMessage failed`, c.reason);
          const f = c.reason instanceof Error ? c.reason : new Error(String(c.reason));
          t.source?.postMessage({
            id: n,
            tag: l.messageTag,
            error: f
          });
        }
      });
      return;
    }
    const s = this.handlers.get(r);
    if (!s) {
      this.debug && console.warn(`[${r}] unknown message tag, ignoring message`);
      return;
    }
    try {
      const o = await s.handleMessage(t.data);
      this.debug && console.log(`[${r}] outgoing response:`, o), o && t.source?.postMessage(o);
    } catch (o) {
      this.debug && console.error(`[${r}] handleMessage failed`, o);
      const a = o instanceof Error ? o : new Error(String(o));
      t.source?.postMessage({ id: n, tag: r, error: a });
    }
  }
  /**
   * Returns the registered SW for the path.
   * It uses the functions in `service-worker-manager.ts` module.
   * @param path
   * @return the Service Worker
   * @throws if not running in a browser environment
   */
  static async getServiceWorker(t) {
    return Fg(t);
  }
  /**
   * Set up and register the Service Worker, ensuring it's done once at most.
   * It uses the functions in `service-worker-manager.ts` module.
   * @param path
   * @return the Service Worker
   * @throws if not running in a browser environment
   */
  static async setup(t) {
    return await aI(t), Fg(t);
  }
}
const fO = "WALLET_UPDATER";
class dO {
  /**
   * Instantiate a new WalletUpdater.
   * Can override the default `messageTag` allowing more than one updater to run in parallel.
   * Note that the default ServiceWorkerWallet sends messages to the default WalletUpdater tag.
   */
  constructor(t) {
    this.onNextTick = [], this.messageTag = t?.messageTag ?? fO;
  }
  // lifecycle methods
  async start(...t) {
    const [n, r] = t;
    this.readonlyWallet = n.readonlyWallet, this.wallet = n.wallet, this.arkProvider = n.arkProvider, this.walletRepository = r.walletRepository;
  }
  async stop() {
  }
  async tick(t) {
    const n = await Promise.allSettled(this.onNextTick.map((r) => r()));
    return this.onNextTick = [], n.map((r) => r.status === "fulfilled" ? r.value : (console.error(`[${this.messageTag}] tick failed`, r.reason), null)).filter((r) => r !== null);
  }
  scheduleForNextTick(t) {
    this.onNextTick.push(t);
  }
  requireWallet() {
    if (!this.wallet)
      throw new Error("Read-only wallet: operation requires signing");
    return this.wallet;
  }
  tagged(t) {
    return {
      ...t,
      tag: this.messageTag
    };
  }
  async handleMessage(t) {
    const n = t.id;
    if (t.type === "INIT_WALLET")
      return await this.handleInitWallet(t), this.tagged({
        id: n,
        type: "WALLET_INITIALIZED"
      });
    if (!this.readonlyWallet)
      return this.tagged({
        id: n,
        error: new Error("Wallet handler not initialized")
      });
    try {
      switch (t.type) {
        case "SETTLE": {
          const r = await this.handleSettle(t);
          return this.tagged({
            id: n,
            ...r
          });
        }
        case "SEND_BITCOIN": {
          const r = await this.handleSendBitcoin(t);
          return this.tagged({
            id: n,
            ...r
          });
        }
        case "GET_ADDRESS": {
          const r = await this.readonlyWallet.getAddress();
          return this.tagged({
            id: n,
            type: "ADDRESS",
            payload: { address: r }
          });
        }
        case "GET_BOARDING_ADDRESS": {
          const r = await this.readonlyWallet.getBoardingAddress();
          return this.tagged({
            id: n,
            type: "BOARDING_ADDRESS",
            payload: { address: r }
          });
        }
        case "GET_BALANCE": {
          const r = await this.handleGetBalance();
          return this.tagged({
            id: n,
            type: "BALANCE",
            payload: r
          });
        }
        case "GET_VTXOS": {
          const r = await this.handleGetVtxos(t);
          return {
            tag: this.messageTag,
            id: n,
            type: "VTXOS",
            payload: { vtxos: r }
          };
        }
        case "GET_BOARDING_UTXOS": {
          const r = await this.getAllBoardingUtxos();
          return this.tagged({
            id: n,
            type: "BOARDING_UTXOS",
            payload: { utxos: r }
          });
        }
        case "GET_TRANSACTION_HISTORY": {
          const r = await this.readonlyWallet.getTransactionHistory();
          return this.tagged({
            id: n,
            type: "TRANSACTION_HISTORY",
            payload: { transactions: r }
          });
        }
        case "GET_STATUS": {
          const r = await this.readonlyWallet.identity.xOnlyPublicKey();
          return this.tagged({
            id: n,
            type: "WALLET_STATUS",
            payload: {
              walletInitialized: !0,
              xOnlyPublicKey: r
            }
          });
        }
        case "CLEAR":
          return await this.clear(), this.tagged({
            id: n,
            type: "CLEAR_SUCCESS",
            payload: { cleared: !0 }
          });
        case "RELOAD_WALLET":
          return await this.onWalletInitialized(), this.tagged({
            id: n,
            type: "RELOAD_SUCCESS",
            payload: { reloaded: !0 }
          });
        case "SIGN_TRANSACTION": {
          const r = await this.handleSignTransaction(t);
          return this.tagged({
            id: n,
            ...r
          });
        }
        case "CREATE_CONTRACT": {
          const i = await (await this.readonlyWallet.getContractManager()).createContract(t.payload);
          return this.tagged({
            id: n,
            type: "CONTRACT_CREATED",
            payload: { contract: i }
          });
        }
        case "GET_CONTRACTS": {
          const i = await (await this.readonlyWallet.getContractManager()).getContracts(t.payload.filter);
          return this.tagged({
            id: n,
            type: "CONTRACTS",
            payload: { contracts: i }
          });
        }
        case "GET_CONTRACTS_WITH_VTXOS": {
          const i = await (await this.readonlyWallet.getContractManager()).getContractsWithVtxos(t.payload.filter);
          return this.tagged({
            id: n,
            type: "CONTRACTS_WITH_VTXOS",
            payload: { contracts: i }
          });
        }
        case "UPDATE_CONTRACT": {
          const i = await (await this.readonlyWallet.getContractManager()).updateContract(t.payload.script, t.payload.updates);
          return this.tagged({
            id: n,
            type: "CONTRACT_UPDATED",
            payload: { contract: i }
          });
        }
        case "DELETE_CONTRACT":
          return await (await this.readonlyWallet.getContractManager()).deleteContract(t.payload.script), this.tagged({
            id: n,
            type: "CONTRACT_DELETED",
            payload: { deleted: !0 }
          });
        case "GET_SPENDABLE_PATHS": {
          const i = await (await this.readonlyWallet.getContractManager()).getSpendablePaths(t.payload.options);
          return this.tagged({
            id: n,
            type: "SPENDABLE_PATHS",
            payload: { paths: i }
          });
        }
        case "GET_ALL_SPENDING_PATHS": {
          const i = await (await this.readonlyWallet.getContractManager()).getAllSpendingPaths(t.payload.options);
          return this.tagged({
            id: n,
            type: "ALL_SPENDING_PATHS",
            payload: { paths: i }
          });
        }
        case "IS_CONTRACT_MANAGER_WATCHING": {
          const i = await (await this.readonlyWallet.getContractManager()).isWatching();
          return this.tagged({
            id: n,
            type: "CONTRACT_WATCHING",
            payload: { isWatching: i }
          });
        }
        default:
          throw console.error("Unknown message type", t), new Error("Unknown message");
      }
    } catch (r) {
      return this.tagged({ id: n, error: r });
    }
  }
  // Wallet methods
  async handleInitWallet({ payload: t }) {
    const { arkServerUrl: n } = t;
    this.indexerProvider = new K0(n), await this.onWalletInitialized();
  }
  async handleGetBalance() {
    const [t, n, r] = await Promise.all([
      this.getAllBoardingUtxos(),
      this.getSpendableVtxos(),
      this.getSweptVtxos()
    ]);
    let i = 0, s = 0;
    for (const f of t)
      f.status.confirmed ? i += f.value : s += f.value;
    let o = 0, a = 0, c = 0;
    for (const f of n)
      f.virtualStatus.state === "settled" ? o += f.value : f.virtualStatus.state === "preconfirmed" && (a += f.value);
    for (const f of r)
      qi(f) && (c += f.value);
    const u = i + s, l = o + a + c;
    return {
      boarding: {
        confirmed: i,
        unconfirmed: s,
        total: u
      },
      settled: o,
      preconfirmed: a,
      available: o + a,
      recoverable: c,
      total: u + l
    };
  }
  async getAllBoardingUtxos() {
    return this.readonlyWallet ? this.readonlyWallet.getBoardingUtxos() : [];
  }
  /**
   * Get spendable vtxos for the current wallet address
   */
  async getSpendableVtxos() {
    return this.readonlyWallet ? (await this.readonlyWallet.getVtxos()).filter(qi) : [];
  }
  /**
   * Get swept vtxos for the current wallet address
   */
  async getSweptVtxos() {
    return this.readonlyWallet ? (await this.readonlyWallet.getVtxos()).filter((n) => n.virtualStatus.state === "swept") : [];
  }
  async onWalletInitialized() {
    if (!this.readonlyWallet || !this.arkProvider || !this.indexerProvider || !this.walletRepository)
      return;
    const t = this.readonlyWallet.defaultContractScript, r = (await this.indexerProvider.getVtxos({
      scripts: [t]
    })).vtxos.map((c) => jn(this.readonlyWallet, c));
    if (this.wallet)
      try {
        const { pending: c, finalized: u } = await this.wallet.finalizePendingTxs(r.filter((l) => l.virtualStatus.state !== "swept" && l.virtualStatus.state !== "settled"));
        console.info(`Recovered ${u.length}/${c.length} pending transactions: ${u.join(", ")}`);
      } catch (c) {
        console.error("Error recovering pending transactions:", c);
      }
    const i = await this.readonlyWallet.getAddress();
    await this.walletRepository.saveVtxos(i, r);
    const s = await this.readonlyWallet.getBoardingAddress(), o = await this.readonlyWallet.onchainProvider.getCoins(s);
    await this.walletRepository.saveUtxos(s, o.map((c) => $f(this.readonlyWallet, c)));
    const a = await this.readonlyWallet.getTransactionHistory();
    a && await this.walletRepository.saveTransactions(i, a), this.incomingFundsSubscription && this.incomingFundsSubscription(), this.incomingFundsSubscription = await this.readonlyWallet.notifyIncomingFunds(async (c) => {
      if (c.type === "vtxo") {
        const u = c.newVtxos.length > 0 ? c.newVtxos.map((f) => jn(this.readonlyWallet, f)) : [], l = c.spentVtxos.length > 0 ? c.spentVtxos.map((f) => jn(this.readonlyWallet, f)) : [];
        if ([...u, ...l].length === 0)
          return;
        await this.walletRepository?.saveVtxos(i, [
          ...u,
          ...l
        ]), this.scheduleForNextTick(() => this.tagged({
          type: "VTXO_UPDATE",
          broadcast: !0,
          payload: { newVtxos: u, spentVtxos: l }
        }));
      }
      if (c.type === "utxo") {
        const u = c.coins.map((f) => $f(this.readonlyWallet, f)), l = await this.readonlyWallet.getBoardingAddress();
        await this.walletRepository?.saveUtxos(l, u), this.scheduleForNextTick(() => this.tagged({
          type: "UTXO_UPDATE",
          broadcast: !0,
          payload: { coins: u }
        }));
      }
    }), await this.ensureContractEventBroadcasting();
  }
  async handleSettle(t) {
    const r = await this.requireWallet().settle(t.payload.params, (i) => {
      this.scheduleForNextTick(() => this.tagged({
        id: t.id,
        type: "SETTLE_EVENT",
        payload: i
      }));
    });
    if (!r)
      throw new Error("Settlement failed");
    return { type: "SETTLE_SUCCESS", payload: { txid: r } };
  }
  async handleSendBitcoin(t) {
    const r = await this.requireWallet().sendBitcoin(t.payload);
    if (!r)
      throw new Error("Send bitcoin failed");
    return {
      type: "SEND_BITCOIN_SUCCESS",
      payload: { txid: r }
    };
  }
  async handleSignTransaction(t) {
    const n = this.requireWallet(), { tx: r, inputIndexes: i } = t.payload, s = await n.identity.sign(r, i);
    if (!s)
      throw new Error("Sign transaction failed");
    return {
      type: "SIGN_TRANSACTION",
      payload: { tx: s }
    };
  }
  async handleGetVtxos(t) {
    if (!this.readonlyWallet)
      throw new Error("Wallet handler not initialized");
    const n = await this.getSpendableVtxos(), r = this.readonlyWallet.dustAmount;
    return t.payload.filter?.withRecoverable ?? !1 ? n : n.filter((o) => !(r != null && H0(o, r) || eh(o) || F0(o)));
  }
  async clear() {
    if (this.readonlyWallet) {
      this.incomingFundsSubscription && this.incomingFundsSubscription(), this.contractEventsSubscription && (this.contractEventsSubscription(), this.contractEventsSubscription = void 0);
      try {
        await this.walletRepository?.clear();
      } catch {
        console.warn("Failed to clear vtxos from wallet repository");
      }
      this.wallet = void 0, this.readonlyWallet = void 0, this.arkProvider = void 0, this.indexerProvider = void 0;
    }
  }
  async ensureContractEventBroadcasting() {
    if (this.readonlyWallet && !this.contractEventsSubscription)
      try {
        const t = await this.readonlyWallet.getContractManager();
        this.contractEventsSubscription = t.onContractEvent((n) => {
          this.scheduleForNextTick(() => this.tagged({
            type: "CONTRACT_EVENT",
            broadcast: !0,
            payload: { event: n }
          }));
        });
      } catch (t) {
        console.error("Error subscribing to contract events:", t);
      }
  }
}
const gl = (e) => e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
class gt {
  constructor(t, n, r, i, s, o) {
    this.hasWitness = t, this.inputCount = n, this.outputCount = r, this.inputSize = i, this.inputWitnessSize = s, this.outputSize = o;
  }
  static create() {
    return new gt(!1, 0, 0, 0, 0, 0);
  }
  addP2AInput() {
    return this.inputCount++, this.inputSize += gt.INPUT_SIZE, this;
  }
  addKeySpendInput(t = !0) {
    return this.inputCount++, this.inputWitnessSize += 65 + (t ? 0 : 1), this.inputSize += gt.INPUT_SIZE, this.hasWitness = !0, this;
  }
  addP2PKHInput() {
    return this.inputCount++, this.inputWitnessSize++, this.inputSize += gt.INPUT_SIZE + gt.P2PKH_SCRIPT_SIG_SIZE, this;
  }
  addTapscriptInput(t, n, r) {
    const i = 1 + gt.BASE_CONTROL_BLOCK_SIZE + 1 + n + 1 + r;
    return this.inputCount++, this.inputWitnessSize += t + 1 + i, this.inputSize += gt.INPUT_SIZE, this.hasWitness = !0, this;
  }
  addP2WPKHOutput() {
    return this.outputCount++, this.outputSize += gt.OUTPUT_SIZE + gt.P2WPKH_OUTPUT_SIZE, this;
  }
  addP2TROutput() {
    return this.outputCount++, this.outputSize += gt.OUTPUT_SIZE + gt.P2TR_OUTPUT_SIZE, this;
  }
  /**
   * Adds an output given a raw script.
   * Cost = 8 bytes (amount) + varint(scriptLen) + scriptLen
   */
  addOutputScript(t) {
    return this.outputCount++, this.outputSize += 8 + gl(t.length) + t.length, this;
  }
  /**
   * Adds an output by decoding the address to get the exact script size.
   */
  addOutputAddress(t, n) {
    const r = Gn(n).decode(t), i = It.encode(r);
    return this.addOutputScript(i);
  }
  vsize() {
    const t = gl(this.inputCount), n = gl(this.outputCount);
    let i = (gt.BASE_TX_SIZE + t + this.inputSize + n + this.outputSize) * gt.WITNESS_SCALE_FACTOR;
    return this.hasWitness && (i += gt.WITNESS_HEADER_SIZE + this.inputWitnessSize), hO(i);
  }
}
gt.P2PKH_SCRIPT_SIG_SIZE = 108;
gt.INPUT_SIZE = 41;
gt.BASE_CONTROL_BLOCK_SIZE = 33;
gt.OUTPUT_SIZE = 9;
gt.P2WPKH_OUTPUT_SIZE = 22;
gt.BASE_TX_SIZE = 10;
gt.WITNESS_HEADER_SIZE = 2;
gt.WITNESS_SCALE_FACTOR = 4;
gt.P2TR_OUTPUT_SIZE = 34;
const hO = (e) => {
  const t = BigInt(Math.ceil(e / gt.WITNESS_SCALE_FACTOR));
  return {
    value: t,
    fee: (n) => n * t
  };
};
var Ey;
(function(e) {
  let t;
  (function(i) {
    i[i.UNROLL = 0] = "UNROLL", i[i.WAIT = 1] = "WAIT", i[i.DONE = 2] = "DONE";
  })(t = e.StepType || (e.StepType = {}));
  class n {
    constructor(s, o, a, c) {
      this.toUnroll = s, this.bumper = o, this.explorer = a, this.indexer = c;
    }
    static async create(s, o, a, c) {
      const { chain: u } = await c.getVtxoChain(s);
      return new n({ ...s, chain: u }, o, a, c);
    }
    /**
     * Get the next step to be executed
     * @returns The next step to be executed + the function to execute it
     */
    async next() {
      let s;
      const o = this.toUnroll.chain;
      for (let u = o.length - 1; u >= 0; u--) {
        const l = o[u];
        if (!(l.type === Gi.COMMITMENT || l.type === Gi.UNSPECIFIED))
          try {
            if (!(await this.explorer.getTxStatus(l.txid)).confirmed)
              return {
                type: t.WAIT,
                txid: l.txid,
                do: yO(this.explorer, l.txid)
              };
          } catch {
            s = l;
            break;
          }
      }
      if (!s)
        return {
          type: t.DONE,
          vtxoTxid: this.toUnroll.txid,
          do: () => Promise.resolve()
        };
      const a = await this.indexer.getVirtualTxs([
        s.txid
      ]);
      if (a.txs.length === 0)
        throw new Error(`Tx ${s.txid} not found`);
      const c = Dr.fromPSBT(ut.decode(a.txs[0]));
      if (s.type === Gi.TREE) {
        const u = c.getInput(0);
        if (!u)
          throw new Error("Input not found");
        const l = u.tapKeySig;
        if (!l)
          throw new Error("Tap key sig not found");
        c.updateInput(0, {
          finalScriptWitness: [l]
        });
      } else
        c.finalize();
      return {
        type: t.UNROLL,
        tx: c,
        do: gO(this.bumper, this.explorer, c)
      };
    }
    /**
     * Iterate over the steps to be executed and execute them
     * @returns An async iterator over the executed steps
     */
    async *[Symbol.asyncIterator]() {
      let s;
      do {
        s !== void 0 && await pO(1e3);
        const o = await this.next();
        await o.do(), yield o, s = o.type;
      } while (s !== t.DONE);
    }
  }
  e.Session = n;
  async function r(i, s, o) {
    const a = await i.onchainProvider.getChainTip();
    let c = await i.getVtxos({ withUnrolled: !0 });
    if (c = c.filter((x) => s.includes(x.txid)), c.length === 0)
      throw new Error("No vtxos to complete unroll");
    const u = [];
    let l = 0n;
    const f = gt.create();
    for (const x of c) {
      if (!x.isUnrolled)
        throw new Error(`Vtxo ${x.txid}:${x.vout} is not fully unrolled, use unroll first`);
      const S = await i.onchainProvider.getTxStatus(x.txid);
      if (!S.confirmed)
        throw new Error(`tx ${x.txid} is not confirmed`);
      const A = wO({ height: S.blockHeight, time: S.blockTime }, a, x);
      if (!A)
        throw new Error(`no available exit path found for vtxo ${x.txid}:${x.vout}`);
      const R = Ne.decode(x.tapTree).findLeaf(C.encode(A.script));
      if (!R)
        throw new Error(`spending leaf not found for vtxo ${x.txid}:${x.vout}`);
      l += BigInt(x.value), u.push({
        txid: x.txid,
        index: x.vout,
        tapLeafScript: [R],
        sequence: 4294967294,
        witnessUtxo: {
          amount: BigInt(x.value),
          script: Ne.decode(x.tapTree).pkScript
        },
        sighashType: _r.DEFAULT
      }), f.addTapscriptInput(64, R[1].length, Tn.encode(R[0]).length);
    }
    const h = new Dr({ version: 2 });
    for (const x of u)
      h.addInput(x);
    f.addOutputAddress(o, i.network);
    let g = await i.onchainProvider.getFeeRate();
    (!g || g < ws.MIN_FEE_RATE) && (g = ws.MIN_FEE_RATE);
    const d = f.vsize().fee(BigInt(g));
    if (d > l)
      throw new Error("fee amount is greater than the total amount");
    const p = l - d;
    if (p < BigInt(QI))
      throw new Error("send amount is less than dust amount");
    h.addOutputAddress(o, p);
    const y = await i.identity.sign(h);
    return y.finalize(), await i.onchainProvider.broadcastTransaction(y.hex), y.id;
  }
  e.completeUnroll = r;
})(Ey || (Ey = {}));
function pO(e) {
  return new Promise((t) => setTimeout(t, e));
}
function gO(e, t, n) {
  return async () => {
    const [r, i] = await e.bumpP2A(n);
    await t.broadcastTransaction(r, i);
  };
}
function yO(e, t) {
  return () => new Promise((n, r) => {
    const i = setInterval(async () => {
      try {
        (await e.getTxStatus(t)).confirmed && (clearInterval(i), n());
      } catch (s) {
        clearInterval(i), r(s);
      }
    }, 5e3);
  });
}
function wO(e, t, n) {
  const r = Ne.decode(n.tapTree).exitPaths();
  for (const i of r)
    if (i.params.timelock.type === "blocks") {
      if (t.height >= e.height + Number(i.params.timelock.value))
        return i;
    } else if (t.time >= e.time + Number(i.params.timelock.value))
      return i;
}
const mO = new lE(), bO = new uE(), EO = new kb(), xO = new lO(mO, bO, {
  messageHandlers: [
    new dO(),
    new RA(EO)
    // new SwapMessageHandler({}),
  ],
  tickIntervalMs: 5e3,
  debug: !0
});
xO.start().catch(console.error);
const fE = "arkade-cache-v1";
self.addEventListener("install", (e) => {
  e.waitUntil(caches.open(fE)), self.skipWaiting();
});
self.addEventListener("activate", (e) => {
  e.waitUntil(
    caches.keys().then((t) => Promise.all(
      t.map((n) => {
        if (n !== fE)
          return caches.delete(n);
      })
    ))
  ), self.clients.matchAll({
    includeUncontrolled: !0,
    type: "window"
  }).then((t) => {
    t.forEach((n) => {
      n.postMessage({ type: "RELOAD_PAGE" });
    });
  }), self.clients.claim();
});
